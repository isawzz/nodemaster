AGraph: "class AGraph {\r

  \  constructor() {\r

  \    this.init(...arguments);\r

  \    this.posDict = {};\r

  \  }\r

  \  init() {\r

  \    let defOptions = {\r

  \      maxZoom: 1,\r

  \      minZoom: .001,\r

  \      motionBlur: false,\r

  \      zoomingEnabled: false,\r

  \      userZoomingEnabled: false,\r

  \      panningEnabled: false,\r

  \      userPanningEnabled: false,\r

  \      boxSelectionEnabled: false,\r

  \      layout: { name: 'preset' },\r

  \      elements: [],\r

  \    };\r

  \    this.cy = cytoscape(defOptions);\r

  \  }\r

  \  clear() { this.cy.destroy(); }\r

  \  //#region access and algos\r

  \  getComponents() { return this.cy.elements().components(); }\r

  \  getComponentIds() { return this.cy.elements().components().map(x =>
  x.id()); }\r

  \  getCommonEdgeId(nid1, nid2) { return nid1 + '_' + nid2; }\r

  \  getNumComponents() { return this.cy.elements().components().length; }\r

  \  getNode(id) { return this.cy.getElementById(id); }\r

  \  getEdge(id) { return this.cy.getElementById(id); }\r

  \  getNodes() { return this.cy.nodes(); }\r

  \  getNodeIds() { return this.cy.nodes().map(x => x.id()); }\r

  \  getNodeData() { return this.cy.nodes().map(x => x.data()); }\r

  \  getNodePositions() { return this.cy.nodes.map(x => x.position()); }\r

  \  getEdges() { return this.cy.edges(); }\r

  \  getEdgeIds() { return this.cy.edges().map(x => x.id()); }\r

  \  getPosition(id) {\r

  \    let node = this.getNode(id);\r

  \    let pos = node.renderedPosition();\r

  \    return pos; \r

  \  }\r

  \  getSize(id) {\r

  \    let node = this.getNode(id);\r

  \    let pos = node.bb();\r

  \    return pos; \r

  \  }\r

  \  getProp(id, prop) { return this.cy.getElementById(id).data(prop); }\r

  \  getDegree(id) { return this.cy.getElementById(id).degree(); }\r

  \  getNodeWithMaxDegree(idlist) {\r

  \    if (nundef(idlist)) idlist = this.cy.elements().filter('node').map(x =>
  x.data().id);\r

  \    let imax = arrMinMax(idlist, x => this.getDegree(x)).imax;\r

  \    let id = idlist[imax];\r

  \    return id;\r

  \  }\r

  \  getShortestPathsFrom(id) { let res = this.cy.elements().dijkstra('#' +
  id); return res; }\r

  \  getShortestPathFromTo(nid1, nid2) {\r

  \    let funcs = this.dijkstra = this.getShortestPathsFrom(nid1);\r

  \    let path = funcs.pathTo('#' + nid2);\r

  \    return path;\r

  \  }\r

  \  getLengthOfShortestPath(nid1, nid2) {\r

  \    let funcs = this.dijkstra = this.getShortestPathsFrom(nid1);\r

  \    let len = funcs.distanceTo('#' + nid2);\r

  \    return len;\r

  \  }\r

  \  setPositionData(prop = 'center') {\r

  \    let ids = this.getNodeIds();\r

  \    for (const id of ids) {\r

  \      let pos = this.getProp(id, prop);\r

  \      if (isdef(pos)) this.setPosition(id, pos.x, pos.y);\r

  \      else return false;\r

  \    }\r

  \    return true;\r

  \  }\r

  \  sortNodesByDegree(idlist, descending = true) {\r

  \    if (nundef(idlist)) idlist = this.cy.nodes.map(x => x.data().id);\r

  \    let nodes = idlist.map(x => this.getNode(x));\r

  \    for (const n of nodes) {\r

  \      n.degree = this.getDegree(n.id());\r

  \    }\r

  \    if (descending) sortByDescending(nodes, 'degree'); else sortBy(nodes,
  'degree');\r

  \    return nodes;\r

  \  }\r

  \  storeCurrentPositions(prop = 'center') {\r

  \    for (const n of this.getNodes()) {\r

  \      let id = n.id();\r

  \      let pos = this.getPosition(id);\r

  \      this.setProp(id, prop, pos);\r

  \    }\r

  \  }\r

  \  //#endregion\r

  \  //#region add/remove nodes, edges\r

  \  addNode(data, coords) {\r

  \    if (nundef(data)) data = {};\r

  \    if (nundef(data.id)) data.id = getFruid();\r

  \    if (isdef(coords)) {\r

  \      coords.x -= this.cy.pan().x;\r

  \      coords.y -= this.cy.pan().y;\r

  \    } else { coords = { x: 0, y: 0 }; }\r

  \    var ele = this.cy.add({\r

  \      group: 'nodes',\r

  \      data: data,\r

  \      position: coords\r

  \    });\r

  \    return ele.id();\r

  \  }\r

  \  addNodes(n, datalist, coordlist) {\r

  \    let ids = [];\r

  \    if (nundef(datalist)) datalist = new Array(n).map(x => ({ id:
  getFruid() }));\r

  \    if (nundef(coordlist)) coordlist = new Array(n).map(x => ({ coords: {
  x: 0, y: 0 } }));\r

  \    for (let i = 0; i < n; i++) {\r

  \      let id = this.addNode(datalist[i], coordlist[i]);\r

  \      ids.push(id);\r

  \    }\r

  \    return ids;\r

  \  }\r

  \  addEdge(nid1, nid2, data) {\r

  \    if (nundef(data)) data = {};\r

  \    data.id = this.getCommonEdgeId(nid1, nid2);\r

  \    data.source = nid1;\r

  \    data.target = nid2;\r

  \    var ele = this.cy.add({\r

  \      group: 'edges',\r

  \      data: data,\r

  \    });\r

  \    return ele.id();\r

  \  }\r

  \  addEdges(nOrNodePairList) {\r

  \    if (isNumber(nOrNodePairList)) {\r

  \      let nids = this.getNodeIds();\r

  \      let prod = arrPairs(nids);\r

  \      nOrNodePairList = choose(prod, nOrNodePairList);\r

  \    }\r

  \    let res = [];\r

  \    for (const pair of nOrNodePairList) {\r

  \      res.push(this.addEdge(pair[0], pair[1]));\r

  \    }\r

  \    return res;\r

  \  }\r

  \  removeNode(node) { this.removeElement(node); return this.getNodeIds();
  }\r

  \  removeEdge(edge) { this.removeElement(edge); return this.getEdgeIds();
  }\r

  \  removeElement(ne) { if (!isString(ne)) ne = ne.id();
  this.cy.getElementById(ne).remove(); }\r

  \  //#endregion\r

  \  //#region modify nodes, edges (data, position...)\r

  \  setPosition(id, x, y) { this.cy.getElementById(id).position({ x: x, y: y
  }); }\r

  \  setProp(id, prop, val) { this.cy.getElementById(id).data(prop, val); }\r

  \  //#endregion\r

  }"
Board: "class Board {\r

  \  constructor(rows, cols, handler, cellStyle) {\r

  \    let styles = isdef(cellStyle) ? cellStyle : { margin: 4, w: 150, h:
  150, bg: 'white', fg: 'black' };\r

  \    this.rows = rows;\r

  \    this.cols = cols;\r

  \    let items = this.items = iGrid(this.rows, this.cols, dTable, styles);\r

  \    items.map(x => {\r

  \      let d = iDiv(x);\r

  \      mCenterFlex(d);\r

  \      d.onclick = handler;\r

  \    });\r

  \  }\r

  \  get(ir, c) {\r

  \    if (isdef(c)) {\r

  \      let idx = ir * this.cols + c;\r

  \      return this.items[idx];\r

  \    } else {\r

  \      return this.items[ir];\r

  \    }\r

  \  }\r

  \  getState() {\r

  \    return this.items.map(x => x.label);\r

  \  }\r

  \  setState(arr, colors) {\r

  \    if (isEmpty(arr)) return;\r

  \    if (isList(arr[0])) { arr = arrFlatten(arr); }\r

  \    for (let i = 0; i < arr.length; i++) {\r

  \      let item = this.items[i];\r

  \      let val = arr[i];\r

  \      if (!EmptyFunc(val)) {\r

  \        addLabel(item, val, { fz: 60, fg: colors[val] });\r

  \      } else item.label = val;\r

  \    }\r

  \  }\r

  \  clear() {\r

  \    for (const item of this.items) {\r

  \      let dLabel = iLabel(item);\r

  \      if (isdef(dLabel)) { removeLabel(item); item.label = null; }\r

  \    }\r

  \  }\r

  }"
Board2D: "class Board2D {\r

  \  constructor(rows, cols, dParent, cellStyles, boardStyles, handler) {\r

  \    cellStyles = this.cellStyles = isdef(cellStyles) ? cellStyles : {
  margin: 4, w: 150, h: 150, bg: 'white', fg: 'black' };\r

  \    boardStyles = this.boardStyles = isdef(boardStyles) ? boardStyles : {
  bg: 'silver', fg: 'black' };\r

  \    this.rows = rows;\r

  \    this.cols = cols;\r

  \    this.dParent = dParent;\r

  \    let dBoard = this.dBoard = mDiv(dParent);\r

  \    let items = this.items = this.fill(dBoard, this.rows, this.cols, null,
  cellStyles);\r

  \  }\r

  \  fill(d, rows, cols, items, cellStyles) {\r

  \    if (nundef(items)) items = [];\r

  \    clearElement(d);\r

  \    mStyle(d, { display: 'grid', 'grid-template-columns': cols });\r

  \    for (let i = 0; i < rows * cols; i++) {\r

  \      let item = items[i];\r

  \      if (isdef(item)) {\r

  \        let d1 = iDiv(item);\r

  \        if (isdef(d1)) mAppend(d, iDiv(item));\r

  \        else {\r

  \          d1 = mDiv(d, cellStyles); iAdd(item, { div: d1 }); mAppend(d,
  d1);\r

  \        }\r

  \      } else {\r

  \        let [r, c] = iToRowCol(i);\r

  \        item = { row: r, col: c, index: i };\r

  \        let d1 = mDiv(d, cellStyles); iAdd(item, { div: d1 }); mAppend(d,
  d1);\r

  \      }\r

  \      mStyle(iDiv(item), cellStyles);\r

  \      items.push(item)\r

  \    }\r

  \    return items;\r

  \  }\r

  \  get(ir, c) {\r

  \    if (isdef(c)) {\r

  \      let idx = ir * this.cols + c;\r

  \      return this.items[idx];\r

  \    } else {\r

  \      return this.items[ir];\r

  \    }\r

  \  }\r

  \  getState() {\r

  \    return this.items.map(x => x.label);\r

  \  }\r

  \  setState(arr, colors) {\r

  \    if (isEmpty(arr)) return;\r

  \    if (isList(arr[0])) { arr = arrFlatten(arr); }\r

  \    for (let i = 0; i < arr.length; i++) {\r

  \      let item = this.items[i];\r

  \      let val = arr[i];\r

  \      if (!EmptyFunc(val)) {\r

  \        addLabel(item, val, { fz: 60, fg: colors[val] });\r

  \      } else item.label = val;\r

  \    }\r

  \  }\r

  \  clear() {\r

  \    for (const item of this.items) {\r

  \      let dLabel = iLabel(item);\r

  \      if (isdef(dLabel)) { removeLabel(item); item.label = null; }\r

  \    }\r

  \  }\r

  }"
Card52: "class Card52 {\r

  \  static toString(c) { return c.rank + ' of ' + c.suit; }\r

  \  static _getKey(i) {\r

  \    if (i >= 52) return 'card_J1';\r

  \    let rank = Card52.getRank(i);\r

  \    let suit = Card52.getSuit(i);\r

  \    return 'card_' + rank + suit;\r

  \  }\r

  \  static _fromKey(k) {\r

  \    let ranks = 'A23456789TJQK';\r

  \    let suits = 'SHDC';\r

  \    let ir = ranks.indexOf(k[0]); \r

  \    let is = suits.indexOf(k[1]); \r

  \    return is * 13 + ir;\r

  \  }\r

  \  static getRankValue(i) { if (nundef(i)) return null; let r = i % 13;
  return r == 0 ? 12 : r - 1; }\r

  \  static getRank(i) {\r

  \    let rank = (i % 13);\r

  \    if (rank == 0) rank = 'A';\r

  \    else if (rank >= 9) rank = ['T', 'J', 'Q', 'K'][rank - 9];\r

  \    else rank = rank + 1;\r

  \    return rank;\r

  \  }\r

  \  static getSuit(i) {\r

  \    let s = ['S', 'H', 'D', 'C'][divInt(i, 13)];\r

  \    return s;\r

  \  }\r

  \  static getShortString(c) { return c.suit + c.rank; }\r

  \  static turnFaceDown(c, color) {\r

  \    if (!c.faceUp) return;\r

  \    let svgCode = C52.card_2B; \r

  \    c.div.innerHTML = svgCode;\r

  \    if (isdef(color)) c.div.children[0].children[1].setAttribute('fill',
  color);\r

  \    c.faceUp = false;\r

  \  }\r

  \  static turnFaceUp(c) {\r

  \    if (c.faceUp) return;\r

  \    c.div.innerHTML = C52[c.key];\r

  \    c.faceUp = true;\r

  \  }\r

  \  static fromSR(sr, h) { return Card52.fromShortString(sr, h); }\r

  \  static fromShortString(sr, h) {\r

  \    let key = sr[1].toUpperCase() + sr[0].toUpperCase();\r

  \    let i = Card52._fromKey(key);\r

  \    console.log('card from ', sr, 'is', key, 'i', i)\r

  \    return Card52.getItem(i, h);\r

  \  }\r

  \  static get(sr, h) { return Card52.fromSR(sr, h); }\r

  \  static getItem(i, h = 110, w) {\r

  \    if (nundef(w)) w = h * .7;\r

  \    if (nundef(i)) i = randomNumber(0, 51);\r

  \    if (isString(i) && i.length == 2) { i =
  Card52._fromKey(i[1].toUpperCase() + i[0].toUpperCase()); }\r

  \    let c = Card52._createUi(i, undefined, w, h);\r

  \    c.i = c.val = i;\r

  \    return c;\r

  \  }\r

  \  static _createUi(irankey, suit, w, h) {\r

  \    //#region set rank and suit from inputs\r

  \    let rank = irankey;\r

  \    if (nundef(irankey) && nundef(suit)) {\r

  \      [rank, suit] = Card52.randomRankSuit();\r

  \    } else if (nundef(irankey)) {\r

  \      irankey = '2';\r

  \      suit = 'B';\r

  \    } else if (nundef(suit)) {\r

  \      if (isNumber(irankey)) irankey = Card52._getKey(irankey);\r

  \      rank = irankey[5];\r

  \      suit = irankey[6];\r

  \    }\r

  \    if (rank == '10') rank = 'T';\r

  \    if (rank == '1') rank = 'A';\r

  \    if (nundef(suit)) suit = 'H'; else suit = suit[0].toUpperCase(); \r

  \    //#endregion\r

  \    //#region load svg for card_[rank][suit] (eg. card_2H)\r

  \    let cardKey = 'card_' + rank + suit;\r

  \    let svgCode = C52[cardKey]; \r

  \    svgCode = '<div>' + svgCode + '</div>';\r

  \    let el = mCreateFrom(svgCode);\r

  \    if (isdef(h) || isdef(w)) { mSize(el, w, h); }\r

  \    //#endregion\r

  \    return { rank: rank, suit: suit, key: cardKey, div: el, w: w, h: h,
  faceUp: true }; \r

  \  }\r

  \  static random() { return Card52.getItem(randomNumber(0, 51)); }\r

  \  static randomRankSuit() {\r

  \    let c = Card52.random();\r

  \    return [c.rank, c.suit];\r

  \  }\r

  \  static show(icard, dParent, h = 110, w = undefined) {\r

  \    if (isNumber(icard)) {\r

  \      if (nundef(w)) w = h * .7;\r

  \      icard = Card52.getItem(icard, h, w);\r

  \    }\r

  \    mAppend(dParent, icard.div);\r

  \  }\r

  }"
Cardz: "class Cardz {\r

  \  static toString(c) { return c.rank + ' of ' + c.suit; }\r

  \  static _getKey(i) {\r

  \    if (i >= 52) return 'card_J1';\r

  \    let rank = Card52.getRank(i);\r

  \    let suit = Card52.getSuit(i);\r

  \    return 'card_' + rank + suit;\r

  \  }\r

  \  static _fromKey(k) {\r

  \    let ranks = 'A23456789TJQK';\r

  \    let suits = 'SHDC';\r

  \    let i_rank = ranks.indexOf(k[0]); \r

  \    let i_suit = suits.indexOf(k[1]); \r

  \    return i_suit * ranks.length + i_rank;\r

  \  }\r

  \  static getRankValue(i) { if (nundef(i)) return null; let r = i % 13;
  return r == 0 ? 12 : r - 1; }\r

  \  static getRank(i) {\r

  \    let rank = (i % 13);\r

  \    if (rank == 0) rank = 'A';\r

  \    else if (rank >= 9) rank = ['T', 'J', 'Q', 'K'][rank - 9];\r

  \    else rank = rank + 1;\r

  \    return rank;\r

  \  }\r

  \  static getSuit(i) {\r

  \    let s = ['S', 'H', 'D', 'C'][divInt(i, 13)];\r

  \    return s;\r

  \  }\r

  \  static getShortString(c) { return c.suit + c.rank; }\r

  \  static turnFaceDown(c, color) {\r

  \    if (!c.faceUp) return;\r

  \    let svgCode = C52.card_2B; \r

  \    c.div.innerHTML = svgCode;\r

  \    if (isdef(color)) c.div.children[0].children[1].setAttribute('fill',
  color);\r

  \    c.faceUp = false;\r

  \  }\r

  \  static turnFaceUp(c) {\r

  \    if (c.faceUp) return;\r

  \    c.div.innerHTML = C52[c.key];\r

  \    c.faceUp = true;\r

  \  }\r

  \  static fromSR(sr) { return Card52.fromShortString(sr); }\r

  \  static fromShortString(sr) {\r

  \    let key = sr[1].toUpperCase() + sr[0].toUpperCase();\r

  \    let i = Card52._fromKey(key);\r

  \    console.log(key, 'i', i)\r

  \    return Card52.getItem(i);\r

  \  }\r

  \  static getItem(i, h = 110, w) {\r

  \    if (nundef(w)) w = h * .7;\r

  \    if (nundef(i)) i = randomNumber(0, 51);\r

  \    if (isString(i) && i.length == 2) { i =
  Card52._fromKey(i[1].toUpperCase() + i[0].toUpperCase()); }\r

  \    let c = Card52._createUi(i, undefined, w, h);\r

  \    c.i = c.val = i;\r

  \    return c;\r

  \  }\r

  \  static _createUi(irankey, suit, w, h) {\r

  \    //#region set rank and suit from inputs\r

  \    let rank = irankey;\r

  \    if (nundef(irankey) && nundef(suit)) {\r

  \      [rank, suit] = Card52.randomRankSuit();\r

  \    } else if (nundef(irankey)) {\r

  \      irankey = '2';\r

  \      suit = 'B';\r

  \    } else if (nundef(suit)) {\r

  \      if (isNumber(irankey)) irankey = Card52._getKey(irankey);\r

  \      rank = irankey[5];\r

  \      suit = irankey[6];\r

  \    }\r

  \    if (rank == '10') rank = 'T';\r

  \    if (rank == '1') rank = 'A';\r

  \    if (nundef(suit)) suit = 'H'; else suit = suit[0].toUpperCase(); \r

  \    //#endregion\r

  \    //#region load svg for card_[rank][suit] (eg. card_2H)\r

  \    let cardKey = 'card_' + rank + suit;\r

  \    let svgCode = C52[cardKey]; \r

  \    svgCode = '<div>' + svgCode + '</div>';\r

  \    let el = mCreateFrom(svgCode);\r

  \    if (isdef(h) || isdef(w)) { mSize(el, w, h); }\r

  \    //#endregion\r

  \    return { rank: rank, suit: suit, key: cardKey, div: el, w: w, h: h,
  faceUp: true }; \r

  \  }\r

  \  static random() { return Card52.getItem(randomNumber(0, 51)); }\r

  \  static randomRankSuit() {\r

  \    let c = Card52.random();\r

  \    return [c.rank, c.suit];\r

  \  }\r

  \  static show(icard, dParent, h = 110, w = undefined) {\r

  \    if (isNumber(icard)) {\r

  \      if (nundef(w)) w = h * .7;\r

  \      icard = Card52.getItem(icard, h, w);\r

  \    }\r

  \    mAppend(dParent, icard.div);\r

  \  }\r

  }"
DeckClass: "class DeckClass {\r

  \  constructor(f) { this.data = []; if (isdef(f)) if (isString(f))
  this['init' + f](); else if (isList(f)) this.init(f); }\r

  \  init(arr) { this.data = arr; }\r

  \  initEmpty() { this.data = []; }\r

  \  initNumber(n, shuffled = true) { this.initTest(n, shuffled); }\r

  \  initTest(n, shuffled = true) { this.data = range(0, n - 1); if (shuffled)
  this.shuffle(); }\r

  \  init52(shuffled = true, jokers = 0) { this.data = range(0, 51 + jokers);
  if (shuffled) this.shuffle(); }\r

  \  init52_double(shuffled = true, jokers = 0) { this.data = range(0, 103 +
  jokers); if (shuffled) this.shuffle(); }\r

  \  init52_no_suits(n = 4, shuffled = true, jokers = 0) { this.data =
  range(0, 13 * n + jokers - 1); if (shuffled) this.shuffle(); }\r

  \  initRandomHand52(n) { this.data = choose(range(0, 51), n); }\r

  \  addTop(i) { this.data.push(i); return this; }\r

  \  addBottom(i) { this.data.unshift(i); return this; }\r

  \  bottom() { return this.data[0]; }\r

  \  cards() { return this.data; }\r

  \  count() { return this.data.length; }\r

  \  clear() { this.data = []; }\r

  \  deal(n) { return this.data.splice(0, n); }\r

  \  dealDeck(n) { let d1 = new DeckClass(); d1.init(this.data.splice(0, n));
  return d1; }\r

  \  popTop() { return this.data.pop(); }\r

  \  popBottom() { return this.data.shift(); }\r

  \  remTop() { this.data.pop(); return this; }\r

  \  remBottom() { this.data.shift(); return this; }\r

  \  remove(i) { removeInPlace(this.data, i); return this; }\r

  \  removeAtIndex(i) { return this.data.splice(i, 1)[0]; }\r

  \  removeFromIndex(i, n) { return this.data.splice(i, n); }\r

  \  setData(arr, shuffled = false) { this.data = arr; if (shuffled)
  this.shuffle(); }\r

  \  sort() {\r

  \    this.data.sort((a, b) => Number(a) - Number(b));\r

  \    return this;\r

  \  }\r

  \  shuffle() { shuffle(this.data); return this; }\r

  \  top() { return arrLast(this.data); }\r

  \  toString() { return this.data.toString(); }\r

  }"
Karte: "class Karte {\r

  \  static random(sym = 'bee', h = 220) {\r

  \    return Karte.get(sym, h);\r

  \    return Card52.random();\r

  \  }\r

  \  static c1(info, n, fg, h, w) {\r

  \    let d = mDiv();\r

  \    let svg = mgTag('svg', d, { class: 'card', face: '2C', height: '100%',
  width: '100%', preserveAspectRatio: 'none', viewBox: \"-120 -168 240 336\"
  });\r

  \    let g = mgTag('g', svg);\r

  \    let rect = mgTag('rect', g, { width: 239, height: 335, x: -120, y: 168,
  rx: 12, ry: 12, fill: \"white\", stroke: \"black\" });\r

  \    let t = mgTag('text', g, { 'text-anchor': \"middle\",
  'dominant-baseline': \"middle\", x: 0, y: 0, fill: fg }, { fz: 1000 },
  'HALLO');\r

  \    if (nundef(w)) w = h * .7;\r

  \    if (isdef(h) || isdef(w)) { mSize(d, w, h); }\r

  \    console.log('d', d)\r

  \    return { key: getUID(), div: d, w: w, h: h, faceUp: true }; \r

  \  }\r

  \  static card(info, n, fg, h, w) {\r

  \    let x = `\r

  \    <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \      face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \      <symbol id=\"${fg}${n}\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \        <text text-anchor=\"middle\" dominant-baseline=\"middle\" x=\"0\"
  y=\"0\" fill=\"${fg}\"
  style=\"font-size:1000px;font-weight:bold;\">${n}</text>        \r

  \      </symbol>\r

  \      <symbol id=\"${info.E}\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \        <text text-anchor=\"middle\" dominant-baseline=\"middle\" x=\"0\"
  y=\"-150\" fill=\"red\"
  style=\"font-size:750px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \      </symbol>\r

  \      <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>`;\r

  \    let h1 = { xs: 24, s: 27, m: 42, l: 60, xl: 70, xxl: 100 };\r

  \    let left = [0, 50, 100, 120];\r

  \    let upperLeftNumber = `<use xlink:href=\"#${fg}${n}\" height=\"42\"
  x=\"-120\" y=\"-156\"></use>`\r

  \      `<use xlink:href=\"#${info.E}\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \      <use xlink:href=\"#${info.E}\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \      <g transform=\"rotate(180)\">\r

  \        <use xlink:href=\"#${fg}${n}\" height=\"42\" x=\"-120\"
  y=\"-156\"></use>\r

  \        <use xlink:href=\"#${info.E}\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \        <use xlink:href=\"#${info.E}\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \      </g>\r

  \    </svg>`;\r

  \    let svgCode = x;\r

  \    svgCode = '<div>' + svgCode + '</div>';\r

  \    let el = mCreateFrom(svgCode);\r

  \    if (nundef(w)) w = h * .7;\r

  \    if (isdef(h) || isdef(w)) { mSize(el, w, h); }\r

  \    return { key: getUID(), div: el, w: w, h: h, faceUp: true }; \r

  \  }\r

  \  static get52(suit, rank, fg, bg, h, w, faceUp) {\r

  \    let key = suit.toLowerCase();\r

  \    let di = {\r

  \      h: 'hearts', s: 'spades', p: 'spades', c: 'clubs', t: 'clubs', d:
  'diamonds', k: 'diamonds',\r

  \      j: 'joker', '*': 'joker'\r

  \    };\r

  \    if (isdef(di[key])) key = di[key];\r

  \    let di2 = { spades: 'spade suit', hearts: 'heart suit', diamonds:
  'diamond suit', clubs: 'club suit' };\r

  \    if (isdef(di2[key])) key = di2[key];\r

  \    let info = Syms[key];\r

  \    return Karte.get(key, 300, rank, fg);\r

  \    let fz = info.family == 'emoNoto' ? 750 : 1000;\r

  \  }\r

  \  static get(sym = 'bee', h = 110, n = 2, fg = 'indigo', w) {\r

  \    let info = Syms[sym];\r

  \    n = 2;\r

  \    ensureColorNames();\r

  \    if (nundef(fg)) fg = sym == 'spades' || sym == 'clubs' ? 'black' : sym
  == 'hearts' || sym == 'diamonds' ? 'red' :
  chooseRandom(Object.keys(ColorNames)); \r

  \    let cardKey = info.family == 'emoNoto' ? 'card0' : 'card52';\r

  \    let basic = {\r

  \      card0: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <symbol id=\"${fg}${n}\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <text text-anchor=\"middle\" dominant-baseline=\"middle\"
  x=\"0\" y=\"0\" fill=\"${fg}\"
  style=\"font-size:1000px;font-weight:bold;\">${n}</text>        \r

  \          </symbol>\r

  \          <symbol id=\"${info.E}\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <text text-anchor=\"middle\" dominant-baseline=\"middle\"
  x=\"0\" y=\"-150\" fill=\"red\"
  style=\"font-size:750px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          </symbol>\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <use xlink:href=\"#${fg}${n}\" height=\"42\" x=\"-118\"
  y=\"-156\"></use>\r

  \          <use xlink:href=\"#${info.E}\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \          <use xlink:href=\"#${info.E}\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \          <g transform=\"rotate(180)\">\r

  \            <use xlink:href=\"#${fg}${n}\" height=\"42\" x=\"-118\"
  y=\"-156\"></use>\r

  \            <use xlink:href=\"#${info.E}\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \            <use xlink:href=\"#${info.E}\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \          </g>\r

  \        </svg>`,\r

  \      card52: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <symbol id=\"${fg}${n}\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <text text-anchor=\"middle\" dominant-baseline=\"middle\"
  x=\"0\" y=\"0\" fill=\"${fg}\"
  style=\"font-size:1000px;font-family:opensans;\">${n}</text>        \r

  \          </symbol>\r

  \          <symbol id=\"${info.E}\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <text text-anchor=\"middle\" dominant-baseline=\"middle\"
  x=\"0\" y=\"50\" fill=\"${fg}\"
  style=\"font-size:800px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          </symbol>\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <use xlink:href=\"#${fg}${n}\" height=\"40\" x=\"-116.4\"
  y=\"-156\"></use>\r

  \          <use xlink:href=\"#${info.E}\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \          <use xlink:href=\"#${info.E}\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \          <g transform=\"rotate(180)\">\r

  \            <use xlink:href=\"#${fg}${n}\" height=\"40\" x=\"-116.4\"
  y=\"-156\"></use>\r

  \            <use xlink:href=\"#${info.E}\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \            <use xlink:href=\"#${info.E}\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \          </g>\r

  \        </svg>`,\r

  \      card7: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <symbol id=\"VC2\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <text text-anchor=\"middle\" dominant-baseline=\"middle\"
  x=\"0\" y=\"0\" fill=\"red\"
  style=\"font-size:750px;font-family:opensans;\">A</text>        \r

  \          </symbol>\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <use xlink:href=\"#VC2\" height=\"32\" x=\"-114.4\"
  y=\"-156\"></use>\r

  \          <use xlink:href=\"#VC2\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \          <use xlink:href=\"#VC2\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \          <g transform=\"rotate(180)\">\r

  \            <use xlink:href=\"#VC2\" height=\"32\" x=\"-114.4\"
  y=\"-156\"></use>\r

  \            <use xlink:href=\"#VC2\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \            <use xlink:href=\"#VC2\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \          </g>\r

  \        </svg>`,\r

  \      card6: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <symbol id=\"VC2\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <text text-anchor=\"middle\" dominant-baseline=\"middle\"
  x=\"0\" y=\"0\" fill=\"red\"
  style=\"font-size:750px;font-family:opensans;\">A</text>        \r

  \          </symbol>\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <use xlink:href=\"#VC2\" height=\"32\" x=\"-114.4\"
  y=\"-156\"></use>\r

  \        </svg>`,\r

  \      card5: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <symbol id=\"SC2\" viewBox=\"-600 -600 1200 1200\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <path d=\"M30 150C35 385 85 400 130 500L-130 500C-85 400 -35
  385 -30 150A10 10 0 0 0 -50 150A210 210 0 1 1 -124 -51A10 10 0 0 0 -110
  -65A230 230 0 1 1 110 -65A10 10 0 0 0 124 -51A210 210 0 1 1 50 150A10 10 0 0 0
  30 150Z\" \r

  \              fill=\"black\">\r

  \            </path>\r

  \          </symbol>\r

  \          <symbol id=\"VC2\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <path d=\"M-225 -225C-245 -265 -200 -460 0 -460C 200 -460 225
  -325 225 -225C225 -25 -225 160 -225 460L225 460L225 300\" \r

  \              stroke=\"black\" stroke-width=\"80\"
  stroke-linecap=\"square\" stroke-miterlimit=\"1.5\" fill=\"none\">\r

  \            </path>\r

  \          </symbol>\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <use xlink:href=\"#VC2\" height=\"32\" x=\"-114.4\"
  y=\"-156\"></use>\r

  \          <use xlink:href=\"#SC2\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \          <use xlink:href=\"#SC2\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \          <g transform=\"rotate(180)\">\r

  \            <use xlink:href=\"#VC2\" height=\"32\" x=\"-114.4\"
  y=\"-156\"></use>\r

  \            <use xlink:href=\"#SC2\" height=\"26.769\" x=\"-111.784\"
  y=\"-119\"></use>\r

  \            <use xlink:href=\"#SC2\" height=\"70\" x=\"-35\"
  y=\"-135.588\"></use>\r

  \          </g>\r

  \          <text text-anchor=\"middle\" dominant-baseline=\"middle\" x=\"0\"
  y=\"0\" fill=\"red\" style=\"font-size:16px;font-family:opensans;\">I love
  SVG!</text>        \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"blue\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"green\" transform=\"rotate(180)\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \        </svg>`,\r

  \      card4: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <symbol id=\"VC2\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <text dominant-baseline=\"hanging\" text-anchor=\"middle\"
  x=\"0\" y=\"0\" fill=\"red\"
  style=\"font-size:600px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          </symbol>\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <use xlink:href=\"#VC2\" height=\"32\" x=\"-114.4\" y=\"-156\"
  dominant-baseline=\"hanging\" text-anchor=\"middle\" ></use>\r

  \          <g transform=\"rotate(180)\">\r

  \            <use xlink:href=\"#VC2\" height=\"32\" x=\"-114.4\" y=\"-156\"
  dominant-baseline=\"hanging\" text-anchor=\"middle\" ></use>\r

  \          </g>\r

  \          <text dominant-baseline=\"hanging\" text-anchor=\"middle\"
  x=\"0\" y=\"0\" fill=\"red\"
  style=\"font-size:600px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"middle\" x=\"0\"
  y=\"0\" fill=\"red\" style=\"font-size:16px;font-family:opensans;\">I love
  SVG!</text>        \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"blue\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"green\" transform=\"rotate(180)\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \        </svg>`,\r

  \      card3: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <text dominant-baseline=\"hanging\" x=\"-114\" y=\"-156\"
  fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          <text  text-anchor=\"end\" dominant-baseline=\"hanging\"
  x=\"114\" y=\"-156\" fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"blue\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"middle\" x=\"0\"
  y=\"0\" fill=\"red\" style=\"font-size:16px;font-family:opensans;\">I love
  SVG!</text>        \r

  \          <g transform=\"rotate(180)\">\r

  \            <text dominant-baseline=\"hanging\" x=\"-114\" y=\"-156\"
  fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \            <text  text-anchor=\"end\" dominant-baseline=\"hanging\"
  x=\"114\" y=\"-156\" fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \            <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"blue\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \          </g>\r

  \        </svg>`,\r

  \      card2: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <symbol id=\"VC2\" viewBox=\"-500 -500 1000 1000\"
  preserveAspectRatio=\"xMinYMid\">\r

  \            <text text-anchor=\"middle\" dominant-baseline=\"middle\"
  x=\"0\" y=\"0\" fill=\"red\"
  style=\"font-size:500px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          </symbol>\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <text dominant-baseline=\"hanging\" x=\"-114\" y=\"-156\"
  fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          <text  text-anchor=\"end\" dominant-baseline=\"hanging\"
  x=\"114\" y=\"-156\" fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"blue\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \          <text text-anchor=\"middle\" dominant-baseline=\"middle\" x=\"0\"
  y=\"0\" fill=\"red\" style=\"font-size:16px;font-family:opensans;\">I love
  SVG!</text>        \r

  \          <g transform=\"rotate(180)\">\r

  \            <text dominant-baseline=\"hanging\" x=\"-114\" y=\"-156\"
  fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \            <text  text-anchor=\"end\" dominant-baseline=\"hanging\"
  x=\"114\" y=\"-156\" fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \            <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"blue\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \          </g>\r

  \        </svg>`,\r

  \      card1: `\r

  \        <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" \r

  \        face=\"2C\" height=\"100%\" preserveAspectRatio=\"none\"
  viewBox=\"-120 -168 240 336\" width=\"100%\">\r

  \          <symbol id=\"VC2\">\r

  \          </symbol>\r

  \          <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\"
  rx=\"12\" ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \          <use xlink:href=\"#VC2\" height=\"32\" x=\"-114.4\"
  y=\"-156\"></use>\r

  \          <use xlink:href=\"#VC2\" height=\"32\" x=\"0\" y=\"0\"></use>\r

  \          <text text-anchor=\"middle\" dominant-baseline=\"middle\" x=\"0\"
  y=\"0\" fill=\"red\" style=\"font-size:16px;font-family:opensans;\">I love
  SVG!</text>        \r

  \          <g transform=\"rotate(180)\">\r

  \            <text dominant-baseline=\"hanging\" x=\"-114\" y=\"-156\"
  fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \            <text text-anchor=\"end\" dominant-baseline=\"hanging\"
  x=\"114\" y=\"-156\" fill=\"red\"
  style=\"font-size:30px;font-family:${info.family};\">${info.text}</text>        \
  \r

  \            <text text-anchor=\"middle\" dominant-baseline=\"hanging\"
  x=\"0\" y=\"-156\" fill=\"blue\"
  style=\"font-size:16px;font-family:opensans;\">YES</text>        \r

  \          </g>\r

  \        </svg>`\r

  \    };\r

  \    let svgCode = basic[cardKey];\r

  \    svgCode = '<div>' + svgCode + '</div>';\r

  \    let el = mCreateFrom(svgCode);\r

  \    if (nundef(w)) w = h * .7;\r

  \    if (isdef(h) || isdef(w)) { mSize(el, w, h); }\r

  \    return { key: getUID(), div: el, w: w, h: h, faceUp: true }; \r

  \  }\r

  }"
SimpleTimer: "class SimpleTimer {\r

  \  constructor(elem, msTick, onTick, msTotal, onElapsed) {\r

  \    this.elem = elem;\r

  \    this.msTotal = this.msLeft = msTotal;\r

  \    this.onTick = onTick;\r

  \    this.onElapsed = onElapsed;\r

  \    this.interval = msTick;\r

  \    this.running = false;\r

  \    this.paused = false;\r

  \    this.TO = null;\r

  \  }\r

  \  togglePause() { if (this.paused) this.continue(); else this.pause(); }\r

  \  clear() { let elapsed = this.stop(); clearElement(this.elem); return
  elapsed; }\r

  \  continue() {\r

  \    if (!this.running) this.start();\r

  \    else if (!this.paused) return;\r

  \    else { this.paused = false; this.TO =
  setInterval(this.tickHandler.bind(this), this.interval); }\r

  \  }\r

  \  tickHandler() {\r

  \    this.msLeft -= this.interval;\r

  \    this.msElapsed = this.msTotal - this.msLeft;\r

  \    this.output();\r

  \    if (isdef(this.onTick)) this.onTick();\r

  \    if (this.msLeft <= 0) {\r

  \      this.stop();\r

  \      this.msLeft = 0;\r

  \      if (isdef(this.onElapsed)) {\r

  \        this.onElapsed(0);\r

  \      }\r

  \    }\r

  \  }\r

  \  start() {\r

  \    if (this.running) this.stop();\r

  \    this.started = new Date().now;\r

  \    this.msLeft = this.msTotal;\r

  \    this.msElapsed = 0;\r

  \    this.running = true;\r

  \    this.output();\r

  \    this.TO = setInterval(this.tickHandler.bind(this), this.interval);\r

  \  }\r

  \  output() {\r

  \    this.elem.innerHTML = timeConversion(Math.max(this.msLeft, 0),
  'msh');\r

  \  }\r

  \  stop() {\r

  \    if (!this.running) return;\r

  \    clearInterval(this.TO);\r

  \    this.TO = null;\r

  \    this.running = false;\r

  \    return this.msLeft;\r

  \  }\r

  \  pause() {\r

  \    if (this.paused || !this.running) return;\r

  \    clearInterval(this.TO);\r

  \    this.paused = true;\r

  \  }\r

  }"
UIGraph: "class UIGraph extends AGraph {\r

  \  init(dParent, styles = {}) {\r

  \    let defOptions = {\r

  \      maxZoom: 1,\r

  \      minZoom: .001,\r

  \      motionBlur: false,\r

  \      wheelSensitivity: 0.05,\r

  \      zoomingEnabled: true,\r

  \      userZoomingEnabled: true,\r

  \      panningEnabled: true,\r

  \      userPanningEnabled: true,\r

  \      boxSelectionEnabled: false,\r

  \      elements: [],\r

  \    };\r

  \    this.id = getUID();\r

  \    let dOuter = mDiv(dParent, styles.outer, this.id);\r

  \    let gStyles = valf(styles.inner, { w: 640, h: 420 });\r

  \    let dContainer = mDiv(dOuter, { position: 'relative', w: gStyles.w, h:
  gStyles.h, align: 'left' });\r

  \    let styleDict = {\r

  \      node: { 'label': 'data(label)', width: 25, height: 25,
  'background-color': 'red', color: \"#fff\", \"text-valign\": \"center\",
  \"text-halign\": \"center\" },\r

  \      edge: { width: 2, 'line-color': 'silver', 'curve-style': 'haystack',
  },\r

  \      'node.high': { 'background-color': 'yellow' },\r

  \      'node.trans': { opacity: '0.5' },\r

  \    }\r

  \    for (const ks of ['node', 'edge', 'node.high', 'node.trans']) {\r

  \      if (isdef(styles[ks])) {\r

  \        let mStyles = styles[ks];\r

  \        let cyStyles = translateStylesToCy(mStyles, ks);\r

  \        copyKeys(cyStyles, styleDict[ks]);\r

  \      }\r

  \    }\r

  \    let cyStyle = [];\r

  \    for (const k in styleDict) { cyStyle.push({ selector: k, style:
  styleDict[k] }); }\r

  \    let options = { container: dContainer, style: cyStyle };\r

  \    copyKeys(options, defOptions);\r

  \    this.cy = cytoscape(defOptions);\r

  \    iAdd(this, { div: dOuter, dCy: dContainer });\r

  \  }\r

  \  //#region layouts\r

  \  hex(rows, cols, wCell, hCell) {\r

  \    let centers = this.hexPositions = getCentersFromRowsCols('hex', rows,
  cols, wCell, hCell)[0];\r

  \    this.storePositions('hex', centers);\r

  \    this.storePositions('preset', centers);\r

  \    this.retrievePositions('hex');\r

  \    this.cy.layout({ name: 'preset' }).run();\r

  \    this.center();\r

  \  }\r

  \  hex1(rows, cols, wCell, hCell) {\r

  \    let centers = this.hexPositions = getCentersFromRowsCols('hex1', rows,
  cols, wCell, hCell)[0];\r

  \    this.storePositions('hex1', centers);\r

  \    this.storePositions('preset', centers);\r

  \    let nodes = this.getNodes();\r

  \    for (let i = 0; i < nodes.length; i++) {\r

  \      let node = nodes[i];\r

  \      let center = centers[i];\r

  \      node.data('center', center);\r

  \    }\r

  \    this.retrievePositions('hex1');\r

  \    this.cy.layout({ name: 'preset' }).run();\r

  \    this.center();\r

  \  }\r

  \  breadthfirst() { this.cy.layout({ name: 'breadthfirst', animate: true
  }).run(); }\r

  \  circle() { this.cy.layout({ name: 'circle', animate: 'end' }).run(); }\r

  \  concentric() { this.cy.layout({ name: 'concentric', animate: true
  }).run(); }\r

  \  comcola() {\r

  \    let defaults = {\r

  \      name: 'cola',\r

  \      animate: true, \r

  \      refresh: 1, \r

  \      maxSimulationTime: 4000, \r

  \      ungrabifyWhileSimulating: false, \r

  \      fit: true, \r

  \      padding: 30, \r

  \      boundingBox: undefined, \r

  \      nodeDimensionsIncludeLabels: false, \r

  \      ready: function () { }, \r

  \      stop: function () { }, \r

  \      randomize: false, \r

  \      avoidOverlap: true, \r

  \      handleDisconnected: true, \r

  \      convergenceThreshold: 0.01, \r

  \      nodeSpacing: function (node) { return 10; }, \r

  \      flow: undefined, \r

  \      alignment: undefined, \r

  \      gapInequalities: undefined, \r

  \      edgeLength: undefined, \r

  \      edgeSymDiffLength: undefined, \r

  \      edgeJaccardLength: undefined, \r

  \      unconstrIter: undefined, \r

  \      userConstIter: undefined, \r

  \      allConstIter: undefined, \r

  \      infinite: false \r

  \    };\r

  \    let options = {\r

  \      name: 'cola',\r

  \      convergenceThreshold: 100,\r

  \      boundingBox: { x1: 20, y1: 20, w: 200, h: 200 },\r

  \    };\r

  \    copyKeys(options, defaults);\r

  \    console.log(defaults.boundingBox)\r

  \    this.cy.layout(defaults).run();\r

  \  }\r

  \  cola() { this.cy.layout({ name: 'cola' }).run(); }\r

  \  cose() { this.cy.layout({ name: 'cose', animate: 'end' }).run(); }\r

  \  euler() { this.cy.layout({ name: 'euler', fit: true, padding: 25,
  animate: 'end' }).run(); }\r

  \  fcose() {\r

  \    var defaultOptions = {\r

  \      quality: \"default\",\r

  \      randomize: true,\r

  \      animate: true,\r

  \      animationDuration: 500,\r

  \      animationEasing: undefined,\r

  \      fit: true,\r

  \      padding: 30,\r

  \      nodeDimensionsIncludeLabels: false,\r

  \      uniformNodeDimensions: false,\r

  \      packComponents: true,\r

  \      step: \"all\",\r

  \      samplingType: true,\r

  \      sampleSize: 25,\r

  \      nodeSeparation: 75,\r

  \      piTol: 0.0000001,\r

  \      nodeRepulsion: node => 4500,\r

  \      idealEdgeLength: edge => 50,\r

  \      edgeElasticity: edge => 0.45,\r

  \      nestingFactor: 0.1,\r

  \      numIter: 2500,\r

  \      tile: true,\r

  \      tilingPaddingVertical: 10,\r

  \      tilingPaddingHorizontal: 10,\r

  \      gravity: 0.25,\r

  \      gravityRangeCompound: 1.5,\r

  \      gravityCompound: 1.0,\r

  \      gravityRange: 3.8,\r

  \      initialEnergyOnIncremental: 0.3,\r

  \      fixedNodeConstraint: undefined,\r

  \      alignmentConstraint: undefined,\r

  \      relativePlacementConstraint: undefined,\r

  \      ready: () => { }, \r

  \      stop: () => { }, \r

  \      name: 'fcose',\r

  \    };\r

  \    this.cy.layout(defaultOptions).run(); \r

  \  }\r

  \  gridLayout() { this.cy.layout({ name: 'grid', animate: true }).run(); }\r

  \  presetLayout_dep() {\r

  \    let hasCenterProp = this.setPositionData();\r

  \    if (!hasCenterProp) {\r

  \      console.log('no positions are preset: store first!');\r

  \    } else {\r

  \      let options = {\r

  \        name: 'preset',\r

  \        positions: undefined, \r

  \        zoom: undefined, \r

  \        pan: undefined, \r

  \        fit: true, \r

  \        padding: 30, \r

  \        animate: true, \r

  \        animationDuration: 500, \r

  \        animationEasing: undefined, \r

  \        animateFilter: function (node, i) { return true; }, \r

  \        ready: undefined, \r

  \        stop: undefined, \r

  \        transform: function (node, position) { return position; } \r

  \      };\r

  \      this.cy.layout(options);\r

  \      this.reset();\r

  \    }\r

  \  }\r

  \  presetLayout() {\r

  \    this.retrievePositions('prest');\r

  \    this.cy.layout({ name: 'preset' }).run();\r

  \    this.center();\r

  \  }\r

  \  randomLayout() { this.cy.layout({ name: 'random', animate: 'true'
  }).run(); }\r

  \  klay() {\r

  \    let klayDefaults = {\r

  \      // Following descriptions taken from
  http://layout.rtsys.informatik.uni-kiel.de:9444/Providedlayout.html?algorithm\
  =de.cau.cs.kieler.klay.layered\r

  \      addUnnecessaryBendpoints: false, \r

  \      aspectRatio: 1.6, \r

  \      borderSpacing: 20, \r

  \      compactComponents: false, \r

  \      crossingMinimization: 'LAYER_SWEEP', \r

  \      cycleBreaking: 'GREEDY', \r

  \      direction: 'UNDEFINED', \r

  \      edgeRouting: 'ORTHOGONAL', \r

  \      edgeSpacingFactor: 0.5, \r

  \      feedbackEdges: false, \r

  \      fixedAlignment: 'NONE', \r

  \      inLayerSpacingFactor: 1.0, \r

  \      layoutHierarchy: false, \r

  \      linearSegmentsDeflectionDampening: 0.3, \r

  \      mergeEdges: false, \r

  \      mergeHierarchyCrossingEdges: true, \r

  \      nodeLayering: 'NETWORK_SIMPLEX', \r

  \      nodePlacement: 'BRANDES_KOEPF', \r

  \      randomizationSeed: 1, \r

  \      routeSelfLoopInside: false, \r

  \      separateConnectedComponents: true, \r

  \      spacing: 20, \r

  \      thoroughness: 7 \r

  \    };\r

  \    var options = {\r

  \      nodeDimensionsIncludeLabels: false, \r

  \      fit: true, \r

  \      padding: 20, \r

  \      animate: true, \r

  \      animateFilter: function (node, i) { return true; }, \r

  \      animationDuration: 500, \r

  \      animationEasing: undefined, \r

  \      transform: function (node, pos) { return pos; }, \r

  \      ready: this.reset.bind(this), \r

  \      stop: undefined, \r

  \      klay: {\r

  \        addUnnecessaryBendpoints: false, \r

  \        aspectRatio: 1.6, \r

  \        borderSpacing: 20, \r

  \        compactComponents: false, \r

  \        crossingMinimization: 'LAYER_SWEEP', \r

  \        cycleBreaking: 'GREEDY', \r

  \        direction: 'UNDEFINED', \r

  \        edgeRouting: 'ORTHOGONAL', \r

  \        edgeSpacingFactor: 0.5, \r

  \        feedbackEdges: false, \r

  \        fixedAlignment: 'NONE', \r

  \        inLayerSpacingFactor: 1.0, \r

  \        layoutHierarchy: false, \r

  \        linearSegmentsDeflectionDampening: 0.3,\r

  \        mergeEdges: false, \r

  \        mergeHierarchyCrossingEdges: true, \r

  \        nodeLayering: 'NETWORK_SIMPLEX', \r

  \        nodePlacement: 'INTERACTIVE', \r

  \        randomizationSeed: 1, \r

  \        routeSelfLoopInside: false, \r

  \        separateConnectedComponents: true, \r

  \        spacing: 20, \r

  \        thoroughness: 3 \r

  \      },\r

  \      name: 'klay',\r

  \      priority: function (edge) { return null; }, \r

  \    };\r

  \    this.cy.layout(options).run();\r

  \  }\r

  \  retrievePositions(key) {\r

  \    if (nundef(key)) key = 'prest';\r

  \    let di = this.posDict[key];\r

  \    for (const n of this.getNodes()) {\r

  \      let id = n.id();\r

  \      let pos = di[id];\r

  \      if (isdef(pos)) this.setPosition(id, pos.x, pos.y);\r

  \    }\r

  \  }\r

  \  storePositions(key, poslist = []) {\r

  \    if (nundef(key)) key = 'prest';\r

  \    this.posDict[key] = {};\r

  \    let i = 0;\r

  \    for (const n of this.getNodes()) {\r

  \      let id = n.id();\r

  \      let pos = valf(poslist[i], this.getPosition(id));\r

  \      i += 1;\r

  \      this.posDict[key][id] = pos;\r

  \    }\r

  \  }\r

  \  storeSizes(key, poslist = []) {\r

  \    if (nundef(key)) key = 'size';\r

  \    this.posDict[key] = {};\r

  \    let i = 0;\r

  \    for (const n of this.getNodes()) {\r

  \      let id = n.id();\r

  \      let pos = valf(poslist[i], this.getSize(id));\r

  \      i += 1;\r

  \      this.posDict[key][id] = pos;\r

  \    }\r

  \  }\r

  \  //#endregion\r

  \  //#region zoom pan fit center\r

  \  fit() { this.cy.fit(); }\r

  \  center() { this.cy.center(); } \r

  \  reset() { this.pan0(); this.zoom1(); this.center(); this.fit(); }\r

  \  pan0() { this.cy.pan({ x: 0, y: 0 }); }\r

  \  zoom1() { this.cy.zoom(1); }\r

  \  isPan() { return this.cy.panningEnabled(); }\r

  \  isZoom() { return this.cy.zoomingEnabled(); }\r

  \  enablePanZoom() { this.pan(true); this.zoom(true); }\r

  \  pan(isOn, reset = true) {\r

  \    this.cy.panningEnabled(isOn);\r

  \    this.cy.userPanningEnabled(isOn);\r

  \    if (!isOn && reset) { this.pan0(); this.center(); }\r

  \  }\r

  \  zoom(isOn, minZoom = .25, maxZoom = 1, reset = true) {\r

  \    this.cy.zoomingEnabled(isOn);\r

  \    this.cy.userZoomingEnabled(isOn);\r

  \    if (!isOn && reset) { this.zoom1(); this.center(); }\r

  \    else if (isOn) { this.cy.minZoom(minZoom); this.cy.maxZoom(maxZoom);
  }\r

  \  }\r

  \  //#endregion\r

  \  setSizeToContent() {\r

  \    this.cy.zoomingEnabled(false);\r

  \    this.updateBounds();\r

  \  }\r

  \  updateBounds() {\r

  \    var bounds = this.cy.elements().boundingBox();\r

  \    let dContainer = this.live.dCy;\r

  \    dContainer.css('height', bounds.h + 100);\r

  \    dContainer.css('width', bounds.w + 100);\r

  \    this.cy.center();\r

  \    this.cy.resize();\r

  \    dContainer.cytoscapeEdgehandles('resize');\r

  \  }\r

  \  //#region ui functions\r

  \  enableDD() { this.enableDragging(); }\r

  \  disableDD() { this.disableDragging(); }\r

  \  enableDragging() { this.cy.nodes().grabify(); }\r

  \  disableDragging() { this.cy.nodes().ungrabify(); }\r

  \  showGraph() { }\r

  \  showControls(dWhere, lWhich) {\r

  \    if (!this.hasControls) this.addLayoutControls(dWhere, lWhich);\r

  \    if (nundef(dWhere)) dWhere = iDiv(this);\r

  \  }\r

  \  showExtent() { let bb = this.cy.elements().bb(); console.log('graph
  size:', bb.w, bb.h); }\r

  \  showSize() { this.showExtent(); }\r

  \  hideGraph() { }\r

  \  hideControls() { }\r

  \  mount() { }\r

  \  unmount() { }\r

  \  closeLayoutControls() { if (isdef(this.sb)) hide(this.sb); }\r

  \  addLayoutControls(dParent, buttonlist) {\r

  \    if (nundef(dParent)) dParent = iDiv(this);\r

  \    let buttons = {\r

  \      BFS: mButton('BFS', () => this.breadthfirst(), dParent, {},
  ['tbb']),\r

  \      circle: mButton('circle', () => this.circle(), dParent, {},
  ['tbb']),\r

  \      CC: mButton('CC', () => this.concentric(), dParent, {}, ['tbb']),\r

  \      cola: mButton('cola', () => this.comcola(), dParent, {}, ['tbb']),\r

  \      cose: mButton('cose', () => this.cose(), dParent, {}, ['tbb']),\r

  \      euler: mButton('euler', () => this.euler(), dParent, {}, ['tbb']),\r

  \      fcose: mButton('fcose', () => this.fcose(), dParent, {}, ['tbb']),\r

  \      grid: mButton('grid', () => this.gridLayout(), dParent, {},
  ['tbb']),\r

  \      klay: mButton('klay', () => this.klay(), dParent, {}, ['tbb']),\r

  \      prest: mButton('prest', () => this.presetLayout(), dParent, {},
  ['tbb']),\r

  \      rand: mButton('rand', () => this.randomLayout(), dParent, {},
  ['tbb']),\r

  \      center: mButton('center', () => this.center(), dParent, {},
  ['tbb']),\r

  \      fit: mButton('fit', () => this.fit(), dParent, {}, ['tbb']),\r

  \      reset: mButton('reset', () => this.reset(), dParent, {}, ['tbb']),\r

  \      show: mButton('show', () => this.showGraph(), dParent, {},
  ['tbb']),\r

  \      hide: mButton('hide', () => this.hideGraph(), dParent, {},
  ['tbb']),\r

  \      store: mButton('store', () => this.storeCurrentPositions(), dParent,
  {}, ['tbb']),\r

  \    };\r

  \    for (const b in buttons) {\r

  \      if (isdef(buttonlist) && !buttonlist.includes(b)) hide(buttons[b]);\r

  \    }\r

  \    return buttons;\r

  \  }\r

  \  addVisual(dParent, styles = {}) {\r

  \    if (this.hasVisual) return;\r

  \    this.hasVisual = true;\r

  \    this.id = nundef(dParent.id) ? getUID() : dParent.id;\r

  \    let styleDict = {\r

  \      node: { 'width': 25, 'height': 25, 'background-color': 'red',
  \"color\": \"#fff\", 'label': 'data(id)', \"text-valign\": \"center\",
  \"text-halign\": \"center\", },\r

  \      edge: { 'width': 2, 'line-color': 'silver', 'curve-style':
  'haystack', },\r

  \      'node.highlight': { 'background-color': 'yellow' },\r

  \      'node.trans': { 'opacity': '0.5' },\r

  \    }\r

  \    for (const ks of ['node', 'edge', 'node.highlight', 'node.trans']) {\r

  \      if (isdef(styles[ks])) {\r

  \        for (const k in styles[ks]) {\r

  \          let [prop, val] = translateToCssStyle(k, styles[ks][k], false);\r

  \          styleDict[ks][prop] = val;\r

  \        }\r

  \      }\r

  \    }\r

  \    let cyStyle = [];\r

  \    for (const k in styleDict) { cyStyle.push({ selector: k, style:
  styleDict[k] }); }\r

  \    let size = getSize(dParent);\r

  \    let d1 = mDiv(dParent, { position: 'relative', bg: 'green', w: size.w,
  left: 0, top: 0, h: size.h, align: 'left' });\r

  \    this.cy.mount(d1);\r

  \    this.cy.style(cyStyle);\r

  \    this.enablePanZoom();\r

  \    iAdd(this, { div: dParent, dCy: d1 });\r

  \  }\r

  \  //#endregion\r

  \  //#region events\r

  \  nodeEvent(evname, handler) { this.cy.on(evname, 'node', ev =>
  handler(ev.target)); }\r

  \  mStyle(elid, styles, group = 'node') {\r

  \    if (isString(elid)) elid = this.cy.getElementById(elid);\r

  \    let di = translateStylesToCy(styles, group);\r

  \    for (const k in di) {\r

  \      elid.style(k, di[k]);\r

  \    }\r

  \  }\r

  \  setLabel(id, label, styles) {\r

  \    let ele = this.cy.getElementById(id);\r

  \    ele.data('label', label);\r

  \    this.mStyle(id, styles, isdef(this.getNode(id)) ? 'node' : 'edge');\r

  \  }\r

  \  setStyle(elid, prop, val) {\r

  \    if (isString(elid)) elid = this.cy.getElementById(elid);\r

  \    elid.style(prop, val);\r

  \  }\r

  \  setClass(elid, className) {\r

  \    if (isString(elid)) elid = this.cy.getElementById(elid);\r

  \    elid.class(className);\r

  \  }\r

  \  //#endregion\r

  }"
MazeGraph: "class MazeGraph extends AGraph {\r

  \  constructor(dParent, rows, cols, sz, gap = 4) {\r

  \    super();\r

  \    [this.cols, this.rows, this.sz, this.gap] = [cols, rows, sz, gap];\r

  \    let m = this.m = this.createMaze(cols, rows, sz, gap);\r

  \    let dMaze = this.dMaze = this.createDiv(dParent, cols, rows, sz,
  gap);\r

  \    let szMaze = getSize(dMaze);\r

  \    let dGraph = this.dGraph = mDiv(dParent, { align: 'left', w: szMaze.w,
  h: szMaze.h, bg: 'pink', maleft: 20 }, 'd_graph');\r

  \    this.mazeId = dGraph.id = getUID();\r

  \    let sb = this.sb = mDiv(dParent, { w: 40 });
  mCenterCenterFlex(this.sb);\r

  \    hide(dGraph); hide(sb);\r

  \    this.items = this.createCellItems();\r

  \  }\r

  \  clear() { super.clear(); } \r

  \  getTopLeftCell() { return this.getCell(0, 0); }\r

  \  getTopRightCell() { return this.getCell(0, this.cols - 1); }\r

  \  getBottomLeftCell() { return this.getCell(this.rows - 1, 0); }\r

  \  getBottomRightCell() { return this.getCell(this.rows - 1, this.cols - 1);
  }\r

  \  getCell(row, col) { return this.matrix[row][col]; }\r

  \  getCommonId(row, col) { return '' + row + \"-\" + col; }\r

  \  getCommonIdTable(row, col) { return 'td_' + this.getCommonId(row, col);
  }\r

  \  getRCI(edgeId) {\r

  \    let [r1, c1, r2, c2] = allNumbers(edgeId).map(x => Math.abs(x));  \r

  \    let i1, i2; \r

  \    i1 = r1 < r2 ? 2 : r1 > r2 ? 0 : c1 < c2 ? 1 : 3;\r

  \    i2 = i1 == 0 ? 2 : i1 == 1 ? 3 : i1 == 2 ? 0 : 1;\r

  \    return [r1, c1, i1, r2, c2, i2];\r

  \  }\r

  \  getRelativeDirections(item1, item2) {\r

  \    let [r1, c1, r2, c2] = [item1.row, item1.col, item2.row, item2.col];\r

  \    let i1, i2; \r

  \    i1 = r1 < r2 ? 2 : r1 > r2 ? 0 : c1 < c2 ? 1 : 3;\r

  \    i2 = i1 == 0 ? 2 : i1 == 1 ? 3 : i1 == 2 ? 0 : 1;\r

  \    return [i1, i2];\r

  \  }\r

  \  createCellItems() {\r

  \    let items = [];\r

  \    this.matrix = [];\r

  \    for (let r = 0; r < this.rows; r++) {\r

  \      this.matrix[r] = [];\r

  \      for (let c = 0; c < this.cols; c++) {\r

  \        let id = this.getCommonId(r, c);\r

  \        let item = { id: id, nid: id, nodeId: id, cellId:
  this.getCommonIdTable(r, c), row: r, col: c, sz: this.sz, marr: this.m[r, c]
  };\r

  \        delete Items[id];\r

  \        iAdd(item, { div: mBy(this.getCommonIdTable(r, c)) });\r

  \        items.push(item);\r

  \        this.matrix[r][c] = item;\r

  \      }\r

  \    }\r

  \    return items;\r

  \  }\r

  \  createDiv(dParent, cols, rows, sz, gap = 1) {\r

  \    let [wCell, hCell] = [sz, sz];\r

  \    let [wTotal, hTotal] = [cols * (wCell + gap) + gap, rows * (hCell +
  gap) + gap];\r

  \    let dGridOuter = this.dMaze = mDiv(dParent, { wmin: wTotal, hmin:
  hTotal, position: 'relative' });\r

  \    let m = this.m;\r

  \    let [x, y] = [0, 0];\r

  \    let sBorder = `${gap}px solid black`;\r

  \    let noBorder = `${gap}px solid transparent`;\r

  \    this.dCells = [];\r

  \    for (var r = 0; r < m.length; r++) {\r

  \      x = 0;\r

  \      this.dCells[r] = [];\r

  \      for (var c = 0; c < m[r].length; c++) {\r

  \        let info = m[r][c];\r

  \        let dCell = mDiv(dGridOuter, { w: wCell, h: hCell, position:
  'absolute', top: y, left: x, bg: 'gray' });\r

  \        dCell.id = this.getCommonIdTable(r, c);\r

  \        dCell.style.borderTop = info[0] == 0 ? sBorder : noBorder;\r

  \        dCell.style.borderRight = info[1] == 0 ? sBorder : noBorder;\r

  \        dCell.style.borderBottom = info[2] == 0 ? sBorder : noBorder;\r

  \        dCell.style.borderLeft = info[3] == 0 ? sBorder : noBorder;\r

  \        x += wCell + gap;\r

  \        this.dCells[r].push(dCell);\r

  \      }\r

  \      y += hCell + gap;\r

  \    }\r

  \    return dGridOuter;\r

  \  }\r

  \  createDiv_orig(dParent, cols, rows, sz, gap) {\r

  \    let [wCell, hCell] = [sz, sz];\r

  \    let [wTotal, hTotal] = [cols * (wCell + gap), rows * (hCell + gap)];\r

  \    let dGridOuter = this.dMaze = mDiv(dParent, { wmin: wTotal, hmin:
  hTotal });\r

  \    let m = this.m;\r

  \    let id = 'tMaze';\r

  \    setCSSVariable('--wCell', `${wCell}px`);\r

  \    setCSSVariable('--hCell', `${hCell}px`);\r

  \    let tMaze = createElementFromHtml(`\r

  \      <table id=\"${id}\">\r

  \      <tbody></tbody>\r

  \      </table>\r

  \    `);\r

  \    mAppend(dGridOuter, tMaze);\r

  \    let sBorder = `${1}px solid black`;\r

  \    for (var i = 0; i < m.length; i++) {\r

  \      $('#tMaze > tbody').append(\"<tr>\");\r

  \      for (var j = 0; j < m[i].length; j++) {\r

  \        var selector = this.getCommonIdTable(i, j);\r

  \        $('#tMaze > tbody').append(\"<td id='\" + selector +
  \"'>&nbsp;</td>\");\r

  \        if (m[i][j][0] == 0) { $('#' + selector).css('border-top',
  sBorder); }\r

  \        if (m[i][j][1] == 0) { $('#' + selector).css('border-right',
  sBorder); }\r

  \        if (m[i][j][2] == 0) { $('#' + selector).css('border-bottom',
  sBorder); }\r

  \        if (m[i][j][3] == 0) { $('#' + selector).css('border-left',
  sBorder); }\r

  \      }\r

  \      $('tMmaze > tbody').append(\"</tr>\");\r

  \    }\r

  \    return dGridOuter;\r

  \  }\r

  \  createMaze(cols, rows, sz, gap) {\r

  \    var dxy = sz + 2 * gap;\r

  \    var offs = dxy / 2 + gap;\r

  \    var totalCells = cols * rows;\r

  \    var cells = new Array();\r

  \    var unvis = new Array();\r

  \    for (var i = 0; i < rows; i++) {\r

  \      cells[i] = new Array();\r

  \      unvis[i] = new Array();\r

  \      for (var j = 0; j < cols; j++) {\r

  \        cells[i][j] = [0, 0, 0, 0];\r

  \        let pos = { x: offs + dxy * j, y: offs + dxy * i };\r

  \        this.addNode({ id: this.getCommonId(i, j), row: i, col: j, center:
  pos }, pos);\r

  \        unvis[i][j] = true;\r

  \      }\r

  \    }\r

  \    var currentCell = [Math.floor(Math.random() * rows),
  Math.floor(Math.random() * cols)];\r

  \    var path = [currentCell];\r

  \    unvis[currentCell[0]][currentCell[1]] = false;\r

  \    var visited = 1;\r

  \    while (visited < totalCells) {\r

  \      var pot = [[currentCell[0] - 1, currentCell[1], 0, 2],\r

  \      [currentCell[0], currentCell[1] + 1, 1, 3],\r

  \      [currentCell[0] + 1, currentCell[1], 2, 0],\r

  \      [currentCell[0], currentCell[1] - 1, 3, 1]];\r

  \      var neighbors = new Array();\r

  \      for (var l = 0; l < 4; l++) {\r

  \        if (pot[l][0] > -1 && pot[l][0] < rows && pot[l][1] > -1 &&
  pot[l][1] < cols && unvis[pot[l][0]][pot[l][1]]) { neighbors.push(pot[l]); }\r

  \      }\r

  \      if (neighbors.length) {\r

  \        let next = neighbors[Math.floor(Math.random() *
  neighbors.length)];\r

  \        cells[currentCell[0]][currentCell[1]][next[2]] = 1;\r

  \        cells[next[0]][next[1]][next[3]] = 1;\r

  \        let row = currentCell[0];\r

  \        let col = currentCell[1];\r

  \        let row2 = next[0];\r

  \        let col2 = next[1];\r

  \        this.addEdge(this.getCommonId(row, col), this.getCommonId(row2,
  col2), {});\r

  \        unvis[next[0]][next[1]] = false;\r

  \        visited++;\r

  \        currentCell = [next[0], next[1]];\r

  \        path.push(currentCell);\r

  \      }\r

  \      else {\r

  \        currentCell = path.pop();\r

  \      }\r

  \    }\r

  \    return cells;\r

  \  }\r

  \  setItemBorder(item, dir) {\r

  \    let prop = getBorderPropertyForDirection(dir);\r

  \    iDiv(item).style[prop] = `${this.gap}px solid black`;\r

  \  }\r

  \  setItemColor(item, color) { mStyle(iDiv(item), { bg: color }); }\r

  \  setItemContent(item, text) { iDiv(item).innerHTML = text; }\r

  \  removeItemContent(item) { iDiv(item).innerHTML = ''; }\r

  \  disconnectCells(nid1, nid2) {\r

  \    this.removeEdge(this.getCommonEdgeId(nid1, nid2));\r

  \    let [item1, item2] = [Items[nid1], Items[nid2]];\r

  \    let [dir1, dir2] = this.getRelativeDirections(item1, item2);\r

  \    this.setItemBorder(item1, dir1);\r

  \    this.setItemBorder(item2, dir2);\r

  \  }\r

  \  cutPath(path, min, max) {\r

  \    let edges = path.edges();\r

  \    let len = edges.length;\r

  \    let [imin, imax] = [Math.floor(len * min), Math.floor(len * max)];\r

  \    let i = randomNumber(imin, imax);\r

  \    let edge = edges[i];\r

  \    let [nid1, nid2] = edge.connectedNodes().map(x => x.id());\r

  \    this.disconnectCells(nid1, nid2);\r

  \  }\r

  \  breadCrumbs(path, color = 'sienna', sz = 10) {\r

  \    for (const cell of path.nodes().map(x => Items[x.id()])) {\r

  \      mCellContent(iDiv(cell), { w: sz, h: sz, bg: color, fg: 'white',
  rounding: '50%' });\r

  \    }\r

  \  }\r

  \  colorComponents() {\r

  \    let comps = this.getComponents();\r

  \    let wheel = getColorWheel('red', comps.length);\r

  \    let i = 0;\r

  \    for (const comp of comps) {\r

  \      this.breadCrumbs(comp, wheel[i]); i += 1;\r

  \    }\r

  \  }\r

  \  showGraph() {\r

  \    this.dGraph.style.opacity = 1;\r

  \    if (this.hasVisual) { show(this.dGraph); return; }\r

  \    this.addVisual(this.dGraph);\r

  \    this.storeCurrentPositions();\r

  \    this.addLayoutControls(this.sb, ['show', 'hide', 'prest', 'grid',
  'klay', 'rand', 'euler', 'reset', 'store']);\r

  \  }\r

  \  hideGraph() {\r

  \    if (isdef(this.dGraph) && this.hasVisual) {\r

  \      this.dGraph.style.display = 'none';\r

  \    }\r

  \  }\r

  }"
Deck1: "class Deck1 extends Array {\r

  \  initTest(n, shuffled = true) { range(0, n).map(x =>
  this.push(Card52.getItem(x))); if (shuffled) this.shuffle(); }\r

  \  initEmpty() { }\r

  \  init52(shuffled = true, jokers = 0) {\r

  \    range(0, 51 + jokers).map(x => this.push(Card52.getItem(x)));\r

  \    if (shuffled) this.shuffle();\r

  \  }\r

  \  add(otherDeck) { while (otherDeck.length > 0) {
  this.unshift(otherDeck.pop()); } return this; }\r

  \  count() { return this.length; }\r

  \  static transferTopFromToBottom(d1, d2) { let c = d1.pop();
  d2.putUnderPile(c); return c; }\r

  \  deal(n) { return this.splice(0, n); }\r

  \  getIndices() { return this.map(x => x.i); }\r

  \  log() { console.log(this); }\r

  \  putUnderPile(x) { this.push(x); }\r

  \  putOnTop(x) { this.unshift(x); }\r

  \  showDeck(dParent, splay, ovPercent = 0, faceUp = undefined, contStyles =
  {}) {\r

  \    if (isdef(faceUp)) { if (faceUp == true) this.turnFaceUp(); else
  this.turnFaceDown(); }\r

  \    splayout(this, dParent, contStyles, ovPercent, splay);\r

  \  }\r

  \  shuffle() { shuffle(this); }\r

  \  topCard() { return this[this.length - 1]; }\r

  \  turnFaceUp() {\r

  \    if (isEmpty(this) || this[0].faceUp) return;\r

  \    this.map(x => Card52.turnFaceUp(x));\r

  \  }\r

  \  turnFaceDown() {\r

  \    if (isEmpty(this) || !this[0].faceUp) return;\r

  \    this.map(x => Card52.turnFaceDown(x));\r

  \  }\r

  }"
_poll: "function _poll() {\r

  \  if (nundef(U) || nundef(Z) || nundef(Z.friendly)) { console.log('poll
  without U or Z!!!', U, Z); return; }\r

  \  show_polling_signal();\r

  \  if (nundef(DA.pollCounter)) DA.pollCounter = 0; DA.pollCounter++;
  console.log('polling'); \r

  \  if (Z.game == 'feedback' && i_am_host()) {\r

  \    send_or_sim({ friendly: Z.friendly, uname: Z.uplayer, fen: Z.fen,
  write_fen: true, auto: true }, 'table');\r

  \  } else send_or_sim({ friendly: Z.friendly, uname: Z.uplayer, auto: true
  }, 'table');\r

  }"
autopoll: function autopoll(ms) { TO.poll = setTimeout(_poll, valf(ms,
  valf(Z.options.poll, 2000))); }
ensure_polling: function ensure_polling() { }
handle_result: "function handle_result(result, cmd) {\r

  \  if (result.trim() == \"\") return;\r

  \  let obj;\r

  \  try { obj = JSON.parse(result); } catch { console.log('ERROR:', result);
  }\r

  \  if (Clientdata.AUTORESET) { Clientdata.AUTORESET = false; if (result.auto
  == true) { console.log('message bounced'); return; } }\r

  \  DA.result = jsCopy(obj); \r

  \  processServerdata(obj, cmd);\r

  \  switch (cmd) {\r

  \    case \"assets\": load_assets(obj); start_with_assets(); break;\r

  \    case \"users\": show_users(); break;\r

  \    case \"tables\": show_tables(); break;\r

  \    case \"delete_table\":\r

  \    case \"delete_tables\": show_tables(); break;\r

  \    case \"table1\":\r

  \      update_table();\r

  \      console.log('cmd', cmd)\r

  \      console.log('obj', obj)\r

  \      for (const k in obj) { if (isLiteral(obj[k])) { console.log(k,
  obj[k]); } }\r

  \      clear_timeouts();\r

  \      gamestep();\r

  \      break;\r

  \    case \"gameover\":\r

  \    case \"table\":\r

  \    case \"startgame\":\r

  \      update_table();\r

  \      if (Z.skip_presentation) { Z.func.state_info(mBy('dTitleLeft'));
  autopoll(); return; }\r

  \      clear_timeouts();\r

  \      gamestep();\r

  \      break;\r

  \  }\r

  }"
load_assets: "function load_assets(obj) {\r

  \  Config = jsyaml.load(obj.config);\r

  \  Syms = jsyaml.load(obj.syms);\r

  \  SymKeys = Object.keys(Syms);\r

  \  ByGroupSubgroup = jsyaml.load(obj.symGSG);\r

  \  C52 = jsyaml.load(obj.c52);\r

  \  Cinno = jsyaml.load(obj.cinno);\r

  \  Info = jsyaml.load(obj.info);\r

  \  Sayings = jsyaml.load(obj.sayings);\r

  \  create_card_assets_c52();\r

  \  KeySets = getKeySets();\r

  \  assertion(isdef(Config), 'NO Config!!!!!!!!!!!!!!!!!!!!!!!!');\r

  }"
phpPost: "function phpPost(data, cmd) {\r

  \  if (DA.TEST1 === true && cmd == 'table') { cmd = 'table1'; }\r

  \  pollStop();\r

  \  var o = {};\r

  \  o.data = valf(data, {});\r

  \  o.cmd = cmd;\r

  \  o = JSON.stringify(o);\r

  \  if (DA.SIMSIM && (DA.exclusive || ['table', 'startgame', 'gameover',
  'tables'].includes(cmd))) {\r

  \    sendSIMSIM(o, DA.exclusive);\r

  \    FORCE_REDRAW = true;\r

  \    if (DA.exclusive) return;\r

  \  } else if (DA.simulate) {\r

  \    sendSIMSIM(o, true, true);\r

  \    FORCE_REDRAW = true;\r

  \    return;\r

  \  }\r

  \  clear_transaction();\r

  \  var xml = new XMLHttpRequest();\r

  \  loader_on();\r

  \  xml.onload = function () {\r

  \    if (xml.readyState == 4 || xml.status == 200) {\r

  \      loader_off();\r

  \      handle_result(xml.responseText, cmd);\r

  \    } else { console.log('WTF?????') }\r

  \  }\r

  \  xml.open(\"POST\", \"api.php\", true);\r

  \  xml.send(o);\r

  }"
pollStop: function pollStop() { clearTimeout(TO.poll); Clientdata.AUTORESET = true; }
processServerdata: "function processServerdata(obj, cmd) {\r

  \  if (isdef(Serverdata.table)) Serverdata.prevtable =
  jsCopy(Serverdata.table);\r

  \  if (isdef(obj.playerdata)) {\r

  \    let old_playerdata = valf(Serverdata.playerdata, []);\r

  \    let di = list2dict(old_playerdata, 'name');\r

  \    Serverdata.playerdata = if_stringified(obj.playerdata);\r

  \    Serverdata.playerdata_changed_for = [];\r

  \    for (const o of Serverdata.playerdata) {\r

  \      let old = di[o.name];\r

  \      o.state = isEmpty(o.state) ? '' : if_stringified(o.state);\r

  \      o.state1 = isEmpty(o.state1) ? '' : if_stringified(o.state1);\r

  \      o.state2 = isEmpty(o.state2) ? '' : if_stringified(o.state2);\r

  \      let changed = nundef(old) ? true : !simpleCompare(old, o);\r

  \      if (changed) {\r

  \        Serverdata.playerdata_changed_for.push(o.name);\r

  \      }\r

  \    }\r

  \  } else if (isdef(Serverdata.playerdata)) {\r

  \    Serverdata.playerdata_changed_for = Serverdata.playerdata.map(x =>
  x.name);\r

  \    Serverdata.playerdata = [];\r

  \  } else Serverdata.playerdata_changed_for = [];\r

  \  for (const k in obj) {\r

  \    if (k == 'tables') Serverdata.tables = obj.tables.map(x =>
  unpack_table(x));\r

  \    else if (k == 'table') { Serverdata.table = unpack_table(obj.table);
  }\r

  \    else if (k == 'users') Serverdata[k] = obj[k];\r

  \    else if (k == 'playerdata') continue;\r

  \    else if (cmd != 'assets') Serverdata[k] = obj[k];\r

  \  }\r

  \  if (isdef(obj.table)) {\r

  \    assertion(isdef(Serverdata.table) && obj.table.id ==
  Serverdata.table.id, 'table NOT in Serverdata or table id mismatch');\r

  \    let i = Serverdata.tables.findIndex(x => x.id == obj.table.id);\r

  \    if (i != -1) { Serverdata.tables[i] = Serverdata.table; } else
  Serverdata.tables.push(Serverdata.table);\r

  \  }\r

  \  else if (isdef(Serverdata.table)) {\r

  \    let t = Serverdata.tables.find(x => x.id == Serverdata.table.id);\r

  \    if (nundef(t)) delete Serverdata.table;\r

  \  }\r

  }"
send_or_sim: "function send_or_sim(o, cmd) {\r

  \  Counter.server += 1; \r

  \  phpPost(o, cmd);\r

  }"
stopPolling: function stopPolling() { pollStop(); }
unpack_table: "function unpack_table(table) {\r

  \  for (const k of ['players', 'fen', 'options', 'scoring']) {\r

  \    let val = table[k];\r

  \    if (isdef(table[k])) table[k] = if_stringified(val); if
  (nundef(table[k])) table[k] = {}; \r

  \  }\r

  \  if (isdef(table.modified)) { table.modified = Number(table.modified);
  table.timestamp = new Date(table.modified); table.stime =
  stringBeforeLast(table.timestamp.toString(), 'G').trim(); }\r

  \  assertion(isdef(window[table.game]), 'game function for ' + table.game +
  ' not defined in window');\r

  \  if (isdef(table.game)) { table.func = window[table.game](); }\r

  \  if (isdef(table.options.mode)) { table.mode = table.options.mode; }\r

  \  delete table.action; delete table.expected;\r

  \  return table;\r

  }"
update_table: "function update_table() {\r

  \  assertion(isdef(U), 'NO USER LOGGED IN WHEN GETTING TABLE FROM
  SERVER!!!!!!!!!!!!!!!!!!!!', U);\r

  \  if (nundef(Z) || nundef(Z.prev)) Z = { prev: {} };\r

  \  for (const wichtig of ['playerdata', 'notes', 'uplayer', 'uname',
  'friendly', 'step', 'round', 'phase', 'stage', 'timestamp', 'modified',
  'stime', 'mode', 'scoring']) {\r

  \    if (isdef(Z[wichtig])) Z.prev[wichtig] = jsCopy(Z[wichtig]);\r

  \  }\r

  \  Z.prev.turn = Clientdata.last_turn = Clientdata.this_turn;\r

  \  copyKeys(Serverdata, Z);\r

  \  if (isdef(Serverdata.table)) { copyKeys(Serverdata.table, Z);
  Z.playerlist = Z.players; copyKeys(Serverdata.table.fen, Z); }\r

  \  assertion(isdef(Z.fen), 'no fen in Z bei cmd=table or startgame!!!',
  Serverdata);\r

  \  assertion(isdef(Z.host), 'TABLE HAS NOT HOST IN
  UPDATE_TABLE!!!!!!!!!!!!!!')\r

  \  Clientdata.this_turn = Z.turn;\r

  \  set_user(U.name); \r

  \  assertion(!isEmpty(Z.turn), 'turn
  empty!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', Z.turn);\r

  \  let [fen, uname, turn, mode, host] = [Z.fen, Z.uname, Z.fen.turn, Z.mode,
  Z.host];\r

  \  let role = Z.role = !is_playing(uname, fen) ? 'spectator' :
  fen.turn.includes(uname) ? 'active' : 'inactive';\r

  \  let upl = role != 'spectator' ? uname : turn[0];\r

  \  if (Z.game == 'accuse') {\r

  \    if (isdef(Clientdata.mode)) Z.mode = Clientdata.mode;\r

  \    if (mode == 'hotseat' && turn.length > 1) {\r

  \      let next = get_next_in_list(Z.prev.uplayer, Z.turn); if (next) upl =
  next;\r

  \    } else if (turn.length > 1 && uname == host) { \r

  \      let bots = turn_has_bots_that_must_move();\r

  \      if (!isEmpty(bots)) upl = bots[0];\r

  \    } else if (uname == host && !is_human_player(turn[0])) {\r

  \      upl = turn[0];\r

  \    } else if (mode == 'hotseat') { \r

  \      upl = turn[0]; \r

  \    } \r

  \  } else {\r

  \    upl = Z.role == 'active' ? uname : turn[0];\r

  \    if (mode == 'hotseat' && turn.length > 1) { let next =
  get_next_in_list(Z.prev.uplayer, Z.turn); if (next) upl = next; }\r

  \    if (mode == 'multi' && Z.role == 'inactive' && (uname != host ||
  is_human_player(upl))) { upl = uname; }\r

  \  }\r

  \  set_player(upl, fen); \r

  \  let pl = Z.pl;\r

  \  Z.playmode = pl.playmode; \r

  \  Z.strategy = uname == pl.name ? valf(Clientdata.strategy, pl.strategy) :
  pl.strategy; \r

  \  let [uplayer, friendly, modified] = [Z.uplayer, Z.friendly,
  Z.modified];\r

  \  Z.uplayer_data = firstCond(Z.playerdata, x => x.name == Z.uplayer);\r

  \  let sametable = !FORCE_REDRAW && friendly == Z.prev.friendly && modified
  <= Z.prev.modified && uplayer == Z.prev.uplayer;\r

  \  let sameplayerdata = isEmpty(Z.playerdata_changed_for);\r

  \  let myplayerdatachanged = Z.playerdata_changed_for.includes(Z.uplayer);\r

  \  let specialcase = !i_am_host() && !i_am_acting_host() && !i_am_trigger()
  && !myplayerdatachanged;\r

  \  Z.skip_presentation = sametable && (sameplayerdata || specialcase);\r

  \  if (DA.TEST1 && DA.TEST0 && (!sametable || !sameplayerdata)) {\r

  \    console.log('======>Z.skip_presentation', Z.skip_presentation,
  '\\nplayerdata_changed_for', Z.playerdata_changed_for);\r

  \    console.log('_______ *** THE END *** ___________')\r

  \  }\r

  \  FORCE_REDRAW = false;\r

  }"
apiphp: "function apiphp(o, saveFromZ = false) {\r

  \  let [data, cmd] = [o.data, o.cmd];\r

  \  let result = {}, friendly, uname, state, player_status, fen;\r

  \  if (saveFromZ && isdef(data.friendly) && !db_table_exists(data.friendly))
  {\r

  \    let res = db_new_table(data.friendly, Z.game, Z.host,
  jsCopy(Z.playerlist), jsCopy(Z.fen), jsCopy(Z.options));\r

  \    if (isdef(Z.playerdata)) res.playerdata = jsCopy(Z.playerdata);\r

  \  }\r

  \  if (cmd == 'table') {\r

  \    if (isdef(data.auto)) result.auto = data.auto;\r

  \    friendly = data.friendly;\r

  \    uname = data.uname;\r

  \    result.status = \"table\";\r

  \    if (isdef(data.clear_players)) {\r

  \      result.playerdata = db_clear_players(friendly);\r

  \      result.status = \"clear_players\";\r

  \    } else if (isdef(data.write_player) && isdef(data.state)) {\r

  \      player_status = isdef(data.player_status) ? data.player_status :
  '';\r

  \      result.playerdata = db_write_player(friendly, uname, data.state,
  player_status);\r

  \      result.status = \"write_player\";\r

  \    } else {\r

  \      result.playerdata = db_read_playerdata(friendly);\r

  \    }\r

  \    if (isdef(data.write_fen)) {\r

  \      result.table = db_write_fen(friendly, data.fen);\r

  \      result.status += \" write_fen\";\r

  \    } else {\r

  \      result.table = db_read_table(friendly);\r

  \    }\r

  \  } else if (cmd == 'startgame') {\r

  \    let res = db_new_table(data.friendly, data.game, data.host,
  data.players, data.fen, data.options);\r

  \    result.table = res.table;\r

  \    result.playerdata = res.playerdata;\r

  \    result.status = `startgame ${data.friendly}`;\r

  \  } else if (cmd == 'tables') {\r

  \    result.tables = dict2list(GT, 'friendly').map(x => x.table);\r

  \    result.status = \"tables\";\r

  \  } else if (cmd == 'gameover') {\r

  \    result.table = db_write_fen(data.friendly, data.fen, data.scoring);\r

  \    result.status = `scored table ${data.friendly}`;\r

  \  }\r

  \  return result;\r

  }"
data_from_client: "function data_from_client(raw) {\r

  \  assertion(is_stringified(raw), 'data should be stringified
  json!!!!!!!!!!!!!!!', raw);\r

  \  let js = JSON.parse(raw);\r

  \  return js;\r

  }"
db_clear_players: "function db_clear_players(friendly) {\r

  \  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);\r

  \  let t = GT[friendly]; \r

  \  for (const pldata of t.playerdata) { pldata.state = null;
  pldata.player_status = null; }\r

  \  return t.playerdata;\r

  }"
db_new_table: "function db_new_table(friendly, game, host, players, fen,
  options) {\r

  \  let table = { friendly, game, host, players, fen, options };\r

  \  table.modified = Date.now();  \r

  \  let playerdata = [];\r

  \  for (const plname of players) {\r

  \    playerdata.push({ name: `${plname}`, state: null, player_status: null
  });\r

  \  }\r

  \  let res = { table, playerdata };\r

  \  GT[friendly] = res;\r

  \  return res;\r

  }"
db_read_playerdata: "function db_read_playerdata(friendly) {\r

  \  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);\r

  \  return GT[friendly].playerdata;\r

  }"
db_read_table: "function db_read_table(friendly) {\r

  \  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);\r

  \  return GT[friendly].table;\r

  }"
db_table_exists: function db_table_exists(friendly) { return isdef(GT[friendly]); }
db_write_fen: "function db_write_fen(friendly, fen, scoring = null) {\r

  \  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);\r

  \  let t = GT[friendly];\r

  \  let table = t.table;\r

  \  table.fen = fen; table.scoring = scoring; table.phase = isdef(scoring) ?
  'over' : '';\r

  \  table.modified = Date.now();  \r

  \  return table;\r

  }"
db_write_player: "function db_write_player(friendly, uname, state,
  player_status) {\r

  \  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);\r

  \  let t = GT[friendly];\r

  \  let pldata = firstCond(t.playerdata, x => x.name == uname);\r

  \  pldata.state = state;\r

  \  pldata.player_status = player_status;\r

  \  pldata.checked = Date.now();\r

  \  return t.playerdata;\r

  }"
get_now: function get_now() { return new Date(); }
sendSIMSIM: "function sendSIMSIM(o, exclusive = false, saveFromZ = false) {\r

  \  o = data_from_client(o);  \r

  \  let result = apiphp(o, saveFromZ); \r

  \  if (TESTING && o.cmd == 'startgame') { for (const func of DA.test.mods)
  func(result.table); }\r

  \  let res = JSON.stringify(result);\r

  \  if (exclusive) { if_hotseat_autoswitch(result); handle_result(res,
  o.cmd); } else { console.log('sendSIMSIM testresult', result); }\r

  }"
addIf: function addIf(arr, el) { if (!arr.includes(el)) arr.push(el); }
addKeys: function addKeys(ofrom, oto) { for (const k in ofrom) if
  (nundef(oto[k])) oto[k] = ofrom[k]; return oto; }
addMonthToDate: "function addMonthToDate(date, months) {\r

  \  let d = new Date(date);\r

  \  d.setMonth(d.getMonth() + months);\r

  \  return d;\r

  }"
addWeekToDate: "function addWeekToDate(date, weeks) {\r

  \  let d = new Date(date);\r

  \  d.setDate(d.getDate() + (weeks * 7));\r

  \  return d;\r

  }"
aFlip: "function aFlip(d, ms = 300, x = 0, y = 1, easing =
  'cubic-bezier(1,-0.03,.27,1)') {\r

  \  return d.animate({ transform: `scale(${2}px,${y}px)` }, { easing: easing,
  duration: ms });\r

  }"
agCircle: function agCircle(g, sz) { let r = gEllipse(sz, sz); g.appendChild(r);
  return r; }
agColoredShape: "function agColoredShape(g, shape, w, h, color) {\r

  \  SHAPEFUNCS[shape](g, w, h);\r

  \  gBg(g, color);\r

  }"
agEllipse: function agEllipse(g, w, h) { let r = gEllipse(w, h);
  g.appendChild(r); return r; }
agG: function agG(g) { let g1 = gG(); g.appendChild(g1); return g1; }
agHex: function agHex(g, w, h) { let pts = size2hex(w, h); return agPoly(g, pts); }
agLine: function agLine(g, x1, y1, x2, y2) { let r = gLine(x1, y1, x2, y2);
  g.appendChild(r); return r; }
agPoly: function agPoly(g, pts) { let r = gPoly(pts); g.appendChild(r); return r; }
agRect: function agRect(g, w, h) { let r = gRect(w, h); g.appendChild(r); return r; }
agShape: "function agShape(g, shape, w, h, color, rounding) {\r

  \  let sh = gShape(shape, w, h, color, rounding);\r

  \  g.appendChild(sh);\r

  \  return sh;\r

  }"
allNumbers: "function allNumbers(s) {\r

  \  let m =
  s.match(/\\-.\\d+|\\-\\d+|\\.\\d+|\\d+\\.\\d+|\\d+\\b|\\d+(?=\\w)/g);\r

  \  if (m) return m.map(v => Number(v)); else return null;\r

  }"
alphaToHex: "function alphaToHex(zero1) {\r

  \  zero1 = Math.round(zero1 * 100) / 100;\r

  \  var alpha = Math.round(zero1 * 255);\r

  \  var hex = (alpha + 0x10000)\r

  \    .toString(16)\r

  \    .slice(-2)\r

  \    .toUpperCase();\r

  \  var perc = Math.round(zero1 * 100);\r

  \  return hex;\r

  }"
aMove: "function aMove(d, dSource, dTarget, callback, offset, ms, easing, fade)
  {\r

  \  let b1 = getRect(dSource);\r

  \  let b2 = getRect(dTarget);\r

  \  if (nundef(offset)) offset = { x: 0, y: 0 };\r

  \  let dist = { x: b2.x - b1.x + offset.x, y: b2.y - b1.y + offset.y };\r

  \  d.style.zIndex = 100;\r

  \  let a = d.animate({ opacity: valf(fade, 1), transform:
  `translate(${dist.x}px,${dist.y}px)` }, { easing: valf(easing, 'EASE'),
  duration: ms });\r

  \  a.onfinish = () => { d.style.zIndex = iZMax(); if (isdef(callback))
  callback(); };\r

  }"
animateProperty: "function animateProperty(elem, prop, start, middle, end,
  msDuration, forwards) {\r

  \  let kflist = [];\r

  \  for (const v of [start, middle, end]) {\r

  \    let o = {};\r

  \    o[prop] = isString(v) || prop == 'opacity' ? v : '' + v + 'px';\r

  \    kflist.push(o);\r

  \  }\r

  \  let opts = { duration: msDuration };\r

  \  if (isdef(forwards)) opts.fill = forwards;\r

  \  elem.animate(kflist, opts); \r

  }"
animatePropertyX: "function animatePropertyX(elem, prop, start_middle_end,
  msDuration, forwards, easing, delay) {\r

  \  let kflist = [];\r

  \  for (const perc in start_middle_end) {\r

  \    let o = {};\r

  \    let val = start_middle_end[perc];\r

  \    o[prop] = isString(val) || prop == 'opacity' ? val : '' + val + 'px';\r

  \    kflist.push(o);\r

  \  }\r

  \  let opts = { duration: msDuration, fill: valf(forwards, 'none'), easing:
  valf(easing, 'ease-it-out'), delay: valf(delay, 0) };\r

  \  elem.animate(kflist, opts); \r

  }"
aRotate: "function aRotate(d, ms = 2000) { return d.animate({ transform:
  `rotate(360deg)` }, ms); }"
aRotateAccel: "function aRotateAccel(d, ms) { return d.animate({ transform:
  `rotate(1200deg)` }, { easing: 'cubic-bezier(.72, 0, 1, 1)', duration: ms });
  }"
arr_get_max: "function arr_get_max(arr, func) {\r

  \  if (isEmpty(arr)) return null;\r

  \  if (nundef(func)) func = x => x;\r

  \  let i = 0; let aug = arr.map(x => ({ el: jsCopy(x), val: func(x), i: i++
  }));\r

  \  sortByDescending(aug, 'val');\r

  \  let max = aug[0].val;\r

  \  let res = arrTakeWhile(aug, x => x.val == max); return res.map(x =>
  arr[x.i]);\r

  }"
arr_get_min: "function arr_get_min(arr, func) {\r

  \  if (isEmpty(arr)) return null;\r

  \  if (nundef(func)) func = x => x;\r

  \  let i = 0; let aug = arr.map(x => ({ el: jsCopy(x), val: func(x), i: i++
  }));\r

  \  sortBy(aug, 'val');\r

  \  let min = aug[0].val;\r

  \  let res = arrTakeWhile(aug, x => x.val == min); return res.map(x =>
  arr[x.i]);\r

  }"
arrBuckets: "function arrBuckets(arr, func, sortbystr) {\r

  \  let di = {};\r

  \  for (const a of arr) {\r

  \    let val = func(a);\r

  \    if (nundef(di[val])) di[val] = { val: val, list: [] };\r

  \    di[val].list.push(a);\r

  \  }\r

  \  let res = []\r

  \  let keys = get_keys(di);\r

  \  if (isdef(sortbystr)) {\r

  \    keys.sort((a, b) => sortbystr.indexOf(a) - sortbystr.indexOf(b));\r

  \  }\r

  \  return keys.map(x => di[x]);\r

  }"
arrChildren: function arrChildren(elem) { return [...toElem(elem).children]; }
arrClear: function arrClear(arr) { arr.length = 0; }
arrCount: function arrCount(arr, func) { return arr.filter(func).length; }
arrCycle: function arrCycle(arr, count) { return arrRotate(arr, count); }
arrExtend: function arrExtend(arr, list) { list.map(x => arr.push(x)); return arr; }
arrFirst: "function arrFirst(arr) { return arr.length > 0 ? arr[0] : null; }"
arrFlatten: "function arrFlatten(arr) {\r

  \  let res = [];\r

  \  for (let i = 0; i < arr.length; i++) {\r

  \    for (let j = 0; j < arr[i].length; j++) {\r

  \      res.push(arr[i][j]);\r

  \    }\r

  \  }\r

  \  return res;\r

  }"
arrFromIndex: function arrFromIndex(arr, i) { return arr.slice(i); }
arrFromTo: function arrFromTo(arr, iFrom, iTo) { return takeFromTo(arr, iFrom, iTo); }
arrFunc: function arrFunc(n, func) { let res = []; for (let i = 0; i < n; i++)
  res.push(func()); return res; }
arrIndices: "function arrIndices(arr, func) {\r

  \  let indices = [];\r

  \  for (let i = 0; i < arr.length; i++) { if (func(arr[i])) indices.push(i);
  }\r

  \  return indices;\r

  }"
arrLast: "function arrLast(arr) { return arr.length > 0 ? arr[arr.length - 1] : null; }"
arrLastOfLast: "function arrLastOfLast(arr) { if (arr.length > 0) { let l =
  arrLast(arr); return isList(l) ? arrLast(l) : null; } else return null; }"
arrMax: function arrMax(arr, f) { return arr_get_max(arr, f); }
arrMin: function arrMin(arr, f) { return arr_get_min(arr, f); }
arrMinMax: "function arrMinMax(arr, func) {\r

  \  if (nundef(func)) func = x => x;\r

  \  let min = func(arr[0]), max = func(arr[0]), imin = 0, imax = 0;\r

  \  for (let i = 1, len = arr.length; i < len; i++) {\r

  \    let v = func(arr[i]);\r

  \    if (v < min) {\r

  \      min = v; imin = i;\r

  \    } else if (v > max) {\r

  \      max = v; imax = i;\r

  \    }\r

  \  }\r

  \  return { min: min, imin: imin, max: max, imax: imax, elmin: arr[imin],
  elmax: arr[imax] };\r

  }"
arrMinus: function arrMinus(a, b) { if (isList(b)) return a.filter(x =>
  !b.includes(x)); else return a.filter(x => x != b); }
arrPlus: function arrPlus(a, b) { b.map(x => a.push(x)); return a; }
arrRange: function arrRange(from = 1, to = 10, step = 1) { let res = []; for
  (let i = from; i <= to; i += step)res.push(i); return res; }
arrRemove: "function arrRemove(arr, listweg) {\r

  \  arrReplace(arr, listweg, []);\r

  }"
arrRemoveLast: function arrRemoveLast(arr) { arr.length -= 1; }
arrRemovip: "function arrRemovip(arr, el) {\r

  \  let i = arr.indexOf(el);\r

  \  if (i > -1) arr.splice(i, 1);\r

  \  return i;\r

  }"
arrRepeat: function arrRepeat(n, el) { let res = []; for (let i = 0; i < n; i++)
  res.push(el); return res; }
arrReplace: "function arrReplace(arr, listweg, listdazu) {\r

  \  arrExtend(arr, listdazu);\r

  \  listweg.map(x => arrRemovip(arr, x));\r

  \  return arr;\r

  }"
arrReplace1: "function arrReplace1(arr, elweg, eldazu) {\r

  \  let i = arr.indexOf(elweg);\r

  \  arr[i] = eldazu;\r

  \  return arr;\r

  }"
arrReverse: function arrReverse(arr) { return jsCopy(arr).reverse(); }
arrRotate: "function arrRotate(arr, count) {\r

  \  var unshift = Array.prototype.unshift,\r

  \    splice = Array.prototype.splice;\r

  \  var len = arr.length >>> 0, count = count >> 0;\r

  \  let arr1 = jsCopy(arr);\r

  \  unshift.apply(arr1, splice.call(arr1, count % len, len));\r

  \  return arr1;\r

  }"
arrShufflip: function arrShufflip(arr) { if (isEmpty(arr)) return []; else
  return fisherYates(arr); }
arrSplitAtIndex: "function arrSplitAtIndex(arr, i) {\r

  \  return [arr.slice(0, i), arr.slice(i)];\r

  }"
arrSplitByIndices: "function arrSplitByIndices(arr, indices) {\r

  \  let [a1, a2] = [[], jsCopy(arr)];\r

  \  for (let i = 0; i < indices.length; i++) {\r

  \    let el = arr[indices[i]];\r

  \    a1.push(el);\r

  \    removeInPlace(a2, el);\r

  \  }\r

  \  return [a1, a2];\r

  }"
arrSum: function arrSum(arr, props) { if (nundef(props)) return arr.reduce((a,
  b) => a + b); if (!isList(props)) props = [props]; return arr.reduce((a, b) =>
  a + (lookup(b, props) || 0), 0); }
arrSwap: function arrSwap(arr, i, j) { let h = arr[i]; arr[i] = arr[j]; arr[j] = h; }
arrTake: "function arrTake(arr, n = 0, from = 0) {\r

  \  if (isDict(arr)) {\r

  \    let keys = Object.keys(arr);\r

  \    return n > 0 ? keys.slice(from, from + n).map(x => (arr[x])) :
  keys.slice(from).map(x => (arr[x]));\r

  \  } else return n > 0 ? arr.slice(from, from + n) : arr.slice(from);\r

  }"
arrTakeLast: "function arrTakeLast(arr, n, from = 0) {\r

  \  let res = [];\r

  \  if (isDict(arr)) {\r

  \    let keys = Object.keys(arr);\r

  \    let ilast = keys.length - 1; for (let i = ilast - from; i >= 0 && i >
  ilast - from - n; i--) { res.unshift(arr[keys[i]]); }\r

  \  } else {\r

  \    let ilast = arr.length - 1; for (let i = ilast - from; i >= 0 && i >
  ilast - from - n; i--) { res.unshift(arr[i]); }\r

  \  }\r

  \  return res;\r

  }"
arrTakeWhile: "function arrTakeWhile(arr, func) {\r

  \  let res = [];\r

  \  for (const a of arr) {\r

  \    if (func(a)) res.push(a); else break;\r

  \  }\r

  \  return res;\r

  }"
arrWithout: function arrWithout(arr, b) { return arrMinus(arr, b); }
arrZip: "function arrZip(arr1, arr2) {\r

  \  let res = [];\r

  \  for (let i = 0; i < Math.min(arr1, arr2); i++) {\r

  \    let o = {};\r

  \    addKeys(arr1[i], o);\r

  \    addKeys(arr2[i], o);\r

  \    res.push(o);\r

  \  }\r

  \  return res;\r

  }"
assertion: "function assertion(cond) {\r

  \  if (!cond) {\r

  \    let args = [...arguments];\r

  \    for (const a of args) {\r

  \      console.log('\\n', a);\r

  \    }\r

  \    throw new Error('TERMINATING!!!')\r

  \  }\r

  }"
aSvg: "function aSvg(dParent) {\r

  \  if (!dParent.style.position) dParent.style.position = 'relative';\r

  \  let svg1 = gSvg();\r

  \  svg1.setAttribute('width', '100%');\r

  \  svg1.setAttribute('height', '100%');\r

  \  let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;';\r

  \  svg1.setAttribute('style', style);\r

  \  dParent.appendChild(svg1);\r

  \  return svg1;\r

  }"
aSvgg: "function aSvgg(dParent, originInCenter = true) {\r

  \  if (!dParent.style.position) dParent.style.position = 'relative';\r

  \  let svg1 = gSvg();\r

  \  svg1.setAttribute('width', '100%');\r

  \  svg1.setAttribute('height', '100%');\r

  \  let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;';\r

  \  svg1.setAttribute('style', style);\r

  \  dParent.appendChild(svg1);\r

  \  let g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r

  \  svg1.appendChild(g1);\r

  \  if (originInCenter) { g1.style.transform = \"translate(50%, 50%)\"; } \r

  \  return g1;\r

  }"
aTranslateBy: "function aTranslateBy(d, x, y, ms) { return d.animate({
  transform: `translate(${x}px,${y}px)` }, ms); }"
aTranslateByEase: "function aTranslateByEase(d, x, y, ms, easing =
  'cubic-bezier(1,-0.03,.27,1)') {\r

  \  return d.animate({ transform: `translate(${x}px,${y}px)` }, { easing:
  easing, duration: ms });\r

  }"
aTranslateFadeBy: "function aTranslateFadeBy(d, x, y, ms) { return d.animate({
  opacity: .5, transform: `translate(${x}px,${y}px)` }, { easing: MyEasing,
  duration: ms }); }"
bottom_elem_from_to: function bottom_elem_from_to(arr1, arr2) { last_elem_from_to(arr1, arr2); }
bottom_elem_from_to_top: function bottom_elem_from_to_top(arr1, arr2) { arr2.unshift(arr1.pop()); }
calculateDaysBetweenDates: "function calculateDaysBetweenDates(begin, end) {\r

  \  var oneDay = 24 * 60 * 60 * 1000; \r

  \  var firstDate = new Date(begin);\r

  \  var secondDate = new Date(end);\r

  \  var diffDays = Math.round(Math.abs((firstDate.getTime() -
  secondDate.getTime()) / (oneDay)));\r

  \  return diffDays;\r

  }"
capitalize: "function capitalize(s) {\r

  \  if (typeof s !== 'string') return '';\r

  \  return s.charAt(0).toUpperCase() + s.slice(1);\r

  }"
choose: function choose(arr, n, excepti) { return rChoose(arr, n, null, excepti); }
chooseRandom: function chooseRandom(arr) { return rChoose(arr); }
clear_timeouts: "function clear_timeouts() {\r

  \  for (const k in TO) clearTimeout(TO[k]);\r

  \  stop_simple_timer();\r

  }"
clearElement: "function clearElement(elem) {\r

  \  if (isString(elem)) elem = document.getElementById(elem);\r

  \  if (window.jQuery == undefined) { elem.innerHTML = ''; return elem; }\r

  \  while (elem.firstChild) {\r

  \    $(elem.firstChild).remove();\r

  \  }\r

  \  return elem;\r

  }"
clearFleetingMessage: "function clearFleetingMessage() {\r

  \  if (isdef(dFleetingMessage)) {\r

  \    dFleetingMessage.remove();\r

  \    dFleetingMessage = null;\r

  \    clearTimeout(TOFleetingMessage);\r

  \  }\r

  }"
coin: function coin(percent = 50) { let r = Math.random(); r *= 100; return r <
  percent; }
colorDark: "function colorDark(c, percent = 50, log = true) {\r

  \  if (nundef(c)) c = rColor(); else c = colorFrom(c);\r

  \  let zero1 = -percent / 100;\r

  \  return pSBC(zero1, c, undefined, !log);\r

  }"
colorFrom: "function colorFrom(cAny, a, allowHsl = false) {\r

  \  if (isString(cAny)) {\r

  \    if (cAny[0] == '#') {\r

  \      if (a == undefined) return cAny;\r

  \      cAny = cAny.substring(0, 7);\r

  \      return cAny + (a == 1 ? '' : alphaToHex(a));\r

  \    } else if (isdef(ColorDi) && lookup(ColorDi, [cAny])) {\r

  \      let c = ColorDi[cAny].c;\r

  \      if (a == undefined) return c;\r

  \      c = c.substring(0, 7);\r

  \      return c + (a == 1 ? '' : alphaToHex(a));\r

  \    } else if (startsWith(cAny, 'rand')) {\r

  \      let spec = capitalize(cAny.substring(4));\r

  \      if (isdef(window['color' + spec])) {\r

  \        c = window['color' + spec]();\r

  \      } else c = rColor();\r

  \      if (a == undefined) return c;\r

  \      return c + (a == 1 ? '' : alphaToHex(a));\r

  \    } else if (startsWith(cAny, 'linear')) {\r

  \      return cAny;\r

  \    } else if (cAny[0] == 'r' && cAny[1] == 'g') {\r

  \      if (a == undefined) return cAny;\r

  \      if (cAny[3] == 'a') {\r

  \        if (a < 1) {\r

  \          return stringBeforeLast(cAny, ',') + ',' + a + ')';\r

  \        } else {\r

  \          let parts = cAny.split(',');\r

  \          let r = firstNumber(parts[0]);\r

  \          return 'rgb(' + r + ',' + parts[1] + ',' + parts[2] + ')';\r

  \        }\r

  \      } else {\r

  \        if (a < 1) {\r

  \          return 'rgba' + cAny.substring(3, cAny.length - 1) + ',' + a +
  ')';\r

  \        } else {\r

  \          return cAny;\r

  \        }\r

  \      }\r

  \    } else if (cAny[0] == 'h' && cAny[1] == 's') {\r

  \      if (allowHsl) {\r

  \        if (a == undefined) return cAny;\r

  \        if (cAny[3] == 'a') {\r

  \          if (a < 1) {\r

  \            return stringBeforeLast(cAny, ',') + ',' + a + ')';\r

  \          } else {\r

  \            let parts = cAny.split(',');\r

  \            let r = firstNumber(parts[0]);\r

  \            return 'hsl(' + r + ',' + parts[1] + ',' + parts[2] + ')';\r

  \          }\r

  \        } else {\r

  \          return a == 1 ? cAny : 'hsla' + cAny.substring(3, cAny.length -
  1) + ',' + a + ')'; \r

  \        }\r

  \      } else {\r

  \        if (cAny[3] == 'a') {\r

  \          cAny = HSLAToRGBA(cAny);\r

  \        } else {\r

  \          cAny = HSLToRGB(cAny);\r

  \        }\r

  \        return colorFrom(cAny, a, false);\r

  \      }\r

  \    } else { \r

  \      ensureColorDict();\r

  \      let c = ColorDi[cAny];\r

  \      if (nundef(c)) {\r

  \        if (startsWith(cAny, 'rand')) {\r

  \          let spec = cAny.substring(4);\r

  \          if (isdef(window['color' + spec])) {\r

  \            c = window['color' + spec](res);\r

  \          } else c = rColor();\r

  \        } else {\r

  \          console.log('color not available:', cAny);\r

  \          throw new Error('color not found: ' + cAny)\r

  \          return '#00000000'; \r

  \        }\r

  \      } else c = c.c;\r

  \      if (a == undefined) return c;\r

  \      c = c.substring(0, 7);\r

  \      return c + (a == 1 ? '' : alphaToHex(a));\r

  \    }\r

  \  } else if (Array.isArray(cAny)) {\r

  \    if (cAny.length == 3 && isNumber(cAny[0])) { \r

  \      let r = cAny[0];\r

  \      let g = cAny[1];\r

  \      let b = cAny[2];\r

  \      return a == undefined || a == 1 ? `rgb(${r},${g},${b})` :
  `rgba(${r},${g},${b},${a})`;\r

  \    } else { \r

  \      return rChoose(cAny);\r

  \    }\r

  \  } else if (typeof cAny == 'object') {\r

  \    if ('h' in cAny) {\r

  \      let hslString = '';\r

  \      if (a == undefined || a == 1) {\r

  \        hslString = `hsl(${cAny.h},${Math.round(cAny.s <= 1.0 ? cAny.s *
  100 : cAny.s)}%,${Math.round(cAny.l <= 1.0 ? cAny.l * 100 : cAny.l)}%)`;\r

  \      } else {\r

  \        hslString = `hsla(${cAny.h},${Math.round(cAny.s <= 1.0 ? cAny.s *
  100 : cAny.s)}%,${Math.round(cAny.l <= 1.0 ? cAny.l * 100 :
  cAny.l)}%,${a})`;\r

  \      }\r

  \      if (allowHsl) {\r

  \        return hslString;\r

  \      } else {\r

  \        return colorFrom(hslString, a, allowHsl);\r

  \      }\r

  \    } else if ('r' in cAny) {\r

  \      if (a !== undefined && a < 1) {\r

  \        return `rgba(${cAny.r},${cAny.g},${cAny.b},${a})`;\r

  \      } else {\r

  \        return `rgb(${cAny.r},${cAny.g},${cAny.b})`;\r

  \      }\r

  \    }\r

  \  }\r

  }"
colorFromHSL: "function colorFromHSL(hue, sat = 100, lum = 50) {\r

  \  return hslToHex(valf(hue, rHue()), sat, lum);\r

  }"
colorHex: "function colorHex(cAny) {\r

  \  let c = colorFrom(cAny);\r

  \  if (c[0] == '#') {\r

  \    return c;\r

  \  } else {\r

  \    let res = pSBC(0, c, 'c');\r

  \    return res;\r

  \  }\r

  }"
colorHSL: "function colorHSL(cAny, asObject = false) {\r

  \  let res = colorFrom(cAny, undefined, true);\r

  \  let shsl = res;\r

  \  if (res[0] == '#') {\r

  \    if (res.length == 9) {\r

  \      shsl = hexAToHSLA(res);\r

  \    } else if (res.length == 7) {\r

  \      shsl = hexToHSL(res);\r

  \    }\r

  \  } else if (res[0] == 'r') {\r

  \    if (res[3] == 'a') {\r

  \      shsl = RGBAToHSLA(res);\r

  \    } else {\r

  \      shsl = RGBToHSL(res);\r

  \    }\r

  \  }\r

  \  let n = allNumbers(shsl);\r

  \  if (asObject) {\r

  \    return { h: n[0], s: n[1] / 100, l: n[2] / 100, a: n.length > 3 ? n[3]
  : 1 };\r

  \  } else {\r

  \    return shsl;\r

  \  }\r

  }"
colorHSLBuild: function colorHSLBuild(hue, sat = 100, lum = 50) { let result =
  "hsl(" + hue + ',' + sat + '%,' + lum + '%)'; return result; }
colorHue: function colorHue(cAny) { let hsl = colorHSL(cAny, true); return hsl.h; }
colorHueWheel: "function colorHueWheel(contrastTo, minDiff = 25, mod = 30, start
  = 0) {\r

  \  let hc = colorHue(contrastTo);\r

  \  let wheel = [];\r

  \  while (start < 360) {\r

  \    let d1 = Math.abs((start + 360) - hc);\r

  \    let d2 = Math.abs((start) - hc);\r

  \    let d3 = Math.abs((start - 360) - hc);\r

  \    let min = Math.min(d1, d2, d3);\r

  \    if (min > minDiff) wheel.push(start);\r

  \    start += mod;\r

  \  }\r

  \  return wheel;\r

  }"
colorIdealText: "function colorIdealText(bg, grayPreferred = false) {\r

  \  let rgb = colorRGB(bg, true);\r

  \  const nThreshold = 105; \r

  \  let r = rgb.r;\r

  \  let g = rgb.g;\r

  \  let b = rgb.b;\r

  \  var bgDelta = r * 0.299 + g * 0.587 + b * 0.114;\r

  \  var foreColor = 255 - bgDelta < nThreshold ? 'black' : 'white';\r

  \  if (grayPreferred) foreColor = 255 - bgDelta < nThreshold ? 'dimgray' :
  'snow';\r

  \  return foreColor;\r

  }"
colorLight: "function colorLight(c, percent = 20, log = true) {\r

  \  if (nundef(c)) {\r

  \    return colorFromHSL(rHue(), 100, 85);\r

  \  } else c = colorFrom(c);\r

  \  let zero1 = percent / 100;\r

  \  return pSBC(zero1, c, undefined, !log);\r

  }"
colorPalette: "function colorPalette(color, type = 'shade') {\r

  \  color = colorFrom(color);\r

  \  return colorShades(color);\r

  }"
colorPaletteFromImage: "function colorPaletteFromImage(img) {\r

  \  if (nundef(ColorThiefObject)) ColorThiefObject = new ColorThief();\r

  \  let palette0 = ColorThiefObject.getPalette(img);\r

  \  let palette = [];\r

  \  for (const pal of palette0) {\r

  \    let color = colorFrom(pal);\r

  \    palette.push(color);\r

  \  }\r

  \  return palette;\r

  }"
colorPaletteFromUrl: "function colorPaletteFromUrl(path) {\r

  \  let img = mCreateFrom(`<img src='${path}' />`);\r

  \  let pal = colorPaletteFromImage(img);\r

  \  return pal;\r

  }"
colorRGB: "function colorRGB(cAny, asObject = false) {\r

  \  let res = colorFrom(cAny);\r

  \  let srgb = res;\r

  \  if (res[0] == '#') {\r

  \    srgb = pSBC(0, res, 'c');\r

  \  }\r

  \  let n = allNumbers(srgb);\r

  \  if (asObject) {\r

  \    return { r: n[0], g: n[1], b: n[2], a: n.length > 3 ? n[3] : 1 };\r

  \  } else {\r

  \    return srgb;\r

  \  }\r

  }"
colorsFromBFA: "function colorsFromBFA(bg, fg, alpha) {\r

  \  if (fg == 'contrast') {\r

  \    if (bg != 'inherit') bg = colorFrom(bg, alpha);\r

  \    fg = colorIdealText(bg);\r

  \  } else if (bg == 'contrast') {\r

  \    fg = colorFrom(fg);\r

  \    bg = colorIdealText(fg);\r

  \  } else {\r

  \    if (isdef(bg) && bg != 'inherit') bg = colorFrom(bg, alpha);\r

  \    if (isdef(fg) && fg != 'inherit') fg = colorFrom(fg);\r

  \  }\r

  \  return [bg, fg];\r

  }"
colorShades: "function colorShades(color) {\r

  \  let res = [];\r

  \  for (let frac = -0.8; frac <= 0.8; frac += 0.2) {\r

  \    let c = pSBC(frac, color, undefined, true); \r

  \    res.push(c);\r

  \  }\r

  \  return res;\r

  }"
colorTrans: "function colorTrans(cAny, alpha = 0.5) {\r

  \  return colorFrom(cAny, alpha);\r

  }"
colorTransPalette: "function colorTransPalette(color = '#000000') {\r

  \  let res = [];\r

  \  for (const alpha of [.0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1])
  res.push(colorTrans(color, alpha));\r

  \  return res;\r

  }"
colorWheel: "function colorWheel(contrastTo, n) {\r

  \  let hc = colorHue(contrastTo);\r

  \  let wheel = [];\r

  \  let start = hc;\r

  \  let inc = Math.round(360 / (n + 1));\r

  \  start += inc;\r

  \  for (let i = 0; i < n; i++) {\r

  \    wheel.push(start % 360);\r

  \    start += inc;\r

  \  }\r

  \  return wheel.map(x => colorHSLBuild(x));\r

  }"
contains: function contains(s, sSub) { return
  s.toLowerCase().includes(sSub.toLowerCase()); }
copyKeys: "function copyKeys(ofrom, oto, except = {}, only) {\r

  \  let keys = isdef(only) ? only : Object.keys(ofrom);\r

  \  for (const k of keys) {\r

  \    if (isdef(except[k])) continue;\r

  \    oto[k] = ofrom[k];\r

  \  }\r

  }"
date2locale: function date2locale(date) { return date.toLocaleDateString(); }
dict2list: "function dict2list(d, keyName = 'id') {\r

  \  let res = [];\r

  \  for (const key in d) {\r

  \    let val = d[key];\r

  \    let o;\r

  \    if (isDict(val)) { o = jsCopy(val); } else { o = { value: val }; }\r

  \    o[keyName] = key;\r

  \    res.push(o);\r

  \  }\r

  \  return res;\r

  }"
divInt: function divInt(a, b) { return Math.trunc(a / b); }
draw_from_deck_to: function draw_from_deck_to(deck, arr) { top_elem_from_to(deck, arr); }
draw_from_deck_to_board: function draw_from_deck_to_board(deck, arr) {
  top_elem_from_to_top(deck, arr); }
drawFlatHex: "function drawFlatHex(dParent, styles, classes, sizing) {\r

  \  if (nundef(styles)) styles = { w: 100, h: 100, bg: 'blue' };\r

  \  if (nundef(classes)) classes = ['frameOnHover'];\r

  \  if (nundef(sizing)) sizing = { hgrow: true, wgrow: true };\r

  \  let d = mDiv(dParent, styles, null, null, classes, sizing);\r

  \  mStyle(d, { 'clip-path': 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25%
  100%, 0% 50%)' });\r

  \  return d;\r

  }"
drawHex: "function drawHex(dParent, styles, classes, sizing) {\r

  \  if (nundef(styles)) styles = { w: 100, h: 100, bg: 'blue' };\r

  \  if (nundef(classes)) classes = ['frameOnHover'];\r

  \  if (nundef(sizing)) sizing = { hgrow: true, wgrow: true };\r

  \  let d = mDiv(dParent, styles, null, null, classes, sizing);\r

  \  mStyle(d, { 'clip-path': 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%,
  0% 75%, 0% 25%)' });\r

  \  return d;\r

  }"
drawPlainCircle: "function drawPlainCircle(c) {\r

  \  let item = mPic('heart', dMain, { fz: 8, bg: 'red', rounding: '50%',
  padding: 1 });\r

  \  mPos(iDiv(item), c.x, c.y);\r

  \  return item;\r

  }"
drawShape: "function drawShape(key, dParent, styles, classes, sizing) {\r

  \  if (nundef(styles)) styles = { w: 96, h: 96, bg: 'random' };\r

  \  if (nundef(sizing)) sizing = { hgrow: true, wgrow: true };\r

  \  let d = mDiv(dParent, styles, null, null, classes, sizing);\r

  \  if (key == 'circle' || key == 'ellipse') mStyle(d, { rounding: '50%'
  });\r

  \  else mStyle(d, { 'clip-path': PolyClips[key] });\r

  \  return d;\r

  }"
drawSym: "function drawSym(sym, c) {\r

  \  let item = mPic(sym, dMain, { fz: 25, bg: 'skyblue', rounding: '50%',
  padding: 4 });\r

  \  mPos(iDiv(item), c.x, c.y);\r

  \  return item;\r

  }"
drawText: "function drawText(text, c) {\r

  \  let item = mText(text, dMain, { fz: 16, bg: 'skyblue', rounding: '50%',
  padding: 4 });\r

  \  mPos(iDiv(item), c.x, c.y);\r

  \  return item;\r

  }"
drawTriangle: "function drawTriangle(dParent, styles, classes, sizing) {\r

  \  if (nundef(styles)) styles = { w: 100, h: 100, bg: 'blue' };\r

  \  if (nundef(classes)) classes = ['frameOnHover'];\r

  \  if (nundef(sizing)) sizing = { hgrow: true, wgrow: true };\r

  \  let d = mDiv(dParent, styles, null, null, classes, sizing);\r

  \  mStyle(d, { 'clip-path': 'polygon(50% 0%, 100% 100%, 0% 100%)' });\r

  \  return d;\r

  }"
elem_from_to: function elem_from_to(el, arr1, arr2) { removeInPlace(arr1, el);
  arr2.push(el); }
elem_from_to_top: function elem_from_to_top(el, arr1, arr2) {
  removeInPlace(arr1, el); arr2.unshift(el); }
endsWith: function endsWith(s, sSub) { let i = s.indexOf(sSub); return i >= 0 &&
  i == s.length - sSub.length; }
ensureColorDict: "function ensureColorDict() {\r

  \  if (isdef(ColorDi)) return;\r

  \  ColorDi = {};\r

  \  let names = getColorNames();\r

  \  let hexes = getColorHexes();\r

  \  for (let i = 0; i < names.length; i++) {\r

  \    ColorDi[names[i].toLowerCase()] = { c: '#' + hexes[i] };\r

  \  }\r

  \  const newcolors = {\r

  \    black: { c: '#000000', D: 'schwarz' },\r

  \    blue: { c: '#0000ff', D: 'blau' },\r

  \    BLUE: { c: '#4363d8', E: 'blue', D: 'blau' },\r

  \    BLUEGREEN: { c: '#004054', E: 'bluegreen', D: 'blaugrn' },\r

  \    BROWN: { c: '#96613d', E: 'brown', D: 'braun' },\r

  \    deepyellow: { c: '#ffed01', E: 'yellow', D: 'gelb' },\r

  \    FIREBRICK: { c: '#800000', E: 'darkred', D: 'rotbraun' },\r

  \    gold: { c: 'gold', D: 'golden' },\r

  \    green: { c: 'green', D: 'grn' },\r

  \    GREEN: { c: '#3cb44b', E: 'green', D: 'grn' },\r

  \    grey: { c: 'grey', D: 'grau' },\r

  \    lightblue: { c: 'lightblue', D: 'hellblau' }, \r

  \    LIGHTBLUE: { c: '#42d4f4', E: 'lightblue', D: 'hellblau' },\r

  \    lightgreen: { c: 'lightgreen', D: 'hellgrn' },\r

  \    LIGHTGREEN: { c: '#afff45', E: 'lightgreen', D: 'hellgrn' },\r

  \    lightyellow: { c: '#fff620', E: 'lightyellow', D: 'gelb' },\r

  \    NEONORANGE: { c: '#ff6700', E: 'neonorange', D: 'neonorange' },\r

  \    NEONYELLOW: { c: '#efff04', E: 'neonyellow', D: 'neongelb' },\r

  \    olive: { c: 'olive', D: 'oliv' },\r

  \    OLIVE: { c: '#808000', E: 'olive', D: 'oliv' },\r

  \    orange: { c: 'orange', D: 'orange' },\r

  \    ORANGE: { c: '#f58231', E: 'orange', D: 'orange' },\r

  \    PINK: { c: 'deeppink', D: 'rosa' },\r

  \    pink: { c: 'pink', D: 'rosa' },\r

  \    purple: { c: 'purple', D: 'lila' },\r

  \    PURPLE: { c: '#911eb4', E: 'purple', D: 'lila' },\r

  \    red: { c: 'red', D: 'rot' },\r

  \    RED: { c: '#e6194B', E: 'red', D: 'rot' },\r

  \    skyblue: { c: 'skyblue', D: 'himmelblau' },\r

  \    SKYBLUE: { c: 'deepskyblue', D: 'himmelblau' },\r

  \    teal: { c: '#469990', D: 'blaugrn' },\r

  \    TEAL: { c: '#469990', E: 'teal', D: 'blaugrn' },\r

  \    transparent: { c: '#00000000', E: 'transparent', D: 'transparent' },\r

  \    violet: { c: 'violet', E: 'violet', D: 'violett' },\r

  \    VIOLET: { c: 'indigo', E: 'violet', D: 'violett' },\r

  \    white: { c: 'white', D: 'weiss' },\r

  \    yellow: { c: 'yellow', D: 'gelb' },\r

  \    yelloworange: { c: '#ffc300', E: 'yellow', D: 'gelb' },\r

  \    YELLOW: { c: '#ffe119', E: 'yellow', D: 'gelb' },\r

  \  };\r

  \  for (const k in newcolors) {\r

  \    let cnew = newcolors[k];\r

  \    if (cnew.c[0] != '#' && isdef(ColorDi[cnew.c])) cnew.c =
  ColorDi[cnew.c].c;\r

  \    ColorDi[k] = cnew;\r

  \  }\r

  }"
errlog: function errlog() { console.log('ERROR!', ...arguments); }
evNoBubble: function evNoBubble(ev) { ev.preventDefault(); ev.cancelBubble = true; }
evToClass: "function evToClass(ev, className) {\r

  \  let elem = findParentWithClass(className);\r

  \  return elem;\r

  }"
evToClosestId: "function evToClosestId(ev) {\r

  \  let elem = findParentWithId(ev.target);\r

  \  return elem.id;\r

  }"
evToId: "function evToId(ev) {\r

  \  let elem = findParentWithId(ev.target);\r

  \  return elem.id;\r

  }"
evToProp: "function evToProp(ev, prop) {\r

  \  let x = ev.target;\r

  \  while (isdef(x) && nundef(x.getAttribute(prop))) x = x.parentNode;\r

  \  return isdef(x) ? x.getAttribute(prop) : null;\r

  }"
evToTargetAttribute: "function evToTargetAttribute(ev, attr) {\r

  \  let val = ev.target.getAttribute(attr);\r

  \  if (nundef(val)) { val = ev.target.parentNode.getAttribute(attr); }\r

  \  return val;\r

  }"
find_minimum: "function find_minimum(array) {\r

  \  let min = array[0];\r

  \  for (let i = 1; i < array.length; i++) {\r

  \    if (array[i] < min) min = array[i];\r

  \  }\r

  \  return min;\r

  }"
find_minimum_by_function: "function find_minimum_by_function(array, func) {\r

  \  let min = func(array[0]);\r

  \  for (let i = 1; i < array.length; i++) {\r

  \    if (func(array[i]) < func(min)) min = array[i];\r

  \  }\r

  \  return min;\r

  }"
findAncestorElemOfType: "function findAncestorElemOfType(el, type) {\r

  \  while (el) {\r

  \    let t = getTypeOf(el);\r

  \    if (t == type) break;\r

  \    el = el.parentNode;\r

  \  }\r

  \  return el;\r

  }"
findAncestorElemWithParentOfType: "function findAncestorElemWithParentOfType(el,
  type) {\r

  \  while (el && el.parentNode) {\r

  \    let t = getTypeOf(el);\r

  \    let tParent = getTypeOf(el.parentNode);\r

  \    if (tParent == type) break;\r

  \    el = el.parentNode;\r

  \  }\r

  \  return el;\r

  }"
findAttributeInAncestors: "function findAttributeInAncestors(elem, attr) {\r

  \  let val;\r

  \  while (elem && nundef(val = elem.getAttribute(attr))) { elem =
  elem.parentNode; }\r

  \  return val;\r

  }"
findChildOfType: "function findChildOfType(type, parentElem) {\r

  \  let children = arrChildren(parentElem);\r

  \  for (const ch of children) {\r

  \    if (getTypeOf(ch) == type) return ch;\r

  \  }\r

  \  return null;\r

  }"
findChildrenOfType: "function findChildrenOfType(type, parentElem) {\r

  \  let children = arrChildren(parentElem);\r

  \  let res = [];\r

  \  for (const ch of children) {\r

  \    if (getTypeOf(ch) == type) res.push(ch);\r

  \  }\r

  \  return res;\r

  }"
findChildWithClass: "function findChildWithClass(className, parentElem) {\r

  \  testHelpers(parentElem);\r

  \  let children = arrChildren(parentElem);\r

  \  for (const ch of children) {\r

  \    if (ch.classList.includes(className)) return ch;\r

  \  }\r

  \  return null;\r

  }"
findChildWithId: "function findChildWithId(id, parentElem) {\r

  \  testHelpers(parentElem);\r

  \  let children = arrChildren(parentElem);\r

  \  for (const ch of children) {\r

  \    if (ch.id == id) return ch;\r

  \  }\r

  \  return null;\r

  }"
findDescendantOfType: "function findDescendantOfType(type, parent) {\r

  \  if (getTypeOf(parent) == type) return parent;\r

  \  let children = arrChildren(parent);\r

  \  if (isEmpty(children)) return null;\r

  \  for (const ch of children) {\r

  \    let res = findDescendantOfType(type, ch);\r

  \    if (res) return res;\r

  \  }\r

  \  return null;\r

  }"
findDescendantWithId: "function findDescendantWithId(id, parent) {\r

  \  if (parent.id == id) return parent;\r

  \  let children = arrChildren(parent);\r

  \  if (isEmpty(children)) return null;\r

  \  for (const ch of children) {\r

  \    let res = findDescendantWithId(id, ch);\r

  \    if (res) return res;\r

  \  }\r

  \  return null;\r

  }"
findKeys: function findKeys(s) { return SymKeys.filter(x => contains(x, s) ||
  contains(Syms[x].E) || contains(Syms[x].D), s); }
findParentWithClass: function findParentWithClass(elem, className) { while (elem
  && !mHasClass(elem, className)) { elem = elem.parentNode; } return elem; }
findParentWithId: function findParentWithId(elem) { while (elem && !(elem.id)) {
  elem = elem.parentNode; } return elem; }
fireClick: "function fireClick(node) {\r

  \  if (document.createEvent) {\r

  \    var evt = document.createEvent('MouseEvents');\r

  \    evt.initEvent('click', true, false);\r

  \    node.dispatchEvent(evt);\r

  \  } else if (document.createEventObject) {\r

  \    node.fireEvent('onclick');\r

  \  } else if (typeof node.onclick == 'function') {\r

  \    node.onclick();\r

  \  }\r

  }"
fireKey: "function fireKey(k, { control, alt, shift } = {}) {\r

  \  console.log('fireKey called!' + document.createEvent)\r

  \  if (document.createEvent) {\r

  \    console.log('fireKey: createEvent and node.dispatchEvent exist!!!', k,
  control, alt, shift);\r

  \    window.dispatchEvent(new KeyboardEvent('keypress', { key: '+', ctrlKey:
  true }));\r

  \  } else if (document.createEventObject) {\r

  \    console.log('fireClick: createEventObject and node.fireEvent exist!!!',
  node)\r

  \    node.fireEvent('onclick');\r

  \  } else if (typeof node.onclick == 'function') {\r

  \    console.log('fireClick: node.onclick exists!!!', node)\r

  \    node.onclick();\r

  \  }\r

  }"
fireWheel: "function fireWheel(node) {\r

  \  if (document.createEvent) {\r

  \    var evt = document.createEvent('MouseEvents');\r

  \    evt.initEvent('wheel', true, false);\r

  \    console.log('fireClick: createEvent and node.dispatchEvent exist!!!',
  node)\r

  \    node.dispatchEvent(evt);\r

  \  } else if (document.createEventObject) {\r

  \    console.log('fireClick: createEventObject and node.fireEvent exist!!!',
  node)\r

  \    node.fireEvent('onclick');\r

  \  } else if (typeof node.onclick == 'function') {\r

  \    console.log('fireClick: node.onclick exists!!!', node)\r

  \    node.onclick();\r

  \  }\r

  }"
firstCond: "function firstCond(arr, func) {\r

  \  if (nundef(arr)) return null;\r

  \  for (const a of arr) {\r

  \    if (func(a)) return a;\r

  \  }\r

  \  return null;\r

  }"
firstCondDict: "function firstCondDict(dict, func) {\r

  \  for (const k in dict) { if (func(dict[k])) return k; }\r

  \  return null;\r

  }"
firstCondDictKey: function firstCondDictKey() { return firstCondDictKeys(...arguments); }
firstCondDictKeys: "function firstCondDictKeys(dict, func) {\r

  \  for (const k in dict) { if (func(k)) return k; }\r

  \  return null;\r

  }"
firstNCond: "function firstNCond(n, arr, func) {\r

  \  if (nundef(arr)) return [];\r

  \  let result = [];\r

  \  let cnt = 0;\r

  \  for (const a of arr) {\r

  \    cnt += 1; if (cnt > n) break;\r

  \    if (func(a)) result.push(a);\r

  \  }\r

  \  return result;\r

  }"
firstNumber: "function firstNumber(s) {\r

  \  if (s) {\r

  \    let m = s.match(/-?\\d+/);\r

  \    if (m) {\r

  \      let sh = m.shift();\r

  \      if (sh) { return Number(sh); }\r

  \    }\r

  \  }\r

  \  return null;\r

  }"
fisherYates: "function fisherYates(arr) {\r

  \  if (arr.length == 2 && coin()) { return arr; } \r

  \  var rnd, temp;\r

  \  let last = arr[0];\r

  \  for (var i = arr.length - 1; i; i--) {\r

  \    rnd = Math.random() * i | 0;\r

  \    temp = arr[i];\r

  \    arr[i] = arr[rnd];\r

  \    arr[rnd] = temp;\r

  \  }\r

  \  return arr;\r

  }"
fleetingMessage: "function fleetingMessage(msg, d, styles, ms, fade) {\r

  \  if (isString(msg)) {\r

  \    dFleetingMessage.innerHTML = msg;\r

  \    mStyle(dFleetingMessage, styles);\r

  \  } else {\r

  \    mAppend(dFleetingMessage, msg);\r

  \  }\r

  \  if (fade) Animation1 = mAnimate(dFleetingMessage, 'opacity', [1, .4, 0],
  null, ms, 'ease-in', 0, 'both');\r

  \  return dFleetingMessage;\r

  }"
forAll: function forAll(arr, func) { for (const a of arr) if (!func(a)) return
  false; return true; }
format_currency: "function format_currency(num) {\r

  \  return '$' + num.toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\r

  }"
format_date: "function format_date(date) {\r

  \  let d = new Date(date);\r

  \  let month = '' + (d.getMonth() + 1);\r

  \  let day = '' + d.getDate();\r

  \  let year = d.getFullYear();\r

  \  if (month.length < 2) month = '0' + month;\r

  \  if (day.length < 2) day = '0' + day;\r

  \  return [month, day, year].join('/');\r

  }"
gBg: function gBg(g, color) { g.setAttribute('fill', color); }
gCanvas: "function gCanvas(area, w, h, color, originInCenter = true) {\r

  \  let dParent = mBy(area);\r

  \  let div = stage3_prepContainer(dParent);\r

  \  div.style.width = w + 'px';\r

  \  div.style.height = h + 'px';\r

  \  let svg = gSvg();\r

  \  let style =
  `margin:0;padding:0;position:absolute;top:0px;left:0px;width:100%;height:100%\
  ;`\r

  \  svg.setAttribute('style', style);\r

  \  mColor(svg, color);\r

  \  div.appendChild(svg);\r

  \  let g = gG();\r

  \  if (originInCenter) g.style.transform = \"translate(50%, 50%)\";\r

  \  svg.appendChild(g);\r

  \  return g;\r

  }"
gCreate: function gCreate(tag) { return
  document.createElementNS('http://www.w3.org/2000/svg', tag); }
gEllipse: function gEllipse(w, h) { let r = gCreate('ellipse');
  r.setAttribute('rx', w / 2); r.setAttribute('ry', h / 2); return r; }
genCats: "function genCats(n) {\r

  \  let di = {};\r

  \  let cats = Object.keys(Categories);\r

  \  for (let i = 0; i < n; i++) {\r

  \    let cat = chooseRandom(cats);\r

  \    let incompat = DA.incompatibleCats[cat];\r

  \    cats = arrMinus(cats, incompat);\r

  \    removeInPlace(cats, cat);\r

  \    di[cat] = Categories[cat];\r

  \  }\r

  \  return di;\r

  }"
get_keys: function get_keys(o) { return Object.keys(o); }
get_mouse_pos: "function get_mouse_pos(ev) {\r

  \  let x = ev.pageX - document.body.scrollLeft; \r

  \  let y = ev.pageY - document.body.scrollTop; \r

  \  return ({ x: x, y: y });\r

  }"
get_values: function get_values(o) { return Object.values(o); }
get_weekday: "function get_weekday(date) {\r

  \  let d = new Date(date);\r

  \  return d.getDay();\r

  }"
getAnimals: "function getAnimals() {\r

  \  let gr = 'Animals & Nature';\r

  \  let result = [];\r

  \  for (const sg in ByGroupSubgroup[gr]) {\r

  \    if (startsWith(sg, 'anim')) result =
  result.concat(ByGroupSubgroup[gr][sg]);\r

  \  }\r

  \  return result;\r

  }"
getColorHexes: "function getColorHexes(x) {\r

  \  return [\r

  \    'f0f8ff',\r

  \    'faebd7',\r

  \    '00ffff',\r

  \    '7fffd4',\r

  \    'f0ffff',\r

  \    'f5f5dc',\r

  \    'ffe4c4',\r

  \    '000000',\r

  \    'ffebcd',\r

  \    '0000ff',\r

  \    '8a2be2',\r

  \    'a52a2a',\r

  \    'deb887',\r

  \    '5f9ea0',\r

  \    '7fff00',\r

  \    'd2691e',\r

  \    'ff7f50',\r

  \    '6495ed',\r

  \    'fff8dc',\r

  \    'dc143c',\r

  \    '00ffff',\r

  \    '00008b',\r

  \    '008b8b',\r

  \    'b8860b',\r

  \    'a9a9a9',\r

  \    'a9a9a9',\r

  \    '006400',\r

  \    'bdb76b',\r

  \    '8b008b',\r

  \    '556b2f',\r

  \    'ff8c00',\r

  \    '9932cc',\r

  \    '8b0000',\r

  \    'e9967a',\r

  \    '8fbc8f',\r

  \    '483d8b',\r

  \    '2f4f4f',\r

  \    '2f4f4f',\r

  \    '00ced1',\r

  \    '9400d3',\r

  \    'ff1493',\r

  \    '00bfff',\r

  \    '696969',\r

  \    '696969',\r

  \    '1e90ff',\r

  \    'b22222',\r

  \    'fffaf0',\r

  \    '228b22',\r

  \    'ff00ff',\r

  \    'dcdcdc',\r

  \    'f8f8ff',\r

  \    'ffd700',\r

  \    'daa520',\r

  \    '808080',\r

  \    '808080',\r

  \    '008000',\r

  \    'adff2f',\r

  \    'f0fff0',\r

  \    'ff69b4',\r

  \    'cd5c5c',\r

  \    '4b0082',\r

  \    'fffff0',\r

  \    'f0e68c',\r

  \    'e6e6fa',\r

  \    'fff0f5',\r

  \    '7cfc00',\r

  \    'fffacd',\r

  \    'add8e6',\r

  \    'f08080',\r

  \    'e0ffff',\r

  \    'fafad2',\r

  \    'd3d3d3',\r

  \    'd3d3d3',\r

  \    '90ee90',\r

  \    'ffb6c1',\r

  \    'ffa07a',\r

  \    '20b2aa',\r

  \    '87cefa',\r

  \    '778899',\r

  \    '778899',\r

  \    'b0c4de',\r

  \    'ffffe0',\r

  \    '00ff00',\r

  \    '32cd32',\r

  \    'faf0e6',\r

  \    'ff00ff',\r

  \    '800000',\r

  \    '66cdaa',\r

  \    '0000cd',\r

  \    'ba55d3',\r

  \    '9370db',\r

  \    '3cb371',\r

  \    '7b68ee',\r

  \    '00fa9a',\r

  \    '48d1cc',\r

  \    'c71585',\r

  \    '191970',\r

  \    'f5fffa',\r

  \    'ffe4e1',\r

  \    'ffe4b5',\r

  \    'ffdead',\r

  \    '000080',\r

  \    'fdf5e6',\r

  \    '808000',\r

  \    '6b8e23',\r

  \    'ffa500',\r

  \    'ff4500',\r

  \    'da70d6',\r

  \    'eee8aa',\r

  \    '98fb98',\r

  \    'afeeee',\r

  \    'db7093',\r

  \    'ffefd5',\r

  \    'ffdab9',\r

  \    'cd853f',\r

  \    'ffc0cb',\r

  \    'dda0dd',\r

  \    'b0e0e6',\r

  \    '800080',\r

  \    '663399',\r

  \    'ff0000',\r

  \    'bc8f8f',\r

  \    '4169e1',\r

  \    '8b4513',\r

  \    'fa8072',\r

  \    'f4a460',\r

  \    '2e8b57',\r

  \    'fff5ee',\r

  \    'a0522d',\r

  \    'c0c0c0',\r

  \    '87ceeb',\r

  \    '6a5acd',\r

  \    '708090',\r

  \    '708090',\r

  \    'fffafa',\r

  \    '00ff7f',\r

  \    '4682b4',\r

  \    'd2b48c',\r

  \    '008080',\r

  \    'd8bfd8',\r

  \    'ff6347',\r

  \    '40e0d0',\r

  \    'ee82ee',\r

  \    'f5deb3',\r

  \    'ffffff',\r

  \    'f5f5f5',\r

  \    'ffff00',\r

  \    '9acd32'\r

  \  ];\r

  }"
getColorNames: "function getColorNames() {\r

  \  return [\r

  \    'AliceBlue',\r

  \    'AntiqueWhite',\r

  \    'Aqua',\r

  \    'Aquamarine',\r

  \    'Azure',\r

  \    'Beige',\r

  \    'Bisque',\r

  \    'Black',\r

  \    'BlanchedAlmond',\r

  \    'Blue',\r

  \    'BlueViolet',\r

  \    'Brown',\r

  \    'BurlyWood',\r

  \    'CadetBlue',\r

  \    'Chartreuse',\r

  \    'Chocolate',\r

  \    'Coral',\r

  \    'CornflowerBlue',\r

  \    'Cornsilk',\r

  \    'Crimson',\r

  \    'Cyan',\r

  \    'DarkBlue',\r

  \    'DarkCyan',\r

  \    'DarkGoldenRod',\r

  \    'DarkGray',\r

  \    'DarkGrey',\r

  \    'DarkGreen',\r

  \    'DarkKhaki',\r

  \    'DarkMagenta',\r

  \    'DarkOliveGreen',\r

  \    'DarkOrange',\r

  \    'DarkOrchid',\r

  \    'DarkRed',\r

  \    'DarkSalmon',\r

  \    'DarkSeaGreen',\r

  \    'DarkSlateBlue',\r

  \    'DarkSlateGray',\r

  \    'DarkSlateGrey',\r

  \    'DarkTurquoise',\r

  \    'DarkViolet',\r

  \    'DeepPink',\r

  \    'DeepSkyBlue',\r

  \    'DimGray',\r

  \    'DimGrey',\r

  \    'DodgerBlue',\r

  \    'FireBrick',\r

  \    'FloralWhite',\r

  \    'ForestGreen',\r

  \    'Fuchsia',\r

  \    'Gainsboro',\r

  \    'GhostWhite',\r

  \    'Gold',\r

  \    'GoldenRod',\r

  \    'Gray',\r

  \    'Grey',\r

  \    'Green',\r

  \    'GreenYellow',\r

  \    'HoneyDew',\r

  \    'HotPink',\r

  \    'IndianRed',\r

  \    'Indigo',\r

  \    'Ivory',\r

  \    'Khaki',\r

  \    'Lavender',\r

  \    'LavenderBlush',\r

  \    'LawnGreen',\r

  \    'LemonChiffon',\r

  \    'LightBlue',\r

  \    'LightCoral',\r

  \    'LightCyan',\r

  \    'LightGoldenRodYellow',\r

  \    'LightGray',\r

  \    'LightGrey',\r

  \    'LightGreen',\r

  \    'LightPink',\r

  \    'LightSalmon',\r

  \    'LightSeaGreen',\r

  \    'LightSkyBlue',\r

  \    'LightSlateGray',\r

  \    'LightSlateGrey',\r

  \    'LightSteelBlue',\r

  \    'LightYellow',\r

  \    'Lime',\r

  \    'LimeGreen',\r

  \    'Linen',\r

  \    'Magenta',\r

  \    'Maroon',\r

  \    'MediumAquaMarine',\r

  \    'MediumBlue',\r

  \    'MediumOrchid',\r

  \    'MediumPurple',\r

  \    'MediumSeaGreen',\r

  \    'MediumSlateBlue',\r

  \    'MediumSpringGreen',\r

  \    'MediumTurquoise',\r

  \    'MediumVioletRed',\r

  \    'MidnightBlue',\r

  \    'MintCream',\r

  \    'MistyRose',\r

  \    'Moccasin',\r

  \    'NavajoWhite',\r

  \    'Navy',\r

  \    'OldLace',\r

  \    'Olive',\r

  \    'OliveDrab',\r

  \    'Orange',\r

  \    'OrangeRed',\r

  \    'Orchid',\r

  \    'PaleGoldenRod',\r

  \    'PaleGreen',\r

  \    'PaleTurquoise',\r

  \    'PaleVioletRed',\r

  \    'PapayaWhip',\r

  \    'PeachPuff',\r

  \    'Peru',\r

  \    'Pink',\r

  \    'Plum',\r

  \    'PowderBlue',\r

  \    'Purple',\r

  \    'RebeccaPurple',\r

  \    'Red',\r

  \    'RosyBrown',\r

  \    'RoyalBlue',\r

  \    'SaddleBrown',\r

  \    'Salmon',\r

  \    'SandyBrown',\r

  \    'SeaGreen',\r

  \    'SeaShell',\r

  \    'Sienna',\r

  \    'Silver',\r

  \    'SkyBlue',\r

  \    'SlateBlue',\r

  \    'SlateGray',\r

  \    'SlateGrey',\r

  \    'Snow',\r

  \    'SpringGreen',\r

  \    'SteelBlue',\r

  \    'Tan',\r

  \    'Teal',\r

  \    'Thistle',\r

  \    'Tomato',\r

  \    'Turquoise',\r

  \    'Violet',\r

  \    'Wheat',\r

  \    'White',\r

  \    'WhiteSmoke',\r

  \    'Yellow',\r

  \    'YellowGreen'\r

  \  ];\r

  }"
getFunctionCallerName: "function getFunctionCallerName() {\r

  \  return new Error().stack.match(/at (\\S+)/g)[1].slice(3);\r

  }"
getFunctionsNameThatCalledThisFunction: "function
  getFunctionsNameThatCalledThisFunction() {\r

  \  let c1 = getFunctionsNameThatCalledThisFunction.caller;\r

  \  if (nundef(c1)) return 'no caller!';\r

  \  let c2 = c1.caller;\r

  \  if (nundef(c2)) return 'no caller!';\r

  \  return c2.name;\r

  }"
getGSGElements: "function getGSGElements(gCond, sCond) {\r

  \  let keys = [];\r

  \  let byg = ByGroupSubgroup;\r

  \  for (const gKey in byg) {\r

  \    if (!gCond(gKey)) continue;\r

  \    for (const sKey in byg[gKey]) {\r

  \      if (!sCond(sKey)) continue;\r

  \      keys = keys.concat(byg[gKey][sKey]);\r

  \    }\r

  \  }\r

  \  return keys.sort();\r

  }"
getKeySets: "function getKeySets() {\r

  \  makeCategories();  \r

  \  let res = {};\r

  \  for (const k in Syms) {\r

  \    let info = Syms[k];\r

  \    if (nundef(info.cats)) continue;\r

  \    for (const ksk of info.cats) {\r

  \      lookupAddIfToList(res, [ksk], k);\r

  \    }\r

  \  }\r

  \  res.animals = getAnimals();\r

  \  res.nature = getNature();\r

  \  localStorage.setItem('KeySets', JSON.stringify(res));\r

  \  return res;\r

  }"
getNature: "function getNature() {\r

  \  let gr = 'Animals & Nature';\r

  \  let result = [];\r

  \  for (const sg in ByGroupSubgroup[gr]) {\r

  \    result = result.concat(ByGroupSubgroup[gr][sg]);\r

  \  }\r

  \  return result;\r

  }"
getRect: "function getRect(elem, relto) {\r

  \  if (isString(elem)) elem = document.getElementById(elem);\r

  \  let res = elem.getBoundingClientRect();\r

  \  if (isdef(relto)) {\r

  \    let b2 = relto.getBoundingClientRect();\r

  \    let b1 = res;\r

  \    res = {\r

  \      x: b1.x - b2.x,\r

  \      y: b1.y - b2.y,\r

  \      left: b1.left - b2.left,\r

  \      top: b1.top - b2.top,\r

  \      right: b1.right - b2.right,\r

  \      bottom: b1.bottom - b2.bottom,\r

  \      width: b1.width,\r

  \      height: b1.height\r

  \    };\r

  \  }\r

  \  let r = { x: res.left, y: res.top, w: res.width, h: res.height };\r

  \  addKeys({ l: r.x, t: r.y, r: r.x + r.w, b: r.t + r.h }, r);\r

  \  return r;\r

  }"
getSizeNeeded: "function getSizeNeeded(elem) {\r

  \  var d = elem.cloneNode(true); \r

  \  d.style.width = 'auto';\r

  \  document.body.appendChild(d);\r

  \  let cStyles = {};\r

  \  cStyles.position = 'fixed';\r

  \  cStyles.opacity = 0;\r

  \  cStyles.top = '-9999px';\r

  \  mStyle(d, cStyles);\r

  \  height = d.clientHeight;\r

  \  width = d.clientWidth;\r

  \  d.parentNode.removeChild(d);\r

  \  return { w: Math.round(width), h: Math.round(height) };\r

  }"
getStyleProp: function getStyleProp(elem, prop) { return
  getComputedStyle(elem).getPropertyValue(prop); }
getTextSize: "function getTextSize(s = 'hallo', parentDivOrId) {\r

  \  var newDiv = document.createElement(\"div\");\r

  \  newDiv.innerHTML = s;\r

  \  newDiv.style.cssText = \"position:fixed; top:-9999px; opacity:0;\"\r

  \  if (isdef(parentDivOrId)) {\r

  \    if (isString(parentDivOrId)) parentDivOrId =
  document.getElementById(parentDivOrId);\r

  \    parentDivOrId.appendChild(newDiv);\r

  \  } else {\r

  \    document.body.appendChild(newDiv);\r

  \  }\r

  \  height = newDiv.clientHeight;\r

  \  width = newDiv.clientWidth;\r

  \  newDiv.parentNode.removeChild(newDiv)\r

  \  return { w: width, h: height };\r

  }"
getTextSizeX: "function getTextSizeX(text, fz, family, weight = 900,
  parentDivOrId = null, styles = {}) {\r

  \  var d = document.createElement(\"div\");\r

  \  styles.fz = fz;\r

  \  styles.family = family;\r

  \  styles['font-weight'] = weight;\r

  \  styles.position = 'fixed';\r

  \  styles.opacity = 0;\r

  \  styles.top = '-9999px';\r

  \  styles.w = 200;\r

  \  mStyleX(d, styles);\r

  \  d.innerHTML = text;\r

  \  if (isdef(parentDivOrId)) {\r

  \    if (isString(parentDivOrId)) parentDivOrId =
  document.getElementById(parentDivOrId);\r

  \    parentDivOrId.appendChild(d);\r

  \  } else {\r

  \    document.body.appendChild(d);\r

  \  }\r

  \  height = d.clientHeight;\r

  \  width = d.clientWidth;\r

  \  d.parentNode.removeChild(d)\r

  \  return { w: width, h: height };\r

  }"
getTextSizeX1: "function getTextSizeX1(text, fz, family, weight = 900,
  parentDivOrId = null, styles = {}) {\r

  \  var d = document.createElement(\"div\");\r

  \  styles.fz = fz;\r

  \  styles.family = family;\r

  \  styles['font-weight'] = weight;\r

  \  styles.position = 'fixed';\r

  \  styles.opacity = 0;\r

  \  styles.top = '-9999px';\r

  \  mStyleX(d, styles);\r

  \  d.innerHTML = text;\r

  \  if (isdef(parentDivOrId)) {\r

  \    if (isString(parentDivOrId)) parentDivOrId =
  document.getElementById(parentDivOrId);\r

  \    parentDivOrId.appendChild(d);\r

  \  } else {\r

  \    document.body.appendChild(d);\r

  \  }\r

  \  height = d.clientHeight;\r

  \  width = d.clientWidth;\r

  \  return { w: width, h: height, d: d };\r

  }"
getTextWidth: "function getTextWidth(text, font) {\r

  \  var canvas = getTextWidth.canvas || (getTextWidth.canvas =
  document.createElement('canvas'));\r

  \  var context = canvas.getContext('2d');\r

  \  context.font = font;\r

  \  var metrics = context.measureText(text);\r

  \  return metrics.width;\r

  }"
getTypeOf: "function getTypeOf(param) {\r

  \  let type = typeof param;\r

  \  if (type == 'string') {\r

  \    return 'string';\r

  \  }\r

  \  if (type == 'object') {\r

  \    type = param.constructor.name;\r

  \    if (startsWith(type, 'SVG')) type = stringBefore(stringAfter(type,
  'SVG'), 'Element').toLowerCase();\r

  \    else if (startsWith(type, 'HTML')) type =
  stringBefore(stringAfter(type, 'HTML'), 'Element').toLowerCase();\r

  \  }\r

  \  let lType = type.toLowerCase();\r

  \  if (lType.includes('event')) type = 'event';\r

  \  return type;\r

  }"
getUID: "function getUID(pref = '') {\r

  \  UIDCounter += 1;\r

  \  return pref + '_' + UIDCounter;\r

  }"
gFg: function gFg(g, color, thickness) { g.setAttribute('stroke', color); if
  (thickness) g.setAttribute('stroke-width', thickness); }
gG: function gG() { return gCreate('g'); }//
  document.createElementNS('http://www.w3.org/2000/svg', 'g'); }
gHex: function gHex(w, h) { let pts = size2hex(w, h); return gPoly(pts); }
gLine: function gLine(x1, y1, x2, y2) { let r = gCreate('line');
  r.setAttribute('x1', x1); r.setAttribute('y1', y1); r.setAttribute('x2', x2);
  r.setAttribute('y2', y2); return r; }
gPoly: function gPoly(pts) { let r = gCreate('polygon'); if (pts)
  r.setAttribute('points', pts); return r; }
gPos: function gPos(g, x, y) { g.style.transform = `translate(${x}px, ${y}px)`; }
gRect: function gRect(w, h) { let r = gCreate('rect'); r.setAttribute('width',
  w); r.setAttribute('height', h); r.setAttribute('x', -w / 2);
  r.setAttribute('y', -h / 2); return r; }
gRounding: "function gRounding(r, rounding) {\r

  \  r.setAttribute('rx', rounding); \r

  \  r.setAttribute('ry', rounding);\r

  }"
gShape: "function gShape(shape, w = 20, h = 20, color = 'green', rounding) {\r

  \  let el = gG();\r

  \  if (nundef(shape)) shape = 'rect';\r

  \  if (shape != 'line') agColoredShape(el, shape, w, h, color);\r

  \  else gStroke(el, color, w); \r

  \  if (isdef(rounding) && shape == 'rect') {\r

  \    let r = el.children[0];\r

  \    gRounding(r, rounding);\r

  \  }\r

  \  return el;\r

  }"
gSize: "function gSize(g, w, h, shape = null, iChild = 0) {\r

  \  let el = (getTypeOf(g) != 'g') ? g : g.children[iChild];\r

  \  let t = getTypeOf(el);\r

  \  switch (t) {\r

  \    case 'rect': el.setAttribute('width', w); el.setAttribute('height', h);
  el.setAttribute('x', -w / 2); el.setAttribute('y', -h / 2); break;\r

  \    case 'ellipse': el.setAttribute('rx', w / 2); el.setAttribute('ry', h /
  2); break;\r

  \    default:\r

  \      if (shape) {\r

  \        switch (shape) {\r

  \          case 'hex': let pts = size2hex(w, h); el.setAttribute('points',
  pts); break;\r

  \        }\r

  \      }\r

  \  }\r

  \  return el;\r

  }"
gSizeToContent: "function gSizeToContent(svg) {\r

  \  var bbox = svg.getBBox();\r

  \  svg.setAttribute(\"width\", bbox.x + bbox.width + bbox.x);\r

  \  svg.setAttribute(\"height\", bbox.y + bbox.height + bbox.y);\r

  }"
gStroke: function gStroke(g, color, thickness) { g.setAttribute('stroke',
  color); if (thickness) g.setAttribute('stroke-width', thickness); }
gSvg: function gSvg() { return gCreate('svg'); }
  //document.createElementNS('http://www.w3.org/2000/svg', 'svg'); }
hasWhiteSpace: function hasWhiteSpace(s) { return /\s/g.test(s); }
hexAToHSLA: "function hexAToHSLA(H) {\r

  \  let ex = /^#([\\da-f]{4}){1,2}$/i;\r

  \  if (ex.test(H)) {\r

  \    let r = 0,\r

  \      g = 0,\r

  \      b = 0,\r

  \      a = 1;\r

  \    if (H.length == 5) {\r

  \      r = '0x' + H[1] + H[1];\r

  \      g = '0x' + H[2] + H[2];\r

  \      b = '0x' + H[3] + H[3];\r

  \      a = '0x' + H[4] + H[4];\r

  \    } else if (H.length == 9) {\r

  \      r = '0x' + H[1] + H[2];\r

  \      g = '0x' + H[3] + H[4];\r

  \      b = '0x' + H[5] + H[6];\r

  \      a = '0x' + H[7] + H[8];\r

  \    }\r

  \    r /= 255;\r

  \    g /= 255;\r

  \    b /= 255;\r

  \    let cmin = Math.min(r, g, b),\r

  \      cmax = Math.max(r, g, b),\r

  \      delta = cmax - cmin,\r

  \      h = 0,\r

  \      s = 0,\r

  \      l = 0;\r

  \    if (delta == 0) h = 0;\r

  \    else if (cmax == r) h = ((g - b) / delta) % 6;\r

  \    else if (cmax == g) h = (b - r) / delta + 2;\r

  \    else h = (r - g) / delta + 4;\r

  \    h = Math.round(h * 60);\r

  \    if (h < 0) h += 360;\r

  \    l = (cmax + cmin) / 2;\r

  \    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\r

  \    s = +(s * 100).toFixed(1);\r

  \    l = +(l * 100).toFixed(1);\r

  \    a = (a / 255).toFixed(3);\r

  \    return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';\r

  \  } else {\r

  \    return 'Invalid input color';\r

  \  }\r

  }"
hexToHSL: "function hexToHSL(H) {\r

  \  let ex = /^#([\\da-f]{3}){1,2}$/i;\r

  \  if (ex.test(H)) {\r

  \    let r = 0,\r

  \      g = 0,\r

  \      b = 0;\r

  \    if (H.length == 4) {\r

  \      r = '0x' + H[1] + H[1];\r

  \      g = '0x' + H[2] + H[2];\r

  \      b = '0x' + H[3] + H[3];\r

  \    } else if (H.length == 7) {\r

  \      r = '0x' + H[1] + H[2];\r

  \      g = '0x' + H[3] + H[4];\r

  \      b = '0x' + H[5] + H[6];\r

  \    }\r

  \    r /= 255;\r

  \    g /= 255;\r

  \    b /= 255;\r

  \    let cmin = Math.min(r, g, b),\r

  \      cmax = Math.max(r, g, b),\r

  \      delta = cmax - cmin,\r

  \      h = 0,\r

  \      s = 0,\r

  \      l = 0;\r

  \    if (delta == 0) h = 0;\r

  \    else if (cmax == r) h = ((g - b) / delta) % 6;\r

  \    else if (cmax == g) h = (b - r) / delta + 2;\r

  \    else h = (r - g) / delta + 4;\r

  \    h = Math.round(h * 60);\r

  \    if (h < 0) h += 360;\r

  \    l = (cmax + cmin) / 2;\r

  \    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\r

  \    s = +(s * 100).toFixed(1);\r

  \    l = +(l * 100).toFixed(1);\r

  \    return 'hsl(' + h + ',' + s + '%,' + l + '%)';\r

  \  } else {\r

  \    return 'Invalid input color';\r

  \  }\r

  }"
hide: "function hide(elem) {\r

  \  if (isString(elem)) elem = document.getElementById(elem);\r

  \  if (nundef(elem)) return;\r

  \  if (isSvg(elem)) {\r

  \    elem.setAttribute('style', 'visibility:hidden;display:none');\r

  \  } else {\r

  \    elem.style.display = 'none';\r

  \  }\r

  }"
HSLAToRGBA: "function HSLAToRGBA(hsla, isPct) {\r

  \  let ex =
  /^hsla\\(((((([12]?[1-9]?\\d)|[12]0\\d|(3[0-5]\\d))(\\.\\d+)?)|(\\.\\d+))(deg\
  )?|(0|0?\\.\\d+)turn|(([0-6](\\.\\d+)?)|(\\.\\d+))rad)(((,\\s?(([1-9]?\\d(\\.\
  \\d+)?)|100|(\\.\\d+))%){2},\\s?)|((\\s(([1-9]?\\d(\\.\\d+)?)|100|(\\.\\d+))%\
  ){2}\\s\\/\\s))((0?\\.\\d+)|[01]|(([1-9]?\\d(\\.\\d+)?)|100|(\\.\\d+))%)\\)$/\
  i;\r

  \  if (ex.test(hsla)) {\r

  \    let sep = hsla.indexOf(',') > -1 ? ',' : ' ';\r

  \    hsla = hsla\r

  \      .substr(5)\r

  \      .split(')')[0]\r

  \      .split(sep);\r

  \    if (hsla.indexOf('/') > -1) hsla.splice(3, 1);\r

  \    isPct = isPct === true;\r

  \    let h = hsla[0],\r

  \      s = hsla[1].substr(0, hsla[1].length - 1) / 100,\r

  \      l = hsla[2].substr(0, hsla[2].length - 1) / 100,\r

  \      a = hsla[3];\r

  \    if (h.indexOf('deg') > -1) h = h.substr(0, h.length - 3);\r

  \    else if (h.indexOf('rad') > -1) h = Math.round((h.substr(0, h.length -
  3) / (2 * Math.PI)) * 360);\r

  \    else if (h.indexOf('turn') > -1) h = Math.round(h.substr(0, h.length -
  4) * 360);\r

  \    if (h >= 360) h %= 360;\r

  \    let c = (1 - Math.abs(2 * l - 1)) * s,\r

  \      x = c * (1 - Math.abs(((h / 60) % 2) - 1)),\r

  \      m = l - c / 2,\r

  \      r = 0,\r

  \      g = 0,\r

  \      b = 0;\r

  \    if (0 <= h && h < 60) {\r

  \      r = c;\r

  \      g = x;\r

  \      b = 0;\r

  \    } else if (60 <= h && h < 120) {\r

  \      r = x;\r

  \      g = c;\r

  \      b = 0;\r

  \    } else if (120 <= h && h < 180) {\r

  \      r = 0;\r

  \      g = c;\r

  \      b = x;\r

  \    } else if (180 <= h && h < 240) {\r

  \      r = 0;\r

  \      g = x;\r

  \      b = c;\r

  \    } else if (240 <= h && h < 300) {\r

  \      r = x;\r

  \      g = 0;\r

  \      b = c;\r

  \    } else if (300 <= h && h < 360) {\r

  \      r = c;\r

  \      g = 0;\r

  \      b = x;\r

  \    }\r

  \    r = Math.round((r + m) * 255);\r

  \    g = Math.round((g + m) * 255);\r

  \    b = Math.round((b + m) * 255);\r

  \    let pctFound = a.indexOf('%') > -1;\r

  \    if (isPct) {\r

  \      r = +((r / 255) * 100).toFixed(1);\r

  \      g = +((g / 255) * 100).toFixed(1);\r

  \      b = +((b / 255) * 100).toFixed(1);\r

  \      if (!pctFound) {\r

  \        a *= 100;\r

  \      } else {\r

  \        a = a.substr(0, a.length - 1);\r

  \      }\r

  \    } else if (pctFound) {\r

  \      a = a.substr(0, a.length - 1) / 100;\r

  \    }\r

  \    return 'rgba(' + (isPct ? r + '%,' + g + '%,' + b + '%,' + a + '%' : +r
  + ',' + +g + ',' + +b + ',' + +a) + ')';\r

  \  } else {\r

  \    return 'Invalid input color';\r

  \  }\r

  }"
hslToHex: "function hslToHex(h, s, l) {\r

  \  l /= 100;\r

  \  const a = s * Math.min(l, 1 - l) / 100;\r

  \  const f = n => {\r

  \    const k = (n + h / 30) % 12;\r

  \    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\r

  \    return Math.round(255 * color).toString(16).padStart(2, '0');   \r

  \  };\r

  \  return `#${f(0)}${f(8)}${f(4)}`;\r

  }"
HSLToRGB: "function HSLToRGB(hsl, isPct) {\r

  \  let ex =
  /^hsl\\(((((([12]?[1-9]?\\d)|[12]0\\d|(3[0-5]\\d))(\\.\\d+)?)|(\\.\\d+))(deg)\
  ?|(0|0?\\.\\d+)turn|(([0-6](\\.\\d+)?)|(\\.\\d+))rad)((,\\s?(([1-9]?\\d(\\.\\\
  d+)?)|100|(\\.\\d+))%){2}|(\\s(([1-9]?\\d(\\.\\d+)?)|100|(\\.\\d+))%){2})\\)$\
  /i;\r

  \  if (ex.test(hsl)) {\r

  \    let sep = hsl.indexOf(',') > -1 ? ',' : ' ';\r

  \    hsl = hsl\r

  \      .substr(4)\r

  \      .split(')')[0]\r

  \      .split(sep);\r

  \    isPct = isPct === true;\r

  \    let h = hsl[0],\r

  \      s = hsl[1].substr(0, hsl[1].length - 1) / 100,\r

  \      l = hsl[2].substr(0, hsl[2].length - 1) / 100;\r

  \    if (h.indexOf('deg') > -1) h = h.substr(0, h.length - 3);\r

  \    else if (h.indexOf('rad') > -1) h = Math.round((h.substr(0, h.length -
  3) / (2 * Math.PI)) * 360);\r

  \    else if (h.indexOf('turn') > -1) h = Math.round(h.substr(0, h.length -
  4) * 360);\r

  \    if (h >= 360) h %= 360;\r

  \    let c = (1 - Math.abs(2 * l - 1)) * s,\r

  \      x = c * (1 - Math.abs(((h / 60) % 2) - 1)),\r

  \      m = l - c / 2,\r

  \      r = 0,\r

  \      g = 0,\r

  \      b = 0;\r

  \    if (0 <= h && h < 60) {\r

  \      r = c;\r

  \      g = x;\r

  \      b = 0;\r

  \    } else if (60 <= h && h < 120) {\r

  \      r = x;\r

  \      g = c;\r

  \      b = 0;\r

  \    } else if (120 <= h && h < 180) {\r

  \      r = 0;\r

  \      g = c;\r

  \      b = x;\r

  \    } else if (180 <= h && h < 240) {\r

  \      r = 0;\r

  \      g = x;\r

  \      b = c;\r

  \    } else if (240 <= h && h < 300) {\r

  \      r = x;\r

  \      g = 0;\r

  \      b = c;\r

  \    } else if (300 <= h && h < 360) {\r

  \      r = c;\r

  \      g = 0;\r

  \      b = x;\r

  \    }\r

  \    r = Math.round((r + m) * 255);\r

  \    g = Math.round((g + m) * 255);\r

  \    b = Math.round((b + m) * 255);\r

  \    if (isPct) {\r

  \      r = +((r / 255) * 100).toFixed(1);\r

  \      g = +((g / 255) * 100).toFixed(1);\r

  \      b = +((b / 255) * 100).toFixed(1);\r

  \    }\r

  \    return 'rgb(' + (isPct ? r + '%,' + g + '%,' + b + '%' : +r + ',' + +g
  + ',' + +b) + ')';\r

  \  } else {\r

  \    return 'Invalid input color';\r

  \  }\r

  }"
iAdd: "function iAdd(item, props) {\r

  \  let id, l;\r

  \  if (isString(item)) { id = item; item = Items[id]; }\r

  \  else if (nundef(item.id)) { id = item.id = iRegister(item); }\r

  \  else { id = item.id; if (nundef(Items[id])) Items[id] = item; }\r

  \  if (nundef(item.live)) item.live = {};\r

  \  l = item.live;\r

  \  for (const k in props) {\r

  \    let val = props[k];\r

  \    if (nundef(val)) {\r

  \      continue;\r

  \    }\r

  \    l[k] = val;\r

  \    if (k == 'div') val.id = id;\r

  \    if (isdef(val.id) && val.id != id) {\r

  \      lookupAddIfToList(val, ['memberOf'], id);\r

  \    }\r

  \  }\r

  }"
iDiv: "function iDiv(i) { return isdef(i.live) ? i.live.div : isdef(i.div) ?
  i.div : i; }"
if_stringified_or_dict: "function if_stringified_or_dict(obj) { return
  nundef(obj) ? {} : is_stringified(obj) ? JSON.parse(obj) : obj; }"
if_stringified_or_list: "function if_stringified_or_list(obj) { return
  nundef(obj) ? [] : is_stringified(obj) ? JSON.parse(obj) : obj; }"
if_stringified_or_string: "function if_stringified_or_string(obj) { return
  nundef(obj) ? '' : is_stringified(obj) ? JSON.parse(obj) : obj; }"
iG: "function iG(i) { return isdef(i.live) ? i.live.g : isdef(i.g) ? i.g : i; }"
iMeasure: "function iMeasure(item, sizingOptions) {\r

  \  if (nundef(iDiv(item))) return;\r

  \  setRect(iDiv(item), valf(sizingOptions, { hgrow: true, wgrow: true }));\r

  }"
incInput: "function incInput(inp, n = 1) {\r

  \  let val = Number(inp.innerHTML);\r

  \  val += n;\r

  \  inp.innerHTML = val;\r

  }"
iRegister: "function iRegister(item, id) { let uid = isdef(id) ? id : getUID();
  Items[uid] = item; return uid; }"
isAlphaNum: function isAlphaNum(s) { query = /^[a-zA-Z0-9]+$/; return query.test(s); }
isdef: function isdef(x) { return x !== null && x !== undefined; }
isDict: function isDict(d) { let res = (d !== null) && (typeof (d) == 'object')
  && !isList(d); return res; }
isDictOrList: function isDictOrList(d) { return typeof (d) == 'object'; }
isDigit: function isDigit(s) { return /^[0-9]$/i.test(s); }
isDOM: "function isDOM(x) { let c = lookup(x, ['constructor', 'name']); return c
  ? startsWith(c, 'HTML') || startsWith(c, 'SVG') : false; }"
isEmpty: "function isEmpty(arr) {\r

  \  return arr === undefined || !arr\r

  \    || (isString(arr) && (arr == 'undefined' || arr == ''))\r

  \    || (Array.isArray(arr) && arr.length == 0)\r

  \    || Object.entries(arr).length === 0;\r

  }"
isEmptyOrWhiteSpace: function isEmptyOrWhiteSpace(s) { return isEmpty(s.trim()); }
isLetter: function isLetter(s) { return /^[a-zA-Z]$/i.test(s); }
isList: function isList(arr) { return Array.isArray(arr); }
isListOf: function isListOf(arr, predfunc) { return Array.isArray(arr) &&
  !firstCond(arr, x => !predfunc(x)); }
isLiteral: function isLiteral(x) { return isString(x) || isNumber(x); }
isNumber: function isNumber(x) { return x !== ' ' && x !== true && x !== false
  && isdef(x) && (x == 0 || !isNaN(+x)); }
isOverflown: "function isOverflown(element) {\r

  \  return element.scrollHeight > element.clientHeight || element.scrollWidth
  > element.clientWidth;\r

  }"
isString: function isString(param) { return typeof param == 'string'; }
isSvg: function isSvg(elem) { return startsWith(elem.constructor.name, 'SVG'); }
iSvg: "function iSvg(i) { return isdef(i.live) ? i.live.svg : isdef(i.svg) ?
  i.svg : i; }"
isVisible: "function isVisible(elem) { \r

  \  if (isString(elem)) elem = document.getElementById(elem);\r

  \  let x = elem.style.flex;\r

  \  return (elem.style.display != 'none' || elem.offsetParent !== null) &&
  (nundef(elem.style.flex) || !endsWith(elem.style.flex, '0%'));\r

  }"
isWhiteSpace: function isWhiteSpace(ch) { return /\s/.test(ch) }
isWhiteSpace2: "function isWhiteSpace2(ch) {\r

  \  const alphanum =
  '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';\r

  \  return !alphanum.includes(ch);\r

  }"
isWhiteSpaceString: function isWhiteSpaceString(s) { return isEmptyOrWhiteSpace(s); }
jsClean: "function jsClean(o) {\r

  \  if (nundef(o)) return o;\r

  \  else if (isDOM(o)) return null;\r

  \  else if (isLiteral(o)) return o;\r

  \  else if (isList(o)) {\r

  \    let onew = o.map(x => jsClean(x));\r

  \    return onew.filter(x => x !== null);\r

  \  } else if (isDict(o)) {\r

  \    for (const k in o) o[k] = jsClean(o[k]);\r

  \    let onew = {};\r

  \    for (const k in o) if (o[k] !== null) onew[k] = o[k];\r

  \    return onew;\r

  \  }\r

  }"
jsCopy: function jsCopy(o) { return JSON.parse(JSON.stringify(o)); }
jsCopySafe: function jsCopySafe(o) { return JSON.parse(JSON.stringify(jsClean(o))); }
jsonToYaml: function jsonToYaml(o) { let y = jsyaml.dump(o); return y; }
last_elem_from_to: function last_elem_from_to(arr1, arr2) { arr2.push(arr1.pop()); }
lastCond: "function lastCond(arr, func) {\r

  \  if (nundef(arr)) return null;\r

  \  for (let i = arr.length - 1; i >= 0; i--) { let a = arr[i]; if (func(a))
  return a; }\r

  \  return null;\r

  }"
lastDescendantOfType: "function lastDescendantOfType(type, parent) {\r

  \  if (getTypeOf(parent) == type) return parent;\r

  \  let children = arrChildren(parent);\r

  \  if (isEmpty(children)) return null;\r

  \  for (const ch of children.reverse()) {\r

  \    let res = lastDescendantOfType(type, ch);\r

  \    if (res) return res;\r

  \  }\r

  \  return null;\r

  }"
list2dict: "function list2dict(arr, keyprop = 'id', uniqueKeys = true) {\r

  \  let di = {};\r

  \  for (const a of arr) {\r

  \    if (uniqueKeys) lookupSet(di, [a[keyprop]], a);\r

  \    else lookupAddToList(di, [a[keyprop]], a);\r

  \  }\r

  \  return di;\r

  }"
load_assets_direct: "function load_assets_direct(obj) {\r

  \  Config = jsyaml.load(obj.config);\r

  \  Syms = jsyaml.load(obj.syms);\r

  \  SymKeys = Object.keys(Syms);\r

  \  ByGroupSubgroup = jsyaml.load(obj.symGSG);\r

  \  Info = jsyaml.load(obj.info);\r

  \  KeySets = getKeySets();\r

  \  console.assert(isdef(Config), 'NO Config!!!!!!!!!!!!!!!!!!!!!!!!');\r

  }"
load_assets_fetch: "async function load_assets_fetch(basepath, baseminpath) {\r

  \  let path = basepath + 'assets/';\r

  \  Config = await route_path_yaml_dict(baseminpath + 'config.yaml');\r

  \  DB = await route_path_yaml_dict(basepath + 'DB.yaml');\r

  \  Syms = await route_path_yaml_dict(path + 'allSyms.yaml');\r

  \  SymKeys = Object.keys(Syms);\r

  \  ByGroupSubgroup = await route_path_yaml_dict(path + 'symGSG.yaml');\r

  \  C52 = await route_path_yaml_dict(path + 'c52.yaml');\r

  \  Cinno = await route_path_yaml_dict(path + 'fe/inno.yaml');\r

  \  Info = await route_path_yaml_dict(path + 'lists/info.yaml');\r

  \  create_card_assets_c52();\r

  \  KeySets = getKeySets();\r

  \  console.assert(isdef(Config), 'NO Config!!!!!!!!!!!!!!!!!!!!!!!!');\r

  \  return { users: dict2list(DB.users, 'name'), games:
  dict2list(Config.games, 'name'), tables: [] };\r

  }"
load_syms: "async function load_syms(path) {\r

  \  if (nundef(path)) path = './base/assets/';\r

  \  Syms = await route_path_yaml_dict(path + 'allSyms.yaml');\r

  \  SymKeys = Object.keys(Syms);\r

  \  ByGroupSubgroup = await route_path_yaml_dict(path + 'symGSG.yaml');\r

  \  KeySets = getKeySets();\r

  }"
loader_off: function loader_off() { let d = mBy('loader_holder'); if (isdef(d))
  d.className = 'loader_off'; }
loader_on: function loader_on() { let d = mBy('loader_holder'); if (isdef(d))
  d.className = 'loader_on'; }
log_array: "function log_array(arr) {\r

  \  arr.map(x => console.log(x));\r

  }"
log_object: "function log_object(o = {}, msg = '', props = [], indent = 0) {\r

  \  console.log(indent ? '.'.repeat(indent) : '____', msg, indent ? '' :
  `(caller:${getFunctionsNameThatCalledThisFunction()})`);\r

  \  let keys = get_keys(o); keys.sort();\r

  \  for (const k of keys) {\r

  \    if (isEmpty(props) || props.includes(k)) {\r

  \      if (isDict(o[k])) { log_object(o[k], k, get_keys(o[k]).join(' '),
  indent + 1); console.log(); }\r

  \      else if (isListOf(o[k], isLiteral)) console.log(' '.repeat(indent), k
  + ':', o[k].join(','));\r

  \      else console.log(' '.repeat(indent), k + ':', o[k]);\r

  \    }\r

  \  }\r

  }"
lookup: "function lookup(dict, keys) {\r

  \  let d = dict;\r

  \  let ilast = keys.length - 1;\r

  \  let i = 0;\r

  \  for (const k of keys) {\r

  \    if (k === undefined) break;\r

  \    let e = d[k];\r

  \    if (e === undefined || e === null) return null; \r

  \    d = d[k];\r

  \    if (i == ilast) return d;\r

  \    i += 1;\r

  \  }\r

  \  return d;\r

  }"
lookupAddIfToList: "function lookupAddIfToList(dict, keys, val) {\r

  \  let lst = lookup(dict, keys);\r

  \  if (isList(lst) && lst.includes(val)) return;\r

  \  lookupAddToList(dict, keys, val);\r

  }"
lookupAddToList: "function lookupAddToList(dict, keys, val) {\r

  \  let d = dict;\r

  \  let ilast = keys.length - 1;\r

  \  let i = 0;\r

  \  for (const k of keys) {\r

  \    if (i == ilast) {\r

  \      if (nundef(k)) {\r

  \        console.assert(false, 'lookupAddToList: last key indefined!' +
  keys.join(' '));\r

  \        return null;\r

  \      } else if (isList(d[k])) {\r

  \        d[k].push(val);\r

  \      } else {\r

  \        d[k] = [val];\r

  \      }\r

  \      return d[k];\r

  \    }\r

  \    if (nundef(k)) continue; \r

  \    if (d[k] === undefined) d[k] = {};\r

  \    d = d[k];\r

  \    i += 1;\r

  \  }\r

  \  return d;\r

  }"
lookupSet: "function lookupSet(dict, keys, val) {\r

  \  let d = dict;\r

  \  let ilast = keys.length - 1;\r

  \  let i = 0;\r

  \  for (const k of keys) {\r

  \    if (nundef(k)) continue; \r

  \    if (d[k] === undefined) d[k] = (i == ilast ? val : {});\r

  \    if (nundef(d[k])) d[k] = (i == ilast ? val : {});\r

  \    d = d[k];\r

  \    if (i == ilast) return d;\r

  \    i += 1;\r

  \  }\r

  \  return d;\r

  }"
lookupSetOverride: "function lookupSetOverride(dict, keys, val) {\r

  \  let d = dict;\r

  \  let ilast = keys.length - 1;\r

  \  let i = 0;\r

  \  for (const k of keys) {\r

  \    if (i == ilast) {\r

  \      if (nundef(k)) {\r

  \        return null;\r

  \      } else {\r

  \        d[k] = val;\r

  \      }\r

  \      return d[k];\r

  \    }\r

  \    if (nundef(k)) continue; \r

  \    if (nundef(d[k])) d[k] = {};\r

  \    d = d[k];\r

  \    i += 1;\r

  \  }\r

  \  return d;\r

  }"
makeCategories: "function makeCategories() {\r

  \  let keys = Categories = {\r

  \    animal: getGSGElements(g => g == 'Animals & Nature', s => startsWith(s,
  'animal')),\r

  \    clothing: getGSGElements(g => g == 'Objects', s => s == 'clothing'),\r

  \    emotion: getGSGElements(g => g == 'Smileys & Emotion', s =>
  startsWith(s, 'face') && !['face-costume', 'face-hat'].includes(s)),\r

  \    food: getGSGElements(g => g == 'Food & Drink', s => startsWith(s,
  'food')),\r

  \    'game/toy': (['sparkler', 'firecracker', 'artist palette', 'balloon',
  'confetti ball'].concat(ByGroupSubgroup['Activities']['game'])).sort(),\r

  \    gesture: getGSGElements(g => g == 'People & Body', s => startsWith(s,
  'hand')),\r

  \    job: ByGroupSubgroup['People & Body']['job'],\r

  \    mammal: ByGroupSubgroup['Animals & Nature']['animal-mammal'],\r

  \    music: getGSGElements(g => g == 'Objects', s => startsWith(s,
  'musi')),\r

  \    object: getGSGElements(g => g == 'Objects', s => true),\r

  \    place: getGSGElements(g => g == 'Travel & Places', s => startsWith(s,
  'place')),\r

  \    plant: getGSGElements(g => g == 'Animals & Nature' || g == 'Food &
  Drink', s => startsWith(s, 'plant') || s == 'food-vegetable' || s ==
  'food-fruit'),\r

  \    sport: ByGroupSubgroup['Activities']['sport'],\r

  \    tool: getGSGElements(g => g == 'Objects', s => s == 'tool'),\r

  \    transport: getGSGElements(g => g == 'Travel & Places', s =>
  startsWith(s, 'transport')),\r

  \  };\r

  \  let incompatible = DA.incompatibleCats = {\r

  \    animal: ['mammal'],\r

  \    clothing: ['object'],\r

  \    emotion: ['gesture'],\r

  \    food: ['plant', 'animal'],\r

  \    'game/toy': ['object', 'music'],\r

  \    gesture: ['emotion'],\r

  \    job: ['sport'],\r

  \    mammal: ['animal'],\r

  \    music: ['object', 'game/toy'],\r

  \    object: ['music', 'clothing', 'game/toy', 'tool'],\r

  \    place: [],\r

  \    plant: ['food'],\r

  \    sport: ['job'],\r

  \    tool: ['object'],\r

  \    transport: [],\r

  \  }\r

  }"
makeUnitString: "function makeUnitString(nOrString, unit = 'px', defaultVal =
  '100%') {\r

  \  if (nundef(nOrString)) return defaultVal;\r

  \  if (isNumber(nOrString)) nOrString = '' + nOrString + unit;\r

  \  return nOrString;\r

  }"
mAnimate: "function mAnimate(elem, prop, valist, callback, msDuration = 1000,
  easing = 'cubic-bezier(1,-0.03,.86,.68)', delay = 0, forwards = 'none') {\r

  \  let kflist = [];\r

  \  for (const perc in valist) {\r

  \    let o = {};\r

  \    let val = valist[perc];\r

  \    o[prop] = isString(val) || prop == 'opacity' ? val : '' + val + 'px';\r

  \    kflist.push(o);\r

  \  }\r

  \  let opts = { duration: msDuration, fill: forwards, easing: easing, delay:
  delay };\r

  \  let a = toElem(elem).animate(kflist, opts);\r

  \  if (isdef(callback)) { a.onfinish = callback; }\r

  \  return a;\r

  }"
mAnimateList: "function mAnimateList(elem, ogoal, callback, msDuration = 1000,
  easing = 'cubic-bezier(1,-0.03,.86,.68)', delay = 0) {\r

  \  for (const k in ogoal) {\r

  \    ogoal[k] = isString(ogoal[k]) || k == 'opacity' ? ogoal[k] : '' +
  ogoal[k] + 'px';\r

  \  }\r

  \  let kflist = [ogoal];\r

  \  let opts = { duration: msDuration, fill: 'forwards', easing: easing,
  delay: delay };\r

  \  let a = toElem(elem).animate(kflist, opts);\r

  \  if (isdef(callback)) { a.onfinish = callback; }\r

  \  return a;\r

  }"
mAnimateTo: "function mAnimateTo(elem, prop, val, callback, msDuration = 1000,
  easing = 'cubic-bezier(1,-0.03,.86,.68)', delay = 0) {\r

  \  let o = {};\r

  \  o[prop] = isString(val) || prop == 'opacity' ? val : '' + val + 'px';\r

  \  let kflist = [o];\r

  \  let opts = { duration: msDuration, fill: 'forwards', easing: easing,
  delay: delay };\r

  \  let a = toElem(elem).animate(kflist, opts);\r

  \  if (isdef(callback)) { a.onfinish = callback; }\r

  \  return a;\r

  }"
mAppear: function mAppear(d, ms = 800, callback = null) { return mAnimateTo(d,
  'opacity', 1, callback, ms); }
mAppend: function mAppend(d, child) { toElem(d).appendChild(child); return child; }
mAttrs: function mAttrs(elem, attrs) { for (const k in attrs) {
  elem.setAttribute(k, attrs[k]); } }
mBackground: "function mBackground(bg, fg) { mStyle(document.body, { bg: bg, fg: fg }); }"
mBoxFromMargins: "function mBoxFromMargins(dParent, t, r, b, l, styles, id,
  inner, classes) {\r

  \  let d = mDiv(dParent, { position: 'absolute', top: t, right: r, bottom:
  b, left: l }, id, inner, classes);\r

  \  let pos = dParent.style.position;\r

  \  if (pos != 'absolute') dParent.style.position = 'relative';\r

  \  if (isdef(styles)) mStyle(d, styles);\r

  \  return d;\r

  }"
mButton: "function mButton(caption, handler, dParent, styles, classes, id) {\r

  \  let x = mCreate('button');\r

  \  x.innerHTML = caption;\r

  \  if (isdef(handler)) x.onclick = handler;\r

  \  if (isdef(dParent)) dParent.appendChild(x);\r

  \  if (isdef(styles)) mStyle(x, styles);\r

  \  if (isdef(classes)) mClass(x, classes);\r

  \  if (isdef(id)) x.id = id;\r

  \  return x;\r

  }"
mButtonX: "function mButtonX(dParent, handler, pos = 'tr', sz = 25, color =
  'white') {\r

  \  let d2 = mDiv(dParent, { fg: color, w: sz, h: sz, pointer: 'cursor' },
  null, `<i class=\"fa fa-times\" style=\"font-size:${sz}px;\"></i>`, 'btnX');\r

  \  mPlace(d2, pos, 2);\r

  \  d2.onclick = handler;\r

  \  return d2;\r

  }"
mBy: function mBy(id) { return document.getElementById(id); }
mCard: "function mCard(dParent, styles, classtr = '', id = null) {\r

  \  let classes = toWords(\"card300 wb \" + classtr);\r

  \  return mDiv(dParent, styles, id, null, classes);\r

  }"
mCardButton: "function mCardButton(caption, handler, dParent, styles, classtr =
  '', id = null) {\r

  \  let classes = toWords(\"card300 wb fett no_outline btn\" + classtr);\r

  \  return mButton(caption, handler, dParent, styles, classes, id);\r

  }"
mCardText: "function mCardText(ckey, sz, color) {\r

  \  let j = is_jolly(ckey);\r

  \  if (nundef(color)) color = get_color_of_card(ckey);\r

  \  return is_jolly(ckey) ?\r

  \    `<span
  style=\"font-size:12px;font-family:Algerian;color:${color}\">jolly</span>` :\r

  \    is_color(ckey) ? `<span
  style=\"font-weight:bold;color:${color}\">${ckey}</span>` :\r

  \      is_color(stringAfter(ckey, '_')) ? `<span
  style=\"font-size:16px;font-family:Algerian;color:${color}\">${stringBefore(c\
  key, '_')}</span>` :\r

  \        `${ckey[0]}${mSuit(ckey, sz, color)}`;\r

  }"
mCenterCenterFlex: function mCenterCenterFlex(d) { mCenterFlex(d, true, true, true); }
mCenterFlex: "function mCenterFlex(d, hCenter = true, vCenter = false, wrap =
  true) {\r

  \  let styles = { display: 'flex' };\r

  \  if (hCenter) styles['justify-content'] = 'center';\r

  \  styles['align-content'] = vCenter ? 'center' : 'flex-start';\r

  \  if (wrap) styles['flex-wrap'] = 'wrap';\r

  \  mStyle(d, styles);\r

  }"
mClass: "function mClass(d) {\r

  \  d = toElem(d);\r

  \  if (arguments.length == 2 && isList(arguments[1])) for (let i = 0; i <
  arguments[1].length; i++) d.classList.add(arguments[1][i]);\r

  \  else for (let i = 1; i < arguments.length; i++)
  d.classList.add(arguments[i]);\r

  }"
mClass0: function mClass0(d) { d = toElem(d); d.className = ''; }
mClassRemove: function mClassRemove(d) { d = toElem(d); for (let i = 1; i <
  arguments.length; i++) d.classList.remove(arguments[i]); }
mClassReplace: function mClassReplace(d, weg, her) { mClassRemove(d, weg); mClass(d, her); }
mClear: function mClear(d) { clearElement(d); }
mColFlex: "function mColFlex(dParent, chflex = [1, 5, 1], bgs) { \r

  \  let styles = { opacity: 1, display: 'flex', 'align-items': 'stretch',
  'flex-flow': 'nowrap' };\r

  \  mStyle(dParent, styles);\r

  \  let res = [];\r

  \  for (let i = 0; i < chflex.length; i++) {\r

  \    let bg = isdef(bgs) ? bgs[i] : null;\r

  \    let d1 = mDiv(dParent, { flex: chflex[i], bg: bg });\r

  \    res.push(d1);\r

  \  }\r

  \  return res;\r

  }"
mColorLetters: "function mColorLetters(s, brightness) {\r

  \  return toLetters(s).map(x => `<div
  style='display:inline-block;transform:rotate(${rChoose([10, 5, -10,
  -5])}deg);color:${rColor(brightness)}'>${x == ' ' ? '&nbsp;' :
  x}</div>`).join('');\r

  }"
mColorPickerBehavior: "function mColorPickerBehavior(value, targetImage, elem,
  handler) {\r

  \  let hues = arrTake(colorHueWheel(value), 10);\r

  \  let colorPalette = hues.map(x => colorFrom(colorHSLBuild(x)));\r

  \  let palette = isdef(targetImage) ? colorPaletteFromImage(targetImage) :
  colorPalette;\r

  \  mStyle(elem, { bg: value });\r

  \  let inp = new JSColor(elem, { alpha: 'ff', closeButton: true, value:
  value, palette: palette, });\r

  \  inp.onInput = () => { let c = inp.toHEXAString(); handler(c); }\r

  \  return inp;\r

  }"
mColorPickerControl: "function mColorPickerControl(label, value, targetImage,
  dParent, handler, styles = { hpadding: 25 }) {\r

  \  let d = mDiv(dParent, styles);\r

  \  let hpad = valf(styles.hpadding, 6);\r

  \  let dLabel = mDiv(d, { 'vertical-align': 'top', w: '35%', align: 'right',
  hpadding: hpad, display: 'inline-block' }, null, label);\r

  \  let hues = arrTake(colorHueWheel(value), 10);\r

  \  let colorPalette = hues.map(x => colorFrom(colorHSLBuild(x)));\r

  \  let palette = isdef(targetImage) ? colorPaletteFromImage(targetImage) :
  colorPalette;\r

  \  let elem = mDiv(d, { w: '55%', hpadding: hpad, h: 24, rounding: hpad,
  display: 'inline-block' });\r

  \  let inp = new JSColor(elem, {\r

  \    alpha: 'ff',\r

  \    closeButton: true,\r

  \    value: value,\r

  \    palette: palette,\r

  \  });\r

  \  inp.onInput = () => { let c = inp.toHEXAString(); handler(c); }\r

  \  return inp;\r

  }"
mCreate: function mCreate(tag, styles, id) { let d =
  document.createElement(tag); if (isdef(id)) d.id = id; if (isdef(styles))
  mStyle(d, styles); return d; }
mCreateFrom: "function mCreateFrom(htmlString) {\r

  \  var div = document.createElement('div');\r

  \  div.innerHTML = htmlString.trim();\r

  \  return div.firstChild;\r

  }"
mDataTable: "function mDataTable(reclist, dParent, rowstylefunc, headers, id,
  showheaders = true) {\r

  \  if (nundef(headers)) headers = get_keys(reclist[0]);\r

  \  let t = mTable(dParent, headers, showheaders);\r

  \  if (isdef(id)) t.id = `t${id}`;\r

  \  let rowitems = [];\r

  \  let i = 0;\r

  \  for (const u of reclist) {\r

  \    let rid = isdef(id) ? `r${id}_${i}` : null;\r

  \    r = mTableRow(t, u, headers, rid);\r

  \    if (isdef(rowstylefunc)) mStyle(r.div, rowstylefunc(u));\r

  \    rowitems.push({ div: r.div, colitems: r.colitems, o: u, id: rid, index:
  i });\r

  \    i++;\r

  \  }\r

  \  return { div: t, rowitems: rowitems };\r

  }"
mDiv: "function mDiv(dParent, styles, id, inner, classes, sizing) {\r

  \  let d = mCreate('div');\r

  \  if (dParent) mAppend(dParent, d);\r

  \  if (isdef(styles)) mStyle(d, styles);\r

  \  if (isdef(classes)) mClass(d, classes);\r

  \  if (isdef(id)) d.id = id;\r

  \  if (isdef(inner)) d.innerHTML = inner;\r

  \  if (isdef(sizing)) { setRect(d, sizing); }\r

  \  return d;\r

  }"
mDiv100: function mDiv100(dParent, styles, id, sizing = true) { let d =
  mDiv(dParent, styles, id); mSize(d, 100, 100, '%', sizing); return d; }
mDivItem: "function mDivItem(dParent, styles, id, content) {\r

  \  if (nundef(id)) id = getUID();\r

  \  let d = mDiv(dParent, styles, id, content);\r

  \  return mItem(id, { div: d });\r

  }"
mDivLR: "function mDivLR(dParent, styles, id, innerlist, classes) {\r

  \  let d = mDiv(dParent, styles, id,
  `<div>${innerlist[0]}</div><div>${innerlist[1]}</div>`, classes);\r

  \  mStyle(d, { display: 'flex', 'justify-content': 'space-between',
  'align-items': 'center' });\r

  \  return d;\r

  }"
mDover: "function mDover(dParent, styles = {}, sizing = true) {\r

  \  let d = mDiv(dParent, styles);\r

  \  mIfNotRelative(dParent);\r

  \  mStyle(d, { position: 'absolute', left: 0, top: 0, w: '100%', h: '100%'
  });\r

  \  setRect(d, sizing);\r

  \  return d;\r

  }"
mDraggable: "function mDraggable(item) {\r

  \  let d = iDiv(item);\r

  \  d.draggable = true;\r

  \  d.ondragstart = drag;\r

  }"
mDroppable: "function mDroppable(item, handler, dragoverhandler) {\r

  \  function allowDrop(ev) { ev.preventDefault(); }\r

  \  let d = iDiv(item);\r

  \  d.ondragover = isdef(dragoverhandler) ? dragoverhandler : allowDrop;\r

  \  d.ondrop = handler;\r

  }"
measure_fieldset: "function measure_fieldset(fs) {\r

  \  let legend = fs.firstChild;\r

  \  let r = getRect(legend);\r

  \  let labels = fs.getElementsByTagName('label');\r

  \  let wmax = 0;\r

  \  for (const l of labels) {\r

  \    let r1 = getRect(l);\r

  \    wmax = Math.max(wmax, r1.w);\r

  \  }\r

  \  let wt = r.w;\r

  \  let wo = wmax + 24;\r

  \  let diff = wt - wo;\r

  \  if (diff >= 10) {\r

  \    for (const l of labels) { let d = l.parentNode; mStyle(d, { maleft:
  diff / 2 }); }\r

  \  }\r

  \  let wneeded = Math.max(wt, wo) + 10;\r

  \  mStyle(fs, { wmin: wneeded });\r

  \  for (const l of labels) { let d = l.parentNode; mStyle(l, { display:
  'inline-block', wmin: 50 }); mStyle(d, { wmin: wneeded - 40 }); }\r

  }"
measureTextX: "function measureTextX(text, fz, family, weight = 900) {\r

  \  let sFont = '' + weight + ' ' + fz + 'px ' + family;\r

  \  sFont = sFont.trim();\r

  \  var canvas = getTextWidth.canvas || (getTextWidth.canvas =
  document.createElement('canvas'));\r

  \  var context = canvas.getContext('2d');\r

  \  context.font = sFont;\r

  \  var metrics = context.measureText(text);\r

  \  let actualHeight = metrics.actualBoundingBoxAscent +
  metrics.actualBoundingBoxDescent;\r

  \  console.log(metrics.width, actualHeight, fz)\r

  \  return { w: metrics.width, h: actualHeight, fz: fz };\r

  }"
mEdit: "function mEdit(label, value, dParent, handler, styles, classes, id) {\r

  \  let d = mDiv(dParent, styles);\r

  \  let hpad = valf(styles.hpadding, 4);\r

  \  let dLabel = mDiv(d, { w: '50%', align: 'right', hpadding: hpad, display:
  'inline-block' }, null, label); \r

  \  let inp = mCreateFrom(`<div contenteditable=\"true\"
  spellcheck=\"false\">${value}</div>  `)\r

  \  mAppend(d, inp);\r

  \  mStyle(inp, { display: 'inline-block', w: '50%', align: 'left', hpadding:
  hpad });\r

  \  inp.addEventListener('keydown', unfocusOnEnter);\r

  \  inp.addEventListener('focusout', ev => { handler(inp.innerHTML, ev);
  });\r

  \  inp.onclick = ev => selectText(ev.target);\r

  \  if (isdef(classes)) mClass(inp, classes);\r

  \  if (isdef(id)) inp.id = id;\r

  \  return inp;\r

  }"
mEditableInput: "function mEditableInput(dParent, label, val, styles, classes,
  id) {\r

  \  let labelElem = mCreateFrom(`<span>${label}</span>  `)\r

  \  let elem = mCreateFrom(`<span contenteditable=\"true\"
  spellcheck=\"false\">${val}</span>  `)\r

  \  elem.addEventListener('keydown', (ev) => {\r

  \    if (ev.key === 'Enter') {\r

  \      ev.preventDefault();\r

  \      mBy('dummy').focus();\r

  \    }\r

  \  });\r

  \  let dui = mDiv(dParent, { margin: 2 });\r

  \  mAppend(dui, labelElem);\r

  \  mAppend(dui, elem);\r

  \  if (isdef(styles)) {\r

  \    if (isdef(styles.wInput)) mStyle(elem, { wmin: styles.wInput });\r

  \    mStyle(elem, styles);\r

  \  }\r

  \  if (isdef(classes)) mStyle(elem, classes);\r

  \  if (isdef(id)) elem.id = id;\r

  \  return elem;\r

  }"
mEditableOnEdited: "function mEditableOnEdited(id, dParent, label, initialVal,
  onEdited, onOpening, styles, classes) {\r

  \  let inp = mEditableInput(dParent, label, initialVal, styles, classes);\r

  \  inp.id = id;\r

  \  if (isdef(onOpening)) { inp.addEventListener('focus', ev =>
  onOpening(ev)); }\r

  \  inp.addEventListener('focusout', ev => {\r

  \    window.getSelection().removeAllRanges();\r

  \    if (isdef(onEdited)) onEdited(inp.innerHTML, ev);\r

  \  });\r

  \  return inp;\r

  }"
mEditNumber: "function mEditNumber(label, value, dParent, handler, styles,
  classes, id, triggerOnChange = false) {\r

  \  let d = mDiv(dParent, styles);\r

  \  let hpad = valf(styles.hpadding, 4);\r

  \  let dLabel = mDiv(d, { w: '50%', align: 'right', hpadding: hpad, display:
  'inline-block' }, null, label); \r

  \  if (nundef(handler)) handler = x => console.log(x);\r

  \  let inp = mCreateFrom(`<div contenteditable=\"true\"
  spellcheck=\"false\">${value}</div>  `)\r

  \  mAppend(d, inp);\r

  \  mStyle(inp, { display: 'inline-block', w: '40%', align: 'left', hpadding:
  hpad });\r

  \  inp.addEventListener('keydown', unfocusOnEnter);\r

  \  inp.addEventListener('focusout', ev => { handler(inp.innerHTML, ev);
  });\r

  \  inp.onclick = ev => selectText(ev.target);\r

  \  if (isdef(classes)) mClass(inp, classes);\r

  \  if (isdef(id)) inp.id = id;\r

  \  return inp;\r

  }"
mEditRange: "function mEditRange(label, value, min, max, step, dParent, handler,
  styles, classes, id, triggerOnChange = true) {\r

  \  let d = mDiv(dParent, styles);\r

  \  let hpad = valf(styles.hpadding, 4);\r

  \  let dLabel = mDiv(d, { w: '30%', align: 'right', hpadding: hpad, display:
  'inline-block' }, null, label); \r

  \  let inpText = mCreateFrom(`<input type='number'  step=${step}
  min=\"${min}\" max=\"${max}\" value=\"${value}\" ></input>`);\r

  \  let inp = mCreateFrom(`<input type=\"range\" step=${step} min=\"${min}\"
  max=\"${max}\" value=\"${value}\" ></input>`);\r

  \  mAppend(d, inpText);\r

  \  mAppend(d, inp);\r

  \  mStyle(inpText, { display: 'inline', w: '20%', align: 'left', hpadding:
  hpad });\r

  \  mStyle(inp, { display: 'inline', w: '40%', hpadding: hpad });\r

  \  inpText.onchange = (ev) => { inp.value = inpText.value;
  handler(inpText.value, ev); };\r

  \  inpText.onclick = ev => selectText(ev.target);\r

  \  inp.onchange = (ev) => { inpText.value = inp.value;
  handler(inpText.value, ev); };\r

  \  if (isdef(classes)) mClass(inp, classes);\r

  \  if (isdef(id)) inp.id = id;\r

  \  return inpText;\r

  }"
mEditX: "function mEditX(label, val, dParent, styles, classes, handler, id, opt
  = {}) {\r

  \  let defOptions = {\r

  \    alignLabel: 'right',\r

  \    fgLabel: 'silver',\r

  \    wminLabel: 120,\r

  \    alignInput: 'left',\r

  \    fgInput: 'white',\r

  \    wminInput: 50,\r

  \    wminRight: 120,\r

  \    align: 'center',\r

  \  }\r

  \  addKeys(defOptions, opt);\r

  \  let wminTotal = wminLabel + wminRight;\r

  \  if (nundef(styles)) styles = {};\r

  \  if (nundef(styles.wmin)) styles.wmin = 0;\r

  \  styles.wmin = Math.max(styles.wmin, wminTotal);\r

  \  styles.align = opt.align;\r

  \  let dOuter = mDiv(dParent, styles, id, null, classes);\r

  \  let dLabel = mDiv(dOuter, { fg: opt.fgLabel, wmin: opt.wminLabel, align:
  opt.alignLabel }, null, label);\r

  \  let dInput = mDiv(dOuter, { contenteditable: true, spellcheck: false, fg:
  opt.fgInput, wmin: opt.wminInput, align: opt.alignInput }, null, val);\r

  \  dInput.onfocusout = ev => handler(dInput.innerHTML, ev);\r

  \  dInput.onkeydown = (ev) => {\r

  \    if (ev.key === 'Enter') {\r

  \      ev.preventDefault();\r

  \      mBy('dummy').focus();\r

  \    }\r

  \  }\r

  \  return dInput;\r

  }"
mFade: function mFade(d, ms = 800, callback = null) { return mAnimateTo(d,
  'opacity', 0, callback, ms); }
mFadeClear: function mFadeClear(d, ms = 800, callback = null) { return
  mAnimateTo(d, 'opacity', 0, () => { mClear(d); if (callback) callback(); },
  ms); }
mFadeClearShow: function mFadeClearShow(d, ms = 800, callback = null) { return
  mAnimate(d, 'opacity', [1, 0], () => { mClear(d); if (callback) callback(); },
  ms); }
mFadeRemove: function mFadeRemove(d, ms = 800, callback = null) { return
  mAnimateTo(d, 'opacity', 0, () => { mRemove(d); if (callback) callback(); },
  ms); }
mFall: "function mFall(d, ms = 800, dist = 50) { toElem(d).animate([{ opacity:
  0, transform: `translateY(-${dist}px)` }, { opacity: 1, transform:
  'translateY(0px)' },], { fill: 'both', duration: ms, easing: 'ease' }); }"
mFlex: "function mFlex(d, or = 'h') {\r

  \  d = toElem(d);\r

  \  d.style.display = 'flex';\r

  \  d.style.flexFlow = (or == 'v' ? 'column' : 'row') + ' ' + (or == 'w' ?
  'wrap' : 'nowrap');\r

  }"
mFlexColumn: "function mFlexColumn(d, or = 'h') {\r

  \  d = toElem(d);\r

  \  d.style.display = 'flex';\r

  \  d.style.flexFlow = (or == 'v' ? 'column' : 'row') + ' ' + (or == 'w' ?
  'wrap' : 'nowrap');\r

  \  d.style.alignItems = 'stretch';\r

  \  d.style.alignContent = 'stretch';\r

  \  d.style.justiifyItems = 'stretch';\r

  \  d.style.justifyContent = 'stretch';\r

  }"
mFlexEvenly: "function mFlexEvenly(d) {\r

  \  let styles = { display: 'flex' };\r

  \  styles['justify-content'] = 'space-evenly';\r

  \  mStyle(d, styles);\r

  }"
mFlexLR: "function mFlexLR(d) { mStyle(d, { display: 'flex', 'justify-content':
  'space-between', 'align-items': 'center' }); }"
mFlexSpacebetween: function mFlexSpacebetween(d) { mFlexLR(d); }
mFlexWrap: function mFlexWrap(d) { mFlex(d, 'w'); }
mForm: "function mForm(dParent) {\r

  \  return mAppend(dParent, mCreate('form'));\r

  }"
mFromPoint: "function mFromPoint(x, y) {\r

  \  var element, elements = [];\r

  \  var old_visibility = [];\r

  \  while (true) {\r

  \    element = document.elementFromPoint(x, y);\r

  \    if (!element || element === document.documentElement) {\r

  \      break;\r

  \    }\r

  \    elements.push(element);\r

  \    old_visibility.push(element.style.visibility);\r

  \    element.style.visibility = 'hidden'; \r

  \  }\r

  \  for (var k = 0; k < elements.length; k++) {\r

  \    elements[k].style.visibility = old_visibility[k];\r

  \  }\r

  \  elements.reverse();\r

  \  return elements;\r

  }"
mGetStyle: "function mGetStyle(elem, prop) {\r

  \  let val;\r

  \  elem = toElem(elem);\r

  \  if (prop == 'bg') { val = getStyleProp(elem, 'background-color'); if
  (isEmpty(val)) return getStyleProp(elem, 'background'); }\r

  \  else if (isdef(STYLE_PARAMS[prop])) { val = getStyleProp(elem,
  STYLE_PARAMS[prop]); } \r

  \  else {\r

  \    switch (prop) {\r

  \      case 'vmargin': val = stringBefore(elem.style.margin, ' '); break;\r

  \      case 'hmargin': val = stringAfter(elem.style.margin, ' '); break;\r

  \      case 'vpadding': val = stringBefore(elem.style.padding, ' ');
  break;\r

  \      case 'hpadding': val = stringAfter(elem.style.padding, ' '); break;\r

  \      case 'box': val = elem.style.boxSizing; break;\r

  \      case 'dir': val = elem.style.flexDirection; break;\r

  \    }\r

  \  }\r

  \  if (nundef(val)) val = getStyleProp(elem, prop); \r

  \  if (val.endsWith('px')) return firstNumber(val); else return val;\r

  }"
mGrid: "function mGrid(rows, cols, dParent, styles = {}) {\r

  \  let d = mDiv(dParent, styles);\r

  \  d.style.gridTemplateColumns = 'repeat(' + cols + ',1fr)';\r

  \  d.style.gridTemplateRows = 'repeat(' + rows + ',1fr)';\r

  \  d.style.display = 'inline-grid';\r

  \  d.style.padding = valf(styles.padding, styles.gap) + 'px';\r

  \  return d;\r

  }"
mgSvg: function mgSvg(dParent, attrs) { return mgTag('svg', dParent, attrs); }
mgTag: "function mgTag(tag, dParent, attrs, styles = {}, innerHTML) {\r

  \  let elem = gCreate(tag);\r

  \  mStyle(elem, styles);\r

  \  mAttrs(elem, attrs);\r

  \  if (isdef(innerHTML)) elem.innerHTML = innerHTML;\r

  \  if (isdef(dParent)) mAppend(dParent, elem);\r

  \  return elem;\r

  }"
mgText: function mgText(text, dParent, attrs, styles) { return mgTag('text',
  dParent, attrs, styles, text); }
mHide: "function mHide(d, ms = 0) { if (ms > 0) mFade(d, ms); else mStyle(d, {
  opacity: 0 }); }"
mIfNotRelative: function mIfNotRelative(d) { if (isEmpty(d.style.position))
  d.style.position = 'relative'; }
mImage: function mImage() { return mImg(...arguments); }
mImg: "function mImg(path, dParent, styles, classes, callback) {\r

  \  let d = mCreate('img');\r

  \  if (isdef(callback)) d.onload = callback;\r

  \  d.src = path;\r

  \  mAppend(dParent, d);\r

  \  if (isdef(styles)) mStyle(d, styles);\r

  \  if (isdef(classes)) mClass(d, classes);\r

  \  if (isdef(styles.w)) d.setAttribute('width', styles.w + 'px');\r

  \  if (isdef(styles.h)) d.setAttribute('height', styles.h + 'px');\r

  \  return d;\r

  }"
mInput: "function mInput(dParent, styles, id, placeholder, classtr = 'input',
  tabindex = null, value = '') {\r

  \  let html = `<input type=\"text\" id=${id} class=\"${classtr}\"
  placeholder=\"${valf(placeholder, '')}\" tabindex=\"${tabindex}\"
  value=\"${value}\">`;\r

  \  let d = mAppend(dParent, mCreateFrom(html));\r

  \  if (isdef(styles)) mStyle(d, styles);\r

  \  return d;\r

  }"
mInsert: function mInsert(dParent, el, index = 0) { dParent.insertBefore(el,
  dParent.childNodes[index]); }
mInsertAfter: "function mInsertAfter(dParent, el, index = 0) {\r

  \  if (dParent.childNodes.length == index) mAppend(dParent, el);\r

  \  else mInsert(dParent, el, index + 1);\r

  }"
mInsertAt: function mInsertAt(dParent, el, index = 0) { mInsert(dParent, el, index); }
mInsertFirst: function mInsertFirst(dParent, el) { mInsert(dParent, el, 0); }
miPic: "function miPic(item, dParent, styles, classes) {\r

  \  let info = isString(item) ? Syms[item] : isdef(item.info) ? item.info :
  item;\r

  \  let d = mDiv(dParent);\r

  \  d.innerHTML = info.text;\r

  \  if (nundef(styles)) styles = {};\r

  \  let family = info.family; \r

  \  addKeys({ family: family, fz: 50, display: 'inline-block' }, styles);\r

  \  mStyle(d, styles);\r

  \  if (isdef(classes)) mClass(d, classes);\r

  \  mCenterCenterFlex(d);\r

  \  return d;\r

  }"
mItem: "function mItem(id, diDOM, di = {}, addSizing = false) {\r

  \  let item = di;\r

  \  id = isdef(id) ? id : isdef(diDOM) && isdef(diDOM.div) &&
  !isEmpty(diDOM.div.id) ? diDOM.div.id : getUID();\r

  \  item.id = iRegister(item, id);\r

  \  if (isdef(diDOM) && isdef(diDOM.div)) { diDOM.div.id = id; iAdd(item,
  diDOM); }\r

  \  if (addSizing) {\r

  \    if (nundef(item.sizing)) item.sizing = 'sizeToContent';\r

  \    if (nundef(item.positioning)) { item.positioning = 'absolute'; }\r

  \    if (nundef(item.posType)) { item.posType = 'center'; }\r

  \    if (isdef(diDOM) && item.sizing == 'sizeToContent') iMeasure(item,
  item.sizingOptions);\r

  \  }\r

  \  return item;\r

  }"
mLine: function mLine(dParent, styles) { return mDiv(dParent, styles, null, '<hr>'); }
mLinebreak: "function mLinebreak(dParent, gap) {\r

  \  dParent = toElem(dParent);\r

  \  let d;\r

  \  let display = getComputedStyle(dParent).display;\r

  \  if (display == 'flex') {\r

  \    d = mDiv(dParent, { fz: 2, 'flex-basis': '100%', h: 0, w: '100%' },
  null, ' &nbsp; ');\r

  \  } else {\r

  \    d = mDiv(dParent, {}, null, '<br>');\r

  \  }\r

  \  if (isdef(gap)) { d.style.minHeight = gap + 'px'; d.innerHTML = ' &nbsp;
  '; d.style.opacity = .2; }\r

  \  return d;\r

  }"
mLinebreakFlex: "function mLinebreakFlex(dParent, gap) {\r

  \  dParent = toElem(dParent);\r

  \  let d = mDiv(dParent, { fz: 2, 'flex-basis': '100%', h: 0, w: '100%' },
  null, ' &nbsp; ');\r

  \  if (isdef(gap)) { d.style.minHeight = gap + 'px'; d.innerHTML = ' &nbsp;
  '; d.style.opacity = .2; }\r

  \  return d;\r

  }"
mLink: "function mLink(dParent, styles, id, inner, classes, sizing) {\r

  \  let d = mCreate('a');\r

  \  if (dParent) mAppend(dParent, d);\r

  \  if (isdef(styles)) mStyle(d, styles);\r

  \  if (isdef(classes)) mClass(d, classes);\r

  \  if (isdef(id)) d.id = id;\r

  \  if (isdef(inner)) d.innerHTML = inner;\r

  \  if (isdef(sizing)) { setRect(d, sizing); }\r

  \  return d;\r

  }"
mMagnifyOnHoverControl: "function mMagnifyOnHoverControl(elem) {\r

  \  elem.onmouseenter = ev => { if (ev.ctrlKey) mClass(elem,
  'magnify_on_hover'); }\r

  \  elem.onmouseleave = ev => mClassRemove(elem, 'magnify_on_hover');\r

  }"
mMagnifyOnHoverControlPopup: "function mMagnifyOnHoverControlPopup(elem) {\r

  \  elem.onmouseenter = ev => {\r

  \    if (ev.ctrlKey) {\r

  \      let r = getRect(elem, document.body);\r

  \      let popup = mDiv(document.body, { rounding: 4, position: 'absolute',
  top: r.y, left: r.x }, 'popup');\r

  \      let clone = elem.cloneNode(true);\r

  \      popup.appendChild(clone);\r

  \      mClass(popup, 'doublesize')\r

  \      popup.onmouseleave = () => popup.remove();\r

  \    }\r

  \  }\r

  }"
mMagnifyOnHoverControlRemove: "function mMagnifyOnHoverControlRemove(elem) {\r

  \  elem.onmouseenter = elem.onmouseleave = null;\r

  \  mClassRemove(elem, 'magnify_on_hover');\r

  }"
mMeasure: "function mMeasure(d) { let r = getRect(d); mStyle(d, { w: r.w, h: r.h
  }); return r; }"
mNode: "function mNode(o, dParent, title) {\r

  \  recConvertLists(o);\r

  \  console.log('mNode o', o);\r

  \  let d = mCreate('div');\r

  \  mYaml(d, o);\r

  \  let pre = d.getElementsByTagName('pre')[0];\r

  \  pre.style.fontFamily = 'inherit';\r

  \  if (isdef(title)) mInsert(d, mText(title));\r

  \  if (isdef(dParent)) mAppend(dParent, d);\r

  \  if (isDict(o)) d.style.textAlign = 'left';\r

  \  return d;\r

  }"
mPlace: "function mPlace(elem, pos, offx, offy) {\r

  \  elem = toElem(elem);\r

  \  pos = pos.toLowerCase();\r

  \  let dParent = elem.parentNode; if (dParent.style.position != 'absolute')
  dParent.style.position = 'relative';\r

  \  let vert = valf(offx, 0); \r

  \  let hor = isdef(offy) ? offy : vert;\r

  \  if (pos[0] == 'c' || pos[1] == 'c') {\r

  \    let rParent = getRect(dParent);\r

  \    let [wParent, hParent] = [rParent.w, rParent.h];\r

  \    let rElem = getRect(elem);\r

  \    let [wElem, hElem] = [rElem.w, rElem.h];\r

  \    switch (pos) {\r

  \      case 'cc': mStyle(elem, { position: 'absolute', left: hor + (wParent
  - wElem) / 2, top: vert + (hParent - hElem) / 2 }); break;\r

  \      case 'tc': mStyle(elem, { position: 'absolute', left: hor + (wParent
  - wElem) / 2, top: vert }); break;\r

  \      case 'bc': mStyle(elem, { position: 'absolute', left: hor + (wParent
  - wElem) / 2, bottom: vert }); break;\r

  \      case 'cl': mStyle(elem, { position: 'absolute', left: hor, top: vert
  + (hParent - hElem) / 2 }); break;\r

  \      case 'cr': mStyle(elem, { position: 'absolute', right: hor, top: vert
  + (hParent - hElem) / 2 }); break;\r

  \    }\r

  \    return;\r

  \  }\r

  \  let di = { t: 'top', b: 'bottom', r: 'right', l: 'left' };\r

  \  elem.style.position = 'absolute';\r

  \  elem.style[di[pos[0]]] = hor + 'px'; elem.style[di[pos[1]]] = vert +
  'px';\r

  }"
mPopup: "function mPopup(content, dParent, styles, id) {\r

  \  if (isdef(mBy(id))) mRemove(id);\r

  \  mIfNotRelative(dParent);\r

  \  if (nundef(styles)) styles = { top: 0, left: 0 };\r

  \  styles.position = 'absolute';\r

  \  let d1 = mDiv(dParent, styles, valf(id, getUID()), content);\r

  \  return d1;\r

  }"
mPos: "function mPos(d, x, y, unit = 'px') { mStyle(d, { left: x, top: y,
  position: 'absolute' }, unit); }"
mPulse: function mPulse(d, ms, callback = null) { mClass(d, 'onPulse');
  TO[getUID()] = setTimeout(() => { mClassRemove(d, 'onPulse'); if (callback)
  callback(); }, ms); }
mPulse1: function mPulse1(d, callback) { mPulse(d, 1000, callback); }
mPulse2: function mPulse2(d, callback) { mPulse(d, 2000, callback); }
mPulse3: function mPulse3(d, callback) { mPulse(d, 3000, callback); }
mRadio: "function mRadio(label, val, name, dParent, styles = {}, handler,
  group_id, is_on) {\r

  \  let cursor = styles.cursor; delete styles.cursor;\r

  \  let d = mDiv(dParent, styles, group_id + '_' + val);\r

  \  let id = isdef(group_id) ? `i_${group_id}_${val}` : getUID();\r

  \  let type = isdef(group_id) ? 'radio' : 'checkbox';\r

  \  let checked = isdef(is_on) ? is_on : false;\r

  \  let inp = mCreateFrom(`<input class='radio' id='${id}' type=\"${type}\"
  name=\"${name}\" value=\"${val}\">`); \r

  \  if (checked) inp.checked = true;\r

  \  let text = mCreateFrom(`<label for='${inp.id}'>${label}</label>`);\r

  \  if (isdef(cursor)) { inp.style.cursor = text.style.cursor = cursor; }\r

  \  mAppend(d, inp);\r

  \  mAppend(d, text);\r

  \  if (isdef(handler)) {\r

  \    inp.onclick = ev => {\r

  \      ev.cancelBubble = true;\r

  \      if (handler == 'toggle') {\r

  \      } else if (isdef(handler)) {\r

  \        handler(val);\r

  \      }\r

  \    };\r

  \  }\r

  \  return d;\r

  }"
mRadio1: "function mRadio1(label, val, dParent, styles = {}, handler, group_id)
  {\r

  \  let cursor = styles.cursor; delete styles.cursor;\r

  \  let d = mDiv(dParent, styles, group_id + '_' + val);\r

  \  let inp = mCreateFrom(`<input class='radio' id='i_${group_id}_${val}'
  type=\"radio\" name=\"${group_id}\" value=\"${val}\" >`);\r

  \  let text = mCreateFrom(`<label for='${inp.id}'>${label}</label>`);\r

  \  if (isdef(cursor)) { inp.style.cursor = text.style.cursor = cursor; }\r

  \  mAppend(d, inp);\r

  \  mAppend(d, text);\r

  \  if (isdef(handler)) d.onclick = () => handler(val);\r

  \  return d;\r

  }"
mRadioGroup: "function mRadioGroup(dParent, styles, id, legend, legendstyles)
  {\r

  \  let f = mCreate('fieldset');\r

  \  f.id = id;\r

  \  if (isdef(styles)) mStyle(f, styles);\r

  \  if (isdef(legend)) {\r

  \    let l = mCreate('legend');\r

  \    l.innerHTML = legend;\r

  \    mAppend(f, l);\r

  \    if (isdef(legendstyles)) { mStyle(l, legendstyles); }\r

  \  }\r

  \  mAppend(dParent, f);\r

  \  return f;\r

  }"
mRadioToggle: "function mRadioToggle(label, val, dParent, styles = {}, is_on =
  true) {\r

  \  let cursor = styles.cursor; delete styles.cursor;\r

  \  let d = mDiv(dParent, styles);\r

  \  let id = getUID();\r

  \  let inp = mCreateFrom(`<input class='radio' id='${id}' type=\"checkbox\"
  checked=\"${is_on}\" value=\"${val}\" >`);\r

  \  let text = mCreateFrom(`<label for='${id}'>${label}</label>`);\r

  \  if (isdef(cursor)) { inp.style.cursor = text.style.cursor = cursor; }\r

  \  mAppend(d, inp);\r

  \  mAppend(d, text);\r

  \  return d;\r

  }"
mRemove: "function mRemove(elem) {\r

  \  elem = toElem(elem);\r

  \  var a = elem.attributes, i, l, n;\r

  \  if (a) {\r

  \    for (i = a.length - 1; i >= 0; i -= 1) {\r

  \      n = a[i].name;\r

  \      if (typeof elem[n] === 'function') {\r

  \        elem[n] = null;\r

  \      }\r

  \    }\r

  \  }\r

  \  a = elem.childNodes;\r

  \  if (a) {\r

  \    l = a.length;\r

  \    for (i = a.length - 1; i >= 0; i -= 1) {\r

  \      mRemove(elem.childNodes[i]);\r

  \    }\r

  \  }\r

  \  elem.remove(); \r

  }"
mRemoveChildrenFromIndex: function mRemoveChildrenFromIndex(dParent, i) { while
  (dParent.children[i]) { mRemove(dParent.children[i]); } }
mRise: "function mRise(d, ms = 800) {\r

  \  toElem(d).animate([{ opacity: 0, transform: 'translateY(50px)' }, {
  opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: ms,
  easing: 'ease' });\r

  }"
mScale: "function mScale(d, scale) { mStyle(d, { 'transform-origin': 'top',
  transform: `scale(${scale})` }); }"
mSelectTableRow: "function mSelectTableRow(r, color = 'pink') {\r

  \  let t = r.parentNode;\r

  \  for (const ch of t.children) mStyle(ch, { background: 'transparent' });\r

  \  mStyle(r, { background: color });\r

  }"
mShield: "function mShield(dParent, styles = { bg: '#00000020' }, id = null,
  classnames = null, hideonclick = false) {\r

  \  dParent = toElem(dParent);\r

  \  let d = mDiv(dParent, styles, id, classnames);\r

  \  lookupAddIfToList(DA, ['shields'], d);\r

  \  mIfNotRelative(dParent);\r

  \  mStyle(d, { position: 'absolute', left: 0, top: 0, w: '100%', h: '100%'
  });\r

  \  if (hideonclick) d.onclick = ev => { evNoBubble(ev); d.remove(); };\r

  \  else d.onclick = ev => { evNoBubble(ev); };\r

  \  mClass(d, 'topmost');\r

  \  return d;\r

  }"
mShieldsOff: function mShieldsOff() { if (nundef(DA.shields)) return; for (const
  d of DA.shields) d.remove(); }
mShow: "function mShow(d, ms = 0) { if (ms > 0) mAppear(d, ms); else mStyle(d, {
  opacity: 1 }); }"
mShrink: "function mShrink(d, x = .75, y = .75, ms = 800, callback = null) {\r

  \  let anim = toElem(d).animate([{ transform: `scale(${1},${1})` }, {
  transform: `scale(${x},${y})` },], { fill: 'both', duration: ms, easing:
  'ease' });\r

  \  anim.onfinish = callback;\r

  }"
mShrinkTranslate: "function mShrinkTranslate(child, scale, newParent, ms = 800,
  callback) {\r

  \  let [dx, dy] = get_screen_distance(child, newParent);\r

  \  mAnimate(child, 'transform', [`translateX(${dx}px) translateY(${dy}px)
  scale(${scale})`], callback, ms, 'ease');\r

  }"
mShrinkUp: "function mShrinkUp(d, x = .75, y = 0, ms = 800, callback = null) {\r

  \  let anim = toElem(d).animate([{ transform: `scale(${1},${1})`, opacity: 1
  }, { transform: `scale(${x},${y})`, opacity: 0 },], { fill: 'none', duration:
  ms, easing: 'ease' });\r

  \  anim.onfinish = mClear(d);\r

  }"
mSize: "function mSize(d, w, h, unit = 'px', sizing) { if (nundef(h)) h = w;
  mStyle(d, { width: w, height: h }, unit); if (isdef(sizing)) setRect(d,
  sizing); }"
mStamp: "function mStamp(d1, text, color, sz) {\r

  \  mStyle(d1, { position: 'relative' });\r

  \  let r = getRect(d1);\r

  \  let [w, h] = [r.w, r.h];\r

  \  color = valf(color, 'black');\r

  \  sz = valf(sz, r.h / 7);\r

  \  let [padding, border, rounding, angle] = [sz / 10, sz / 6, sz / 8,
  rChoose([-16, -14, -10, 10, 14])];\r

  \  let d2 = mDiv(d1, {\r

  \    fg: color,\r

  \    position: 'absolute', top: 25, left: 5,\r

  \    transform: `rotate(${angle}deg)`,\r

  \    fz: sz,\r

  \    hpadding: 2,\r

  \    vpadding: 0,\r

  \    rounding: rounding,\r

  \    border: `${border}px solid ${colorTrans(color, .8)}`, \r

  \    '-webkit-mask-size': `${w}px ${h}px`,\r

  \    '-webkit-mask-position': `50% 50%`,\r

  \    '-webkit-mask-image':
  'url(\"../base/assets/images/textures/grunge.png\")',\r

  \    weight: 400, \r

  \    display: 'inline-block',\r

  \    'text-transform': 'uppercase',\r

  \    family: 'blackops', \r

  \    'mix-blend-mode': 'multiply',\r

  \  }, null, text);\r

  }"
mStyle: "function mStyle(elem, styles, unit = 'px') {\r

  \  elem = toElem(elem);\r

  \  if (isdef(styles.vmargin)) { styles.mabottom = styles.matop =
  styles.vmargin; }\r

  \  if (isdef(styles.hmargin)) { styles.maleft = styles.maright =
  styles.hmargin; }\r

  \  let bg, fg;\r

  \  if (isdef(styles.bg) || isdef(styles.fg)) {\r

  \    [bg, fg] = colorsFromBFA(styles.bg, styles.fg, styles.alpha);\r

  \  }\r

  \  if (isdef(styles.vpadding) || isdef(styles.hpadding)) {\r

  \    styles.padding = valf(styles.vpadding, 0) + unit + ' ' +
  valf(styles.hpadding, 0) + unit;\r

  \  }\r

  \  if (isdef(styles.upperRounding)) {\r

  \    let rtop = '' + valf(styles.upperRounding, 0) + unit;\r

  \    let rbot = '0' + unit;\r

  \    styles['border-radius'] = rtop + ' ' + rtop + ' ' + rbot + ' ' +
  rbot;\r

  \  } else if (isdef(styles.lowerRounding)) {\r

  \    let rbot = '' + valf(styles.lowerRounding, 0) + unit;\r

  \    let rtop = '0' + unit;\r

  \    styles['border-radius'] = rtop + ' ' + rtop + ' ' + rbot + ' ' +
  rbot;\r

  \  }\r

  \  if (isdef(styles.box)) styles['box-sizing'] = 'border-box';\r

  \  for (const k in styles) {\r

  \    let val = styles[k];\r

  \    let key = k;\r

  \    if (isdef(STYLE_PARAMS[k])) key = STYLE_PARAMS[k];\r

  \    else if (k == 'font' && !isString(val)) {\r

  \      let fz = f.size; if (isNumber(fz)) fz = '' + fz + 'px';\r

  \      let ff = f.family;\r

  \      let fv = f.variant;\r

  \      let fw = isdef(f.bold) ? 'bold' : isdef(f.light) ? 'light' :
  f.weight;\r

  \      let fs = isdef(f.italic) ? 'italic' : f.style;\r

  \      if (nundef(fz) || nundef(ff)) return null;\r

  \      let s = fz + ' ' + ff;\r

  \      if (isdef(fw)) s = fw + ' ' + s;\r

  \      if (isdef(fv)) s = fv + ' ' + s;\r

  \      if (isdef(fs)) s = fs + ' ' + s;\r

  \      elem.style.setProperty(k, s);\r

  \      continue;\r

  \    } else if (k == 'classname') {\r

  \      mClass(elem, styles[k]);\r

  \    } else if (k == 'border') {\r

  \      if (isNumber(val)) val = `solid ${val}px ${isdef(styles.fg) ?
  styles.fg : '#ffffff80'}`;\r

  \      if (val.indexOf(' ') < 0) val = 'solid 1px ' + val;\r

  \    } else if (k == 'layout') {\r

  \      if (val[0] == 'f') {\r

  \        val = val.slice(1);\r

  \        elem.style.setProperty('display', 'flex');\r

  \        elem.style.setProperty('flex-wrap', 'wrap');\r

  \        let hor, vert;\r

  \        if (val.length == 1) hor = vert = 'center';\r

  \        else {\r

  \          let di = { c: 'center', s: 'start', e: 'end' };\r

  \          hor = di[val[1]];\r

  \          vert = di[val[2]];\r

  \        }\r

  \        let justStyle = val[0] == 'v' ? vert : hor;\r

  \        let alignStyle = val[0] == 'v' ? hor : vert;\r

  \        elem.style.setProperty('justify-content', justStyle);\r

  \        elem.style.setProperty('align-items', alignStyle);\r

  \        switch (val[0]) {\r

  \          case 'v': elem.style.setProperty('flex-direction', 'column');
  break;\r

  \          case 'h': elem.style.setProperty('flex-direction', 'row');
  break;\r

  \        }\r

  \      } else if (val[0] == 'g') {\r

  \        val = val.slice(1);\r

  \        elem.style.setProperty('display', 'grid');\r

  \        let n = allNumbers(val);\r

  \        let cols = n[0];\r

  \        let w = n.length > 1 ? '' + n[1] + 'px' : 'auto';\r

  \        elem.style.setProperty('grid-template-columns', `repeat(${cols},
  ${w})`);\r

  \        elem.style.setProperty('place-content', 'center');\r

  \      }\r

  \    } else if (k == 'layflex') {\r

  \      elem.style.setProperty('display', 'flex');\r

  \      elem.style.setProperty('flex', '0 1 auto');\r

  \      elem.style.setProperty('flex-wrap', 'wrap');\r

  \      if (val == 'v') { elem.style.setProperty('writing-mode',
  'vertical-lr'); }\r

  \    } else if (k == 'laygrid') {\r

  \      elem.style.setProperty('display', 'grid');\r

  \      let n = allNumbers(val);\r

  \      let cols = n[0];\r

  \      let w = n.length > 1 ? '' + n[1] + 'px' : 'auto';\r

  \      elem.style.setProperty('grid-template-columns', `repeat(${cols},
  ${w})`);\r

  \      elem.style.setProperty('place-content', 'center');\r

  \    }\r

  \    if (key == 'font-weight') { elem.style.setProperty(key, val); continue;
  }\r

  \    else if (key == 'background-color') elem.style.background = bg;\r

  \    else if (key == 'color') elem.style.color = fg;\r

  \    else if (key == 'opacity') elem.style.opacity = val;\r

  \    else if (key == 'wrap') elem.style.flexWrap = 'wrap';\r

  \    else if (startsWith(k, 'dir')) {\r

  \      isCol = val[0] == 'c';\r

  \      elem.style.setProperty('flex-direction', 'column'); \r

  \    } else if (key == 'flex') {\r

  \      if (isNumber(val)) val = '' + val + ' 1 0%';\r

  \      elem.style.setProperty(key, makeUnitString(val, unit));\r

  \    } else {\r

  \      elem.style.setProperty(key, makeUnitString(val, unit));\r

  \    }\r

  \  }\r

  }"
mStyleRemove: "function mStyleRemove(elem, prop) {\r

  \  if (isdef(STYLE_PARAMS[prop])) prop = STYLE_PARAMS[prop];\r

  \  elem.style.removeProperty(prop);\r

  }"
mSuit: "function mSuit(ckey, sz = 20, color = null) {\r

  \  let suit = ckey.length == 1 ? ckey : ckey[1];\r

  \  let di = { S: '&spades;', H: '&hearts;', D: '&diams;', C: '&clubs;' };\r

  \  color = valf(color, suit == 'H' || suit == 'D' ? 'red' : 'black');\r

  \  let html = `<span
  style='color:${color};font-size:${sz}px'>${di[suit]}</span>`;\r

  \  return html;\r

  }"
mSym: "function mSym(key, dParent, styles = {}, pos, classes) {\r

  \  let info = Syms[key];\r

  \  styles.display = 'inline-block';\r

  \  let family = info.family; \r

  \  styles.family = family;\r

  \  let sizes;\r

  \  if (isdef(styles.sz)) { sizes = mSymSizeToBox(info, styles.sz,
  styles.sz); }\r

  \  else if (isdef(styles.w) && isdef(styles.h)) { sizes =
  mSymSizeToBox(info, styles.w, styles.h); }\r

  \  else if (isdef(styles.fz)) { sizes = mSymSizeToFz(info, styles.fz); }\r

  \  else if (isdef(styles.h)) { sizes = mSymSizeToH(info, styles.h); }\r

  \  else if (isdef(styles.w)) { sizes = mSymSizeToW(info, styles.w); }\r

  \  else { sizes = mSymSizeToFz(info, 25); }\r

  \  styles.fz = sizes.fz;\r

  \  styles.w = sizes.w;\r

  \  styles.h = sizes.h;\r

  \  styles.align = 'center';\r

  \  if (isdef(styles.bg) && info.family != 'emoNoto') { styles.fg =
  styles.bg; delete styles.bg; }\r

  \  let x = mDiv(dParent, styles, null, info.text);\r

  \  if (isdef(classes)) mClass(x, classes);\r

  \  if (isdef(pos)) { mPlace(x, pos); }\r

  \  return x;\r

  }"
mSymText: "function mSymText(s, dParent, styles = {}, pos, classes) {\r

  \  styles.display = 'inline-block';\r

  \  styles.w = valfi(styles.w, styles.sz, styles.h, '25%');\r

  \  styles.h = valfi(styles.h, styles.sz, styles.w, styles.fz, '25%');\r

  \  styles.fz = valfi(styles.fz, styles.sz * 4 / 5, styles.h * 4 / 5,
  styles.w * 2, '20%');\r

  \  styles.align = 'center';\r

  \  let x = mDiv(dParent, styles, null, s); mCenterCenterFlex(x);\r

  \  if (isdef(classes)) mClass(x, classes);\r

  \  if (isdef(pos)) { mPlace(x, pos); }\r

  \  return x;\r

  }"
mTable: "function mTable(dParent, headers, showheaders, styles = { mabottom: 0
  }, className = 'table') {\r

  \  let d = mDiv(dParent);\r

  \  let t = mCreate('table');\r

  \  mAppend(d, t);\r

  \  if (isdef(className)) mClass(t, className);\r

  \  if (isdef(styles)) mStyle(t, styles);\r

  \  if (showheaders) {\r

  \    let code = `<tr>`;\r

  \    for (const h of headers) {\r

  \      code += `<th>${h}</th>`\r

  \    }\r

  \    code += `</tr>`;\r

  \    t.innerHTML = code;\r

  \  }\r

  \  return t;\r

  }"
mTableCol: "function mTableCol(r, val) {\r

  \  let col = mCreate('td');\r

  \  mAppend(r, col);\r

  \  if (isdef(val)) col.innerHTML = val;\r

  \  return col;\r

  }"
mTableCommandify: "function mTableCommandify(rowitems, di) {\r

  \  for (const item of rowitems) {\r

  \    for (const index in di) {\r

  \      let colitem = item.colitems[index];\r

  \      colitem.div.innerHTML = di[index](item, colitem.val);\r

  \    }\r

  \  }\r

  }"
mTableCommandifyList: "function mTableCommandifyList(rowitem, val, func) {\r

  \  let names = isString(val) ? val.replaceAll(' ', ',').split(',') : val;\r

  \  let html = '';\r

  \  for (const name of names) {\r

  \    html += func(rowitem, name); \r

  \  }\r

  \  return html;\r

  }"
mTableHeader: "function mTableHeader(t, val) {\r

  \  let col = mCreate('th');\r

  \  mAppend(t.firstChild, col);\r

  \  col.innerHTML = val;\r

  \  return col;\r

  }"
mTableRow: "function mTableRow(t, o, headers, id) {\r

  \  let elem = mCreate('tr');\r

  \  if (isdef(id)) elem.id = id;\r

  \  mAppend(t, elem);\r

  \  let colitems = [];\r

  \  for (const k of headers) {\r

  \    let val = isdef(o[k]) ? isDict(o[k]) ? JSON.stringify(o[k]) :
  isList(o[k]) ? o[k].join(', ') : o[k] : '';\r

  \    let col = mTableCol(elem, val);\r

  \    colitems.push({ div: col, key: k, val: val });\r

  \  }\r

  \  return { div: elem, colitems: colitems };\r

  }"
mTableTransition: "function mTableTransition(d, ms = 800) {\r

  \  toElem(d).animate([{ opacity: .25 }, { opacity: 1 },], { fill: 'both',
  duration: ms, easing: 'ease' });\r

  }"
mText: "function mText(text, dParent, styles, classes) {\r

  \  if (!isString(text)) text = text.toString();\r

  \  let d = mDiv(dParent);\r

  \  if (!isEmpty(text)) { d.innerHTML = text; }\r

  \  if (isdef(styles)) mStyle(d, styles);\r

  \  if (isdef(classes)) mClass(d, classes);\r

  \  return d;\r

  }"
mTextArea: "function mTextArea(rows, cols, dParent, styles = {}, id) {\r

  \  let html = `<textarea id=\"${id}\" rows=\"${rows}\" cols=\"${cols}\"
  wrap=\"hard\"></textarea>`;\r

  \  let t = mCreateFrom(html);\r

  \  mAppend(dParent, t);\r

  \  mStyle(t, styles);\r

  \  return t;\r

  }"
mTranslate: "function mTranslate(child, newParent, ms = 800, callback = null)
  {\r

  \  let [dx, dy] = get_screen_distance(child, newParent);\r

  \  onend = () => { mAppend(newParent, child); if (callback) callback(); };\r

  \  mAnimate(child, 'transform', [`translateX(${dx}px) translateY(${dy}px)`],
  onend, ms, 'ease'); \r

  }"
mTranslateBy: "function mTranslateBy(elem, x, y, ms = 800, callback = null) {\r

  \  mAnimate(elem, 'transform', [`translateX(${x}px) translateY(${y}px)`],
  callback, ms, 'ease'); \r

  }"
mTranslateByFade: "function mTranslateByFade(elem, x, y, ms = 800, callback =
  null) {\r

  \  mAnimate(elem, 'transform', [`translateX(${x}px) translateY(${y}px)`],
  callback, ms, 'ease'); \r

  \  let a = toElem(elem).animate([{ opacity: .25 }, { opacity: 1 },], { fill:
  'both', duration: ms, easing: 'ease' });\r

  }"
mYaml: "function mYaml(d, js) {\r

  \  d.innerHTML = '<pre>' + jsonToYaml(js) + '</pre>';\r

  \  return d;\r

  }"
normalize_string: "function normalize_string(s, sep = '_') {\r

  \  s = s.toLowerCase().trim();\r

  \  let res = '';\r

  \  for (let i = 0; i < s.length; i++) { if (isAlphaNum(s[i])) res += s[i];
  else if (s[i] == ' ') res += sep; }\r

  \  return res;\r

  }"
nundef: function nundef(x) { return x === null || x === undefined; }
old_mButtonX: "function old_mButtonX(dParent, pos = 'tr', handler = null,
  defaultBehavior = 'hide', sz = 40) {\r

  \  dParent = toElem(dParent);\r

  \  let styles = { cursor: 'pointer', w: sz, h: sz };\r

  \  let d2 = mDiv(dParent, styles, null, `<svg width='100%' height='100%'
  ><use xlink:href=\"#Times\" /></svg>`); \r

  \  mClass(d2, 'svgbtnX');\r

  \  d2.onclick = isdef(handler) ? handler : defaultBehavior == 'hide' ? () =>
  hide(dParent) : () => dParent.remove();\r

  \  mPlace(d2, pos, 10);\r

  \  return d2;\r

  }"
oneWordKeys: function oneWordKeys(keys) { return keys.filter(x => !x.includes(' ')); }
plural: "function plural(n) { return n == 0 || n > 1 ? 's' : ''; }"
pSBC: "function pSBC(p, c0, c1, l) {\r

  \  let r,\r

  \    g,\r

  \    b,\r

  \    P,\r

  \    f,\r

  \    t,\r

  \    h,\r

  \    i = parseInt,\r

  \    m = Math.round,\r

  \    a = typeof c1 == 'string';\r

  \  if (typeof p != 'number' || p < -1 || p > 1 || typeof c0 != 'string' ||
  (c0[0] != 'r' && c0[0] != '#') || (c1 && !a)) return null;\r

  \  if (!this.pSBCr)\r

  \    this.pSBCr = d => {\r

  \      let n = d.length,\r

  \        x = {};\r

  \      if (n > 9) {\r

  \        ([r, g, b, a] = d = d.split(',')), (n = d.length);\r

  \        if (n < 3 || n > 4) return null;\r

  \        (x.r = i(r[3] == 'a' ? r.slice(5) : r.slice(4))), (x.g = i(g)),
  (x.b = i(b)), (x.a = a ? parseFloat(a) : -1);\r

  \      } else {\r

  \        if (n == 8 || n == 6 || n < 4) return null;\r

  \        if (n < 6) d = '#' + d[1] + d[1] + d[2] + d[2] + d[3] + d[3] + (n >
  4 ? d[4] + d[4] : '');\r

  \        d = i(d.slice(1), 16);\r

  \        if (n == 9 || n == 5) (x.r = (d >> 24) & 255), (x.g = (d >> 16) &
  255), (x.b = (d >> 8) & 255), (x.a = m((d & 255) / 0.255) / 1000);\r

  \        else (x.r = d >> 16), (x.g = (d >> 8) & 255), (x.b = d & 255), (x.a
  = -1);\r

  \      }\r

  \      return x;\r

  \    };\r

  \  (h = c0.length > 9),\r

  \    (h = a ? (c1.length > 9 ? true : c1 == 'c' ? !h : false) : h),\r

  \    (f = pSBCr(c0)),\r

  \    (P = p < 0),\r

  \    (t = c1 && c1 != 'c' ? pSBCr(c1) : P ? { r: 0, g: 0, b: 0, a: -1 } : {
  r: 255, g: 255, b: 255, a: -1 }),\r

  \    (p = P ? p * -1 : p),\r

  \    (P = 1 - p);\r

  \  if (!f || !t) return null;\r

  \  if (l) (r = m(P * f.r + p * t.r)), (g = m(P * f.g + p * t.g)), (b = m(P *
  f.b + p * t.b));\r

  \  else (r = m((P * f.r ** 2 + p * t.r ** 2) ** 0.5)), (g = m((P * f.g ** 2
  + p * t.g ** 2) ** 0.5)), (b = m((P * f.b ** 2 + p * t.b ** 2) ** 0.5));\r

  \  (a = f.a), (t = t.a), (f = a >= 0 || t >= 0), (a = f ? (a < 0 ? t : t < 0
  ? a : a * P + t * p) : 0);\r

  \  if (h) return 'rgb' + (f ? 'a(' : '(') + r + ',' + g + ',' + b + (f ? ','
  + m(a * 1000) / 1000 : '') + ')';\r

  \  else return '#' + (4294967296 + r * 16777216 + g * 65536 + b * 256 + (f ?
  m(a * 255) : 0)).toString(16).slice(1, f ? undefined : -2);\r

  }"
rAlphanums: function rAlphanums(n) { return
  rChoose(toLetters('0123456789abcdefghijklmnopq'), n); }
randomColor: function randomColor() { return rColor(); }
range: "function range(f, t, st = 1) {\r

  \  if (nundef(t)) {\r

  \    t = f - 1;\r

  \    f = 0;\r

  \  }\r

  \  let arr = [];\r

  \  for (let i = f; i <= t; i += st) {\r

  \    arr.push(i);\r

  \  }\r

  \  return arr;\r

  }"
rCard: function rCard(postfix = 'n', ranks = '*A23456789TJQK', suits = 'HSDC') {
  return rChoose(ranks) + rChoose(suits) + postfix; }
rChoose: "function rChoose(arr, n = 1, func = null, exceptIndices = null) {\r

  \  let indices = arrRange(0, arr.length - 1);\r

  \  if (isdef(exceptIndices)) {\r

  \    for (const i of exceptIndices) removeInPlace(indices, i);\r

  \  }\r

  \  if (isdef(func)) indices = indices.filter(x => func(arr[x]));\r

  \  if (n == 1) {\r

  \    let idx = Math.floor(Math.random() * indices.length);\r

  \    return arr[indices[idx]];\r

  \  }\r

  \  arrShufflip(indices);\r

  \  return indices.slice(0, n).map(x => arr[x]);\r

  }"
rCoin: "function rCoin(percent = 50) {\r

  \  let r = Math.random();\r

  \  r *= 100;\r

  \  return r < percent;\r

  }"
rColor: "function rColor(brightness) {\r

  \  if (isdef(brightness)) {\r

  \    let hue = rHue();\r

  \    let sat = 100;\r

  \    let b = isNumber(brightness) ? brightness : brightness == 'dark' ? 25 :
  brightness == 'light' ? 75 : 50;\r

  \    return colorFromHSL(hue, sat, b);\r

  \  }\r

  \  let s = '#';\r

  \  for (let i = 0; i < 6; i++) {\r

  \    s += rChoose(['f', 'c', '9', '6', '3', '0']);\r

  \  }\r

  \  return s;\r

  }"
rDate: "function rDate(before, after) {\r

  \  let after_date = new Date(after);\r

  \  let before_date = new Date(before);\r

  \  let random_date = new Date(Math.random() * (before_date.getTime() -
  after_date.getTime()) + after_date.getTime());\r

  \  return random_date;\r

  }"
rDigits: function rDigits(n) { return rChoose(toLetters('0123456789'), n); }
recConvertLists: "function recConvertLists(o, maxlen = 25) {\r

  \  for (const k in o) {\r

  \    let val = o[k];\r

  \    if (isList(val)) {\r

  \      if (val.length > maxlen) val = val.slice(0, maxlen).toString() +
  '...';\r

  \      else val = val.toString();\r

  \      o[k] = val;\r

  \    } else if (isDict(val)) recConvertLists(val);\r

  \  }\r

  }"
removeDuplicates: "function removeDuplicates(keys, prop) {\r

  \  let di = {};\r

  \  let res = [];\r

  \  let items = keys.map(x => Syms[x]);\r

  \  for (const item of items) {\r

  \    if (isdef(di[item.best])) { continue; }\r

  \    res.push(item);\r

  \    di[item.key] = true;\r

  \  }\r

  \  return res.map(x => x.key);\r

  }"
removeInPlace: "function removeInPlace(arr, el) {\r

  \  arrRemovip(arr, el);\r

  }"
replaceAll: "function replaceAll(str, sSub, sBy) {\r

  \  let regex = new RegExp(sSub, 'g');\r

  \  return str.replace(regex, sBy);\r

  }"
replaceAllFast: function replaceAllFast(str, sSub, sBy) { return replaceAll(str, sSub, sBy); }
replaceAllSafe: function replaceAllSafe(str, sSub, sBy) { return
  replaceAllSpecialChars(str, sSub, sBy); }
replaceAllSpecialChars: function replaceAllSpecialChars(str, sSub, sBy) { return
  str.split(sSub).join(sBy); }
replaceAllX: function replaceAllX(str, sSub, sBy) { return
  replaceAllSpecialChars(str, sSub, sBy); }
replaceAtString: function replaceAtString(s, i, ssub) { return s.substring(0, i)
  + ssub + s.substring(i + 1); }
replaceEvery: "function replaceEvery(w, letter, nth) {\r

  \  let res = '';\r

  \  for (let i = 1; i < w.length; i += 2) {\r

  \    res += letter;\r

  \    res += w[i];\r

  \  }\r

  \  if (w.length % 2) res += w[0];\r

  \  return res;\r

  }"
return_elem_to_deck_from: function return_elem_to_deck_from(el, arr, deck) {
  elem_from_to(el, arr, deck); }
reverse: "function reverse(x) {\r

  \  if (isString(x)) {\r

  \    var newString = \"\";\r

  \    for (var i = x.length - 1; i >= 0; i--) {\r

  \      newString += x[i];\r

  \    }\r

  \    return newString;\r

  \  }\r

  \  if (isList(x)) return x.reverse();\r

  \  if (isDict(x)) return dict2list(x, 'value').reverse();\r

  \  return x;\r

  }"
RGBAToHex9: "function RGBAToHex9(rgba) {\r

  \  let n = allNumbers(rgba); \r

  \  if (n.length < 3) {\r

  \    return randomHexColor();\r

  \  }\r

  \  let a = n.length > 3 ? n[3] : 1;\r

  \  let sa = alphaToHex(a);\r

  \  if (rgba.includes('%')) {\r

  \    n[0] = Math.round((n[0] * 255) / 100);\r

  \    n[1] = Math.round((n[1] * 255) / 100);\r

  \    n[2] = Math.round((n[2] * 255) / 100);\r

  \  }\r

  \  return '#' + ((1 << 24) + (n[0] << 16) + (n[1] << 8) +
  n[2]).toString(16).slice(1) + sa;\r

  }"
RGBAToHSLA: "function RGBAToHSLA(rgba) {\r

  \  let ex =
  /^rgba\\((((((((1?[1-9]?\\d)|10\\d|(2[0-4]\\d)|25[0-5]),\\s?)){3})|(((([1-9]?\
  \\d(\\.\\d+)?)|100|(\\.\\d+))%,\\s?){3}))|(((((1?[1-9]?\\d)|10\\d|(2[0-4]\\d)\
  |25[0-5])\\s){3})|(((([1-9]?\\d(\\.\\d+)?)|100|(\\.\\d+))%\\s){3}))\\/\\s)((0?\
  \\.\\d+)|[01]|(([1-9]?\\d(\\.\\d+)?)|100|(\\.\\d+))%)\\)$/i;\r

  \  if (ex.test(rgba)) {\r

  \    let sep = rgba.indexOf(',') > -1 ? ',' : ' ';\r

  \    rgba = rgba\r

  \      .substr(5)\r

  \      .split(')')[0]\r

  \      .split(sep);\r

  \    if (rgba.indexOf('/') > -1) rgba.splice(3, 1);\r

  \    for (let R in rgba) {\r

  \      let r = rgba[R];\r

  \      if (r.indexOf('%') > -1) {\r

  \        let p = r.substr(0, r.length - 1) / 100;\r

  \        if (R < 3) {\r

  \          rgba[R] = Math.round(p * 255);\r

  \        }\r

  \      }\r

  \    }\r

  \    let r = rgba[0] / 255,\r

  \      g = rgba[1] / 255,\r

  \      b = rgba[2] / 255,\r

  \      a = rgba[3],\r

  \      cmin = Math.min(r, g, b),\r

  \      cmax = Math.max(r, g, b),\r

  \      delta = cmax - cmin,\r

  \      h = 0,\r

  \      s = 0,\r

  \      l = 0;\r

  \    if (delta == 0) h = 0;\r

  \    else if (cmax == r) h = ((g - b) / delta) % 6;\r

  \    else if (cmax == g) h = (b - r) / delta + 2;\r

  \    else h = (r - g) / delta + 4;\r

  \    h = Math.round(h * 60);\r

  \    if (h < 0) h += 360;\r

  \    l = (cmax + cmin) / 2;\r

  \    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\r

  \    s = +(s * 100).toFixed(1);\r

  \    l = +(l * 100).toFixed(1);\r

  \    return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';\r

  \  } else {\r

  \    return 'Invalid input color';\r

  \  }\r

  }"
rgbToHex: function rgbToHex(rgbStr) { return rgbStr && '#' + rgbStr.slice(4,
  -1).split(',').map(x => (+x).toString(16).padStart(2, '0')).join(''); }
RGBToHex7: "function RGBToHex7(c) {\r

  \  let n = allNumbers(c);\r

  \  if (c.includes('%')) {\r

  \    n[0] = Math.round((n[0] * 255) / 100);\r

  \    n[1] = Math.round((n[1] * 255) / 100);\r

  \    n[2] = Math.round((n[2] * 255) / 100);\r

  \  }\r

  \  return '#' + ((1 << 24) + (n[0] << 16) + (n[1] << 8) +
  n[2]).toString(16).slice(1);\r

  }"
RGBToHSL: "function RGBToHSL(rgb) {\r

  \  let ex =
  /^rgb\\((((((((1?[1-9]?\\d)|10\\d|(2[0-4]\\d)|25[0-5]),\\s?)){2}|((((1?[1-9]?\
  \\d)|10\\d|(2[0-4]\\d)|25[0-5])\\s)){2})((1?[1-9]?\\d)|10\\d|(2[0-4]\\d)|25[0\
  -5]))|((((([1-9]?\\d(\\.\\d+)?)|100|(\\.\\d+))%,\\s?){2}|((([1-9]?\\d(\\.\\d+\
  )?)|100|(\\.\\d+))%\\s){2})(([1-9]?\\d(\\.\\d+)?)|100|(\\.\\d+))%))\\)$/i;\r

  \  if (ex.test(rgb)) {\r

  \    let sep = rgb.indexOf(',') > -1 ? ',' : ' ';\r

  \    rgb = rgb\r

  \      .substr(4)\r

  \      .split(')')[0]\r

  \      .split(sep);\r

  \    for (let R in rgb) {\r

  \      let r = rgb[R];\r

  \      if (r.indexOf('%') > -1) rgb[R] = Math.round((r.substr(0, r.length -
  1) / 100) * 255);\r

  \    }\r

  \    let r = rgb[0] / 255,\r

  \      g = rgb[1] / 255,\r

  \      b = rgb[2] / 255,\r

  \      cmin = Math.min(r, g, b),\r

  \      cmax = Math.max(r, g, b),\r

  \      delta = cmax - cmin,\r

  \      h = 0,\r

  \      s = 0,\r

  \      l = 0;\r

  \    if (delta == 0) h = 0;\r

  \    else if (cmax == r) h = ((g - b) / delta) % 6;\r

  \    else if (cmax == g) h = (b - r) / delta + 2;\r

  \    else h = (r - g) / delta + 4;\r

  \    h = Math.round(h * 60);\r

  \    if (h < 0) h += 360;\r

  \    l = (cmax + cmin) / 2;\r

  \    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\r

  \    s = +(s * 100).toFixed(1);\r

  \    l = +(l * 100).toFixed(1);\r

  \    return 'hsl(' + h + ',' + s + '%,' + l + '%)';\r

  \  } else {\r

  \    return 'Invalid input color';\r

  \  }\r

  }"
rHue: function rHue() { return (rNumber(0, 36) * 10) % 360; }
rLetter: function rLetter(except) { return rLetters(1, except)[0]; }
rLetters: "function rLetters(n, except = []) {\r

  \  let all = 'abcdefghijklmnopqrstuvwxyz';\r

  \  for (const l of except) all = all.replace(l, '');\r

  \  console.log('all', all, except)\r

  \  return rChoose(toLetters(all), n);\r

  }"
rNumber: "function rNumber(min = 0, max = 100) {\r

  \  return Math.floor(Math.random() * (max - min + 1)) + min; \r

  }"
route_path_yaml_dict: "async function route_path_yaml_dict(url) {\r

  \  let data = await fetch(url);\r

  \  let text = await data.text();\r

  \  let dict = jsyaml.load(text);\r

  \  return dict;\r

  }"
rPassword: function rPassword(n) { return
  rChoose(toLetters('0123456789abcdefghijklmnopqABCDEFGHIJKLMNOPQRSTUVWXYZ!.?*&%$#@:;_'),
  n).join(''); }
rPrimaryColor: "function rPrimaryColor() { let c = '#' + rChoose(['ff', '00']) +
  rChoose(['ff', '00']); c += c == '#0000' ? 'ff' : c == '#ffff' ? '00' :
  rChoose(['ff', '00']); return c; }"
rRank: function rRank(ranks = 'A23456789TJQK') { return rChoose(ranks); }
rSuit: function rSuit(suit = 'HSDC') { return rChoose(suit); }
sameList: "function sameList(l1, l2) {\r

  \  if (l1.length != l2.length) return false;\r

  \  for (const s of l1) {\r

  \    if (!l2.includes(s)) return false;\r

  \  }\r

  \  return true;\r

  }"
selectText: "function selectText(el) {\r

  \  var sel, range;\r

  \  if (window.getSelection && document.createRange) { \r

  \    sel = window.getSelection();\r

  \    if (sel.toString() == '') { \r

  \      window.setTimeout(function () {\r

  \        range = document.createRange(); \r

  \        range.selectNodeContents(el); \r

  \        sel.removeAllRanges(); \r

  \        sel.addRange(range);\r

  \      }, 1);\r

  \    }\r

  \  } else if (document.selection) { \r

  \    sel = document.selection.createRange();\r

  \    if (sel.text == '') { \r

  \      range = document.body.createTextRange();\r

  \      range.moveToElementText(el);\r

  \      range.select(); \r

  \    }\r

  \  }\r

  }"
setKeys: "function setKeys({ allowDuplicates, nMin = 25, lang, key, keySets,
  filterFunc, param, confidence, sortByFunc } = {}) {\r

  \  let keys = jsCopy(keySets[key]);\r

  \  if (isdef(nMin)) {\r

  \    let diff = nMin - keys.length;\r

  \    let additionalSet = diff > 0 ? nMin > 100 ? firstCondDictKeys(keySets,
  k => k != key && keySets[k].length > diff) : 'best100' : null;\r

  \    if (additionalSet) KeySets[additionalSet].map(x => addIf(keys, x)); \r

  \  }\r

  \  let primary = [];\r

  \  let spare = [];\r

  \  for (const k of keys) {\r

  \    let info = Syms[k];\r

  \    info.best = info[lang];\r

  \    if (nundef(info.best)) {\r

  \      let ersatzLang = (lang == 'D' ? 'D' : 'E');\r

  \      let klang = 'best' + ersatzLang;\r

  \      if (nundef(info[klang])) info[klang] = lastOfLanguage(k,
  ersatzLang);\r

  \    }\r

  \    let isMatch = true;\r

  \    if (isdef(filterFunc)) isMatch = isMatch && filterFunc(param, k,
  info.best);\r

  \    if (isdef(confidence)) isMatch = info[klang + 'Conf'] >= confidence;\r

  \    if (isMatch) { primary.push(k); } else { spare.push(k); }\r

  \  }\r

  \  if (isdef(nMin)) {\r

  \    let len = primary.length;\r

  \    let nMissing = nMin - len;\r

  \    if (nMissing > 0) { let list = choose(spare, nMissing); spare =
  arrMinus(spare, list); primary = primary.concat(list); }\r

  \  }\r

  \  if (isdef(sortByFunc)) { sortBy(primary, sortByFunc); }\r

  \  if (isdef(nMin)) console.assert(primary.length >= nMin);\r

  \  if (nundef(allowDuplicates)) {\r

  \    primary = removeDuplicates(primary);\r

  \  }\r

  \  return primary;\r

  }"
setRect: "function setRect(elem, options) {\r

  \  let r = getRect(elem);\r

  \  elem.rect = r;\r

  \  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  \r

  \  if (isDict(options)) {\r

  \    if (options.hgrow) mStyle(elem, { hmin: r.h });\r

  \    else if (options.hfix) mStyle(elem, { h: r.h });\r

  \    else if (options.hshrink) mStyle(elem, { hmax: r.h });\r

  \    if (options.wgrow) mStyle(elem, { wmin: r.w });\r

  \    else if (options.wfix) mStyle(elem, { w: r.w });\r

  \    else if (options.wshrink) mStyle(elem, { wmax: r.w });\r

  \  }\r

  \  return r;\r

  }"
show: "function show(elem, isInline = false) {\r

  \  if (isString(elem)) elem = document.getElementById(elem);\r

  \  if (isSvg(elem)) {\r

  \    elem.setAttribute('style', 'visibility:visible');\r

  \  } else {\r

  \    elem.style.display = isInline ? 'inline-block' : null;\r

  \  }\r

  \  return elem;\r

  }"
show_special_message: "function show_special_message(msg, stay = false, ms =
  3000, delay = 0, styles = {}, callback = null) { \r

  \  let dParent = mBy('dBandMessage');\r

  \  if (nundef(dParent)) dParent = mDiv(document.body, {}, 'dBandMessage');\r

  \  show(dParent);\r

  \  clearElement(dParent);\r

  \  addKeys({ position: 'fixed', top: 200, classname: 'slow_gradient_blink',
  vpadding: 10, align: 'center', position: 'absolute', fg: 'white', fz: 24, w:
  '100vw' }, styles);\r

  \  if (!isEmpty(styles.classname)) { mClass(dParent, styles.classname); }\r

  \  delete styles.classname;\r

  \  mStyle(dParent, styles);\r

  \  dParent.innerHTML = msg;\r

  \  if (delay > 0) TO.special = setTimeout(() => { mFadeRemove(dParent, ms,
  callback); }, delay);\r

  \  else mFadeRemove(dParent, ms, callback);\r

  }"
showFleetingMessage: "function showFleetingMessage(msg, dParent, styles = {}, ms
  = 3000, msDelay = 0, fade = true) {\r

  \  clearFleetingMessage();\r

  \  dFleetingMessage = mDiv(dParent);\r

  \  if (msDelay) {\r

  \    TOFleetingMessage = setTimeout(() => fleetingMessage(msg,
  dFleetingMessage, styles, ms, fade), msDelay);\r

  \  } else {\r

  \    TOFleetingMessage = setTimeout(() => fleetingMessage(msg,
  dFleetingMessage, styles, ms, fade), 10);\r

  \  }\r

  }"
shuffle: function shuffle(arr) { if (isEmpty(arr)) return []; else return
  fisherYates(arr); }
shuffle_children: "function shuffle_children(d) {\r

  \  let arr = Array.from(d.children);\r

  \  shuffle(arr);\r

  \  for (const ch of arr) { mAppend(d, ch); }\r

  }"
shuffleChildren: function shuffleChildren(dParent) { shuffle_children(dParent); }
sortBy: "function sortBy(arr, key) { arr.sort((a, b) => (a[key] < b[key] ? -1 :
  1)); return arr; }"
sortByDescending: "function sortByDescending(arr, key) { arr.sort((a, b) =>
  (a[key] > b[key] ? -1 : 1)); return arr; }"
sortByFunc: "function sortByFunc(arr, func) { arr.sort((a, b) => (func(a) <
  func(b) ? -1 : 1)); return arr; }"
sortByFuncDescending: "function sortByFuncDescending(arr, func) { arr.sort((a,
  b) => (func(a) > func(b) ? -1 : 1)); return arr; }"
sortNumbers: function sortNumbers(ilist) { ilist.sort(function (a, b) { return a
  - b }); return ilist; }
splitAtAnyOf: "function splitAtAnyOf(s, sep) {\r

  \  let arr = [], w = '';\r

  \  for (let i = 0; i < s.length; i++) {\r

  \    let ch = s[i];\r

  \    if (sep.includes(ch)) {\r

  \      if (!isEmpty(w)) arr.push(w);\r

  \      w = '';\r

  \    } else {\r

  \      w += ch;\r

  \    }\r

  \  }\r

  \  if (!isEmpty(w)) arr.push(w);\r

  \  return arr;\r

  }"
splitIntoNumbersAndWords: "function splitIntoNumbersAndWords(s) {\r

  \  let arr = [], i = 0;\r

  \  while (i < s.length) {\r

  \    let ch = s[i];\r

  \    let w = '';\r

  \    if (isDigit(ch)) while (i < s.length && isDigit(ch)) { w += ch; i++; ch
  = s[i]; }\r

  \    else if (isLetter(ch)) while (i < s.length && isLetter(ch)) { w += ch;
  i++; ch = s[i]; }\r

  \    else { i++; continue; } \r

  \    arr.push(w);\r

  \  }\r

  \  return arr;\r

  }"
start_simple_timer: "function start_simple_timer(dtimer, msInterval, onTick,
  msTotal, onElapsed) {\r

  \  if (isdef(DA.timer)) { DA.timer.clear(); DA.timer = null; }\r

  \  let timer = DA.timer = new SimpleTimer(dtimer, msInterval, onTick,
  msTotal, onElapsed);\r

  \  timer.start();\r

  }"
startsWith: "function startsWith(s, sSub) {\r

  \  return s.substring(0, sSub.length) == sSub;\r

  }"
stop_simple_timer: function stop_simple_timer() { if (isdef(DA.timer)) {
  DA.timer.clear(); DA.timer = null; } }
stringAfter: "function stringAfter(sFull, sSub) {\r

  \  let idx = sFull.indexOf(sSub);\r

  \  if (idx < 0) return '';\r

  \  return sFull.substring(idx + sSub.length);\r

  }"
stringAfterLast: "function stringAfterLast(sFull, sSub) {\r

  \  let parts = sFull.split(sSub);\r

  \  return arrLast(parts);\r

  }"
stringBefore: "function stringBefore(sFull, sSub) {\r

  \  let idx = sFull.indexOf(sSub);\r

  \  if (idx < 0) return sFull;\r

  \  return sFull.substring(0, idx);\r

  }"
stringBeforeLast: "function stringBeforeLast(sFull, sSub) {\r

  \  let parts = sFull.split(sSub);\r

  \  return sFull.substring(0, sFull.length - arrLast(parts).length - 1);\r

  }"
stringBetween: "function stringBetween(sFull, sStart, sEnd) {\r

  \  return stringBefore(stringAfter(sFull, sStart), isdef(sEnd) ? sEnd :
  sStart);\r

  }"
stringBetweenLast: "function stringBetweenLast(sFull, sStart, sEnd) {\r

  \  let s1 = stringBeforeLast(sFull, isdef(sEnd) ? sEnd : sStart);\r

  \  return stringAfterLast(s1, sStart);\r

  }"
stripToKeys: "function stripToKeys(o, di) {\r

  \  let res = {};\r

  \  for (const k in o) {\r

  \    if (isdef(di[k])) res[k] = o[k];\r

  \  }\r

  \  return res;\r

  }"
timeConversion: "function timeConversion(duration, format = 'Hmsh') {\r

  \  const portions = [];\r

  \  const msInHour = 1000 * 60 * 60;\r

  \  const hours = Math.trunc(duration / msInHour);\r

  \  if (format.includes('H')) portions.push((hours < 10 ? '0' : '') +
  hours);\r

  \  duration = duration - (hours * msInHour); \r

  \  const msInMinute = 1000 * 60;\r

  \  const minutes = Math.trunc(duration / msInMinute);\r

  \  if (format.includes('m')) portions.push((minutes < 10 ? '0' : '') +
  minutes);\r

  \  duration = duration - (minutes * msInMinute);\r

  \  const msInSecond = 1000;\r

  \  const seconds = Math.trunc(duration / 1000);\r

  \  if (format.includes('s')) portions.push((seconds < 10 ? '0' : '') +
  seconds);\r

  \  duration = duration - (seconds * msInSecond);\r

  \  const hundreds = duration / 10;\r

  \  if (format.includes('h')) portions.push((hundreds < 10 ? '0' : '') +
  hundreds);\r

  \  return portions.join(':');\r

  }"
toElem: "function toElem(d) { return isString(d) ? mBy(d) : d; }"
toggleSelection: "function toggleSelection(pic, selected, clSelected =
  'framedPicture', clUnselected = null) {\r

  \  let ui = iDiv(pic);\r

  \  pic.isSelected = !pic.isSelected;\r

  \  if (pic.isSelected) {\r

  \    if (isdef(clUnselected)) mClassRemove(ui, clUnselected);\r

  \    mClass(ui, clSelected);\r

  \  } else {\r

  \    mClassRemove(ui, clSelected);\r

  \    if (isdef(clUnselected)) mClass(ui, clUnselected);\r

  \  }\r

  \  if (isdef(selected)) {\r

  \    if (isList(selected)) {\r

  \      if (pic.isSelected) {\r

  \        console.assert(!selected.includes(pic), 'UNSELECTED PIC IN
  PICLIST!!!!!!!!!!!!')\r

  \        selected.push(pic);\r

  \      } else {\r

  \        console.assert(selected.includes(pic), 'PIC NOT IN PICLIST BUT HAS
  BEEN SELECTED!!!!!!!!!!!!')\r

  \        removeInPlace(selected, pic);\r

  \      }\r

  \    } else {\r

  \      mClassRemove(iDiv(selected), clSelected);\r

  \      if (isdef(clUnselected)) mClass(iDiv(selected), clUnselected);\r

  \      selected.isSelected = false;\r

  \    }\r

  \  }\r

  \  return pic.isSelected ? pic : null;\r

  }"
toggleSelectionOfPicture: "function toggleSelectionOfPicture(pic, selectedPics,
  className = 'framedPicture') {\r

  \  let ui = iDiv(pic);\r

  \  pic.isSelected = !pic.isSelected;\r

  \  if (pic.isSelected) mClass(ui, className); else mClassRemove(ui,
  className);\r

  \  if (isdef(selectedPics)) {\r

  \    if (pic.isSelected) {\r

  \      console.assert(!selectedPics.includes(pic), 'UNSELECTED PIC IN
  PICLIST!!!!!!!!!!!!')\r

  \      selectedPics.push(pic);\r

  \    } else {\r

  \      console.assert(selectedPics.includes(pic), 'PIC NOT IN PICLIST BUT
  HAS BEEN SELECTED!!!!!!!!!!!!')\r

  \      removeInPlace(selectedPics, pic);\r

  \    }\r

  \  }\r

  }"
toLetters: function toLetters(s) { return [...s]; }
top_elem_from_to: function top_elem_from_to(arr1, arr2) { arr2.push(arr1.shift()); }
top_elem_from_to_top: function top_elem_from_to_top(arr1, arr2) { arr2.unshift(arr1.shift()); }
toWords: "function toWords(s) {\r

  \  let arr = s.split(/(?:,|\\s|!)+/);\r

  \  return arr.filter(x => !isEmpty(x));\r

  }"
unfocusOnEnter: "function unfocusOnEnter(ev) {\r

  \  if (ev.key === 'Enter') {\r

  \    ev.preventDefault();\r

  \    mBy('dummy').focus();\r

  \  }\r

  }"
valf: "function valf(val, def) { return isdef(val) ? val : def; }"
valfi: "function valfi() {\r

  \  for (const arg of arguments) {\r

  \    if (isdef(arg)) return arg;\r

  \  }\r

  \  return null;\r

  }"
accuse_get_card: "function accuse_get_card(ckey, h, w, backcolor = BLUE, ov =
  .3) {\r

  \  if (is_color(ckey)) {\r

  \    return get_color_card(ckey,h)\r

  \  } else if (ckey.length > 3) {\r

  \    return get_number_card(ckey, h, null, backcolor, ov);\r

  \  } else {\r

  \    let info = get_c52j_info(ckey, backcolor);\r

  \    let card = cardFromInfo(info, h, w, ov);\r

  \    return card;\r

  \  }\r

  }"
accuse_get_card_func: function accuse_get_card_func(hcard = 80, backcolor =
  BLUE) { return ckey => accuse_get_card(ckey, hcard, null, backcolor); }
aggregate_player_hands_by_rank: "function aggregate_player_hands_by_rank(fen)
  {\r

  \  let di_ranks = {};\r

  \  let akku = [];\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    let hand = pl.hand;\r

  \    for (const c of hand) {\r

  \      akku.push(c);\r

  \      let r = c[0];\r

  \      if (isdef(di_ranks[r])) di_ranks[r] += 1; else di_ranks[r] = 1;\r

  \    }\r

  \  }\r

  \  fen.akku = akku;\r

  \  return di_ranks;\r

  }"
anim_face_down: function anim_face_down(item, ms = 300, callback = null) {
  face_up(item); anim_toggle_face(item, callback); }
anim_face_up: function anim_face_up(item, ms = 300, callback = null) {
  face_down(item); anim_toggle_face(item, callback); }
anim_toggle_face: "function anim_toggle_face(item, ms = 300, callback = null)
  {\r

  \  let d = iDiv(item);\r

  \  mClass(d, 'aniflip');\r

  \  TO.anim = setTimeout(() => {\r

  \    if (item.faceUp) face_down(item); else face_up(item); mClassRemove(d,
  'aniflip');\r

  \    if (isdef(callback)) callback();\r

  \  }, ms);\r

  }"
ari_get_card: "function ari_get_card(ckey, h, w, ov = .3) {\r

  \  let type = ckey[2];\r

  \  let sz = { largecard: 100, smallcard: 50 };\r

  \  let info = type == 'n' ? to_aristocard(ckey, sz.largecard) : type == 'l'
  ? to_luxurycard(ckey, sz.largecard) : type == 'r' ? to_rumorcard(ckey,
  sz.smallcard) : to_commissioncard(ckey, sz.smallcard);\r

  \  let card = cardFromInfo(info, h, w, ov);\r

  \  if (type == 'l') luxury_card_deco(card);\r

  \  else if (type == 'h') heritage_card_deco(card);\r

  \  return card;\r

  }"
ari_get_card_large: "function ari_get_card_large(ckey, h, w, ov = .2) {\r

  \  let type = ckey[2];\r

  \  let sz = { largecard: 120, smallcard: 80 };\r

  \  let info = type == 'n' ? to_aristocard(ckey, sz.largecard) : type == 'l'
  ? to_luxurycard(ckey, sz.largecard) : type == 'r' ? to_rumorcard(ckey,
  sz.smallcard) : to_commissioncard(ckey, sz.smallcard);\r

  \  let card = cardFromInfo(info, h, w, ov);\r

  \  if (type == 'l') luxury_card_deco(card);\r

  \  return card;\r

  }"
calc_hand_value: "function calc_hand_value(hand, card_func = ferro_get_card) {\r

  \  let vals = hand.map(x => card_func(x).val);\r

  \  let sum = vals.reduce((a, b) => a + b, 0);\r

  \  return sum;\r

  }"
cardFromInfo: "function cardFromInfo(info, h, w, ov) {\r

  \  let svgCode = C52[info.c52key];\r

  \  let ckey = info.key;\r

  \  if (info.rank == '*') {\r

  \    let color = get_color_of_card(ckey);\r

  \    if (color != 'red') svgCode = colored_jolly(color);\r

  \  }\r

  \  svgCode = '<div>' + svgCode + '</div>';\r

  \  let el = mCreateFrom(svgCode);\r

  \  h = valf(h, valf(info.h, 100));\r

  \  w = valf(w, h * .7);\r

  \  mSize(el, w, h);\r

  \  let res = {};\r

  \  copyKeys(info, res);\r

  \  copyKeys({ w: w, h: h, faceUp: true, div: el }, res);\r

  \  if (isdef(ov)) res.ov = ov;\r

  \  return res;\r

  }"
colored_jolly: "function colored_jolly(color) {\r

  \  let id = `J_${color}`;\r

  \  let svg = `\r

  \    <svg xmlns=\"http://www.w3.org/2000/svg\"
  xmlns:xlink=\"http://www.w3.org/1999/xlink\" class=\"card\" face=\"1J\" \r

  \    height=\"100%\" preserveAspectRatio=\"none\" viewBox=\"-120 -168 240
  336\" width=\"100%\">\r

  \    <symbol id=\"J11\" preserveAspectRatio=\"none\" viewBox=\"0 0 1300
  2000\">\r

  \    <path fill=\"#FC4\" d=\"M1095,1000A445,445 0 0 1 650,1445 445,445 0 0 1
  205,1000 445,445 0 0 1 650,555 445,445 0 0 1 1095,1000Z\"></path>\r

  \    </symbol>\r

  \    <symbol id=\"${id}\" preserveAspectRatio=\"none\" viewBox=\"0 0 1300
  2000\">\r

  \    <path fill=\"${color}\" d=\"M317.05664,1294.416 100,1620l220,-60 40,240
  140,-200 160,200 40,-200 180,180 60,-220 260,60 -236.67969,-304.3027A445,445 0
  0 1 650,1445 445,445 0 0 1
  317.05664,1294.416ZM831.71484,249.10742C687.94378,262.65874 542.4812,256.33752
  420,520 369.08062,331.38331 278.61481,370.61289 187.77148,412.01367a75,75 0 0
  1 2.52344,19.12695 75,75 0 0 1 -16.78515,47.19532c66.827,55.25537
  117.57478,127.8247 155.77539,213.90429A445,445 0 0 1 650,555 445,445 0 0 1
  924.33984,650.26562c42.39917,-50.4556 91.60026,-93.34711
  167.51176,-106.5332a75,75 0 0 1 -0.6524,-9.14258 75,75 0 0 1
  14.6172,-44.3457C1026.3517,437.47479 931.12146,446.83238 840,440
  761.98041,388.07638 804.10248,338.17898 853.51758,288.4043a75,75 0 0 1
  -21.80274,-39.29688z\"></path>\r

  \    </symbol>\r

  \    <symbol id=\"J13\" preserveAspectRatio=\"none\" viewBox=\"0 0 1300
  2000\">\r

  \    <path fill=\"#44F\" d=\"M879.65521,937.6026a40,40 0 0 1 -40,40 40,40 0
  0 1 -40,-40 40,40 0 0 1 40,-40 40,40 0 0 1 40,40zm-379.31039,0a40,40 0 0 1
  -40,40 40,40 0 0 1 -40,-40 40,40 0 0 1 40,-40 40,40 0 0 1 40,40z\"></path>\r

  \    </symbol>\r

  \    <symbol id=\"J14\" preserveAspectRatio=\"none\" viewBox=\"0 0 1300
  2000\">\r

  \    <path stroke=\"#44F\" stroke-linecap=\"round\"
  stroke-linejoin=\"round\" stroke-width=\"6\" fill=\"none\"
  d=\"M317.05664,1294.416 100,1620l220,-60 40,240 140,-200 160,200 40,-200
  180,180 60,-220 260,60 -236.67969,-304.3027M1241.1987,534.58948a75,75 0 0 1
  -75,75 75,75 0 0 1 -75,-75 75,75 0 0 1 75,-75 75,75 0 0 1
  75,75zM980.11493,234.09686a75,75 0 0 1 -75,75 75,75 0 0 1 -75,-75 75,75 0 0 1
  75,-75 75,75 0 0 1 75,75zM190.29556,431.1412a75,75 0 0 1 -75,75 75,75 0 0 1
  -74.999997,-75 75,75 0 0 1 74.999997,-75 75,75 0 0 1
  75,75zM924.3457,650.27148c42.40088,-50.45397 91.5936,-93.35356
  167.5059,-106.53906 -0.4037,-3.03138 -0.6215,-6.0846 -0.6524,-9.14258
  0.03,-15.96068 5.1503,-31.4957 14.6172,-44.3457C1026.3517,437.47479
  931.12146,446.83238 840,440 761.98041,388.07638 804.10248,338.17898
  853.51758,288.4043 842.40414,277.84182 834.79487,264.12701 831.71484,249.10742
  687.94378,262.65874 542.4812,256.33752 420,520 369.08062,331.38331
  278.61481,370.61289 187.77148,412.01367c1.66108,6.24042 2.50924,12.66925
  2.52344,19.12695 -0.0209,17.1896 -5.94587,33.85038 -16.7832,47.19336
  66.82714,55.25532 117.5686,127.8306
  155.76953,213.91016M384.88867,1140c51.89013,98.343 153.91815,159.9189
  265.11133,160 111.19809,-0.076 213.23257,-61.6527
  265.125,-160M1095,1000A445,445 0 0 1 650,1445 445,445 0 0 1 205,1000 445,445 0
  0 1 650,555 445,445 0 0 1 1095,1000Z\"></path>\r

  \    </symbol>\r

  \    <rect width=\"239\" height=\"335\" x=\"-119.5\" y=\"-167.5\" rx=\"12\"
  ry=\"12\" fill=\"white\" stroke=\"black\"></rect>\r

  \    <text x=\"-110\" y=\"-115\" fill=\"${color}\" stroke=\"${color}\"
  style=\"font:bold 60px sans-serif\">*</text>\r

  \    <use width=\"202.8\" height=\"312\" x=\"-101.4\" y=\"-156\"
  xlink:href=\"#J11\"></use>\r

  \    <use width=\"202.8\" height=\"312\" x=\"-101.4\" y=\"-156\"
  xlink:href=\"#${id}\"></use>\r

  \    <use width=\"202.8\" height=\"312\" x=\"-101.4\" y=\"-156\"
  xlink:href=\"#J13\"></use>\r

  \    <use width=\"202.8\" height=\"312\" x=\"-101.4\" y=\"-156\"
  xlink:href=\"#J14\"></use>\r

  \    </svg>\r

  \  `;\r

  \  return svg;\r

  }"
correct_handsorting: "function correct_handsorting(hand, plname) {\r

  \  let pl = Z.fen.players[plname];\r

  \  let [cs, pls, locs] = [Clientdata.handsorting, pl.handsorting,
  localStorage.getItem('handsorting')];\r

  \  let s = cs ?? pls ?? locs ?? Config.games[Z.game].defaulthandsorting;\r

  \  hand = sort_cards(hand, s == 'suit', 'CDSH', true, Z.func.rankstr);\r

  \  return hand;\r

  }"
create_card_assets_c52: "function create_card_assets_c52() {\r

  \  let ranknames = { A: 'Ace', K: 'King', T: '10', J: 'Jack', Q: 'Queen'
  };\r

  \  let suitnames = { S: 'Spades', H: 'Hearts', C: 'Clubs', D: 'Diamonds'
  };\r

  \  let rankstr = '23456789TJQKA';\r

  \  let suitstr = 'SHDC';\r

  \  sz = 100;\r

  \  let di = {};\r

  \  for (const r of toLetters(rankstr)) {\r

  \    for (const s of toLetters(suitstr)) {\r

  \      let k = r + s;\r

  \      let info = di[k] = { key: k, val: 1, irank: rankstr.indexOf(r),
  isuit: suitstr.indexOf(s), rank: r, suit: s, color: RED, c52key: 'card_' + r +
  s, w: sz * .7, h: sz, sz: sz, ov: .25, friendly: `${isNumber(r) ? r :
  ranknames[r]} of ${suitnames[s]}`, short: `${r}${s}` };\r

  \      info.isort = info.isuit * 13 + info.irank;\r

  \    }\r

  \  }\r

  \  C52Cards = di;\r

  \  return di;\r

  }"
create_fen_deck: "function create_fen_deck(cardtype, num_decks = 1, num_jokers =
  0) {\r

  \  let arr = get_keys(C52Cards).map(x => x + cardtype);\r

  \  let newarr = [];\r

  \  while (num_decks > 0) { newarr = newarr.concat(arr); num_decks--; }\r

  \  while (num_jokers > 0) { newarr.push('*H' + cardtype); num_jokers--; }\r

  \  return newarr;\r

  }"
face_down: "function face_down(item, color, texture) {\r

  \  if (!item.faceUp) return;\r

  \  if (isdef(texture) || lookup(item, ['live', 'dCover'])) {\r

  \    face_down_alt(item, color, texture);\r

  \  } else {\r

  \    let svgCode = C52.card_2B; \r

  \    item.div.innerHTML = svgCode;\r

  \    if (nundef(color)) color = item.color;\r

  \    if (isdef(item.color))
  item.div.children[0].children[1].setAttribute('fill', item.color);\r

  \  }\r

  \  item.faceUp = false;\r

  }"
face_down_alt: "function face_down_alt(item, bg, texture_name) {\r

  \  let dCover = item.live.dCover;\r

  \  if (nundef(dCover)) {\r

  \    let d = iDiv(item);\r

  \    dCover = item.live.dCover = mDiv(d, { background: bg, rounding:
  mGetStyle(d, 'rounding'), position: 'absolute', width: '100%', height: '100%',
  left: 0, top: 0 });\r

  \    let t = get_texture(texture_name);\r

  \    dCover.style.backgroundImage = t;\r

  \    dCover.style.backgroundRepeat = 'repeat';\r

  \  } else mStyle(dCover, { display: 'block' });\r

  }"
face_up: "function face_up(item) {\r

  \  if (item.faceUp) return;\r

  \  if (lookup(item, ['live', 'dCover'])) mStyle(item.live.dCover, { display:
  'none' });\r

  \  else item.div.innerHTML = isdef(item.c52key) ? C52[item.c52key] :
  item.html;\r

  \  item.faceUp = true;\r

  }"
ferro_get_card: "function ferro_get_card(ckey, h, w, ov = .25) {\r

  \  let type = ckey[2];\r

  \  let info = ckey[0] == '*' ? get_joker_info() :
  jsCopy(C52Cards[ckey.substring(0, 2)]);\r

  \  info.key = ckey;\r

  \  info.cardtype = ckey[2]; \r

  \  let [r, s] = [info.rank, info.suit];\r

  \  info.val = r == '*' ? 50 : r == 'A' ? 20 : 'TJQK'.includes(r) ? 10 :
  Number(r);\r

  \  info.color = RED;\r

  \  info.sz = info.h = valf(h, Config.ui.card.h);\r

  \  info.w = valf(w, info.sz * .7);\r

  \  info.irank = '23456789TJQKA*'.indexOf(r);\r

  \  info.isuit = 'SHCDJ'.indexOf(s);\r

  \  info.isort = info.isuit * 14 + info.irank;\r

  \  let card = cardFromInfo(info, h, w, ov);\r

  \  return card;\r

  }"
find_index_of_jolly: function find_index_of_jolly(j) { return j.findIndex(x => is_jolly(x)); }
find_jolly_rank: "function find_jolly_rank(j, rankstr = 'A23456789TJQKA') {\r

  \  let jolly_idx = find_index_of_jolly(j);\r

  \  if (jolly_idx == -1) return false;\r

  \  if (jolly_idx > 0) {\r

  \    let rank_before_index = j[jolly_idx - 1][0];\r

  \    let rank_needed = rankstr[rankstr.indexOf(rank_before_index) + 1];\r

  \    return rank_needed;\r

  \  } else {\r

  \    let rank_after_index = j[jolly_idx + 1][0];\r

  \    let rank_needed = rank_after_index == 'A' ? 'K' :
  rankstr[rankstr.indexOf(rank_after_index) - 1];\r

  \    return rank_needed;\r

  \  }\r

  }"
get_c52j_info: "function get_c52j_info(ckey, backcolor = BLUE) {\r

  \  let info;\r

  \  if (ckey[0] == '*') {\r

  \    info = {\r

  \      c52key: `card_0J`, //'card_1J', //`card_${1+n%2}`,\r

  \      color: \"#e6194B\",\r

  \      friendly: \"Joker\",\r

  \      key: ckey,\r

  \      h: 100,\r

  \      ov: 0.25,\r

  \      rank: \"*\",\r

  \      short: \"J\",\r

  \      suit: ckey[1],\r

  \      sz: 100,\r

  \      val: 0,\r

  \      w: 70,\r

  \    };\r

  \  } else {\r

  \    info = jsCopy(C52Cards[ckey.substring(0, 2)]);\r

  \  }\r

  \  info.key = ckey;\r

  \  info.cardtype = ckey[2];\r

  \  let [r, s] = [info.rank, info.suit];\r

  \  info.val = r == '*' ? 0 : r == 'A' ? 1 : 'TJQK'.includes(r) ? 10 :
  Number(r);\r

  \  info.color = backcolor;\r

  \  info.sz = info.h = sz;\r

  \  info.w = valf(w, sz * .7);\r

  \  let ranks = valf(lookup(Z, ['fen', 'ranks']), '*A23456789TJQK'); \r

  \  info.irank = ranks.indexOf(r);\r

  \  info.isuit = 'SHCD'.indexOf(s);\r

  \  info.isort = info.isuit * ranks.length + info.irank;\r

  \  return info;\r

  }"
get_color_of_card: "function get_color_of_card(ckey) { return is_color(ckey) ?
  ckey : ckey.length == 3 ? ['H', 'D'].includes(ckey[1]) ? 'red' : 'black' :
  stringAfter(ckey, '_'); }"
get_container_styles: function get_container_styles(styles = {}) { let defaults
  = valf(Config.ui.container, {}); defaults.position = 'relative';
  addKeys(defaults, styles); return styles; }
get_containertitle_styles: function get_containertitle_styles(styles = {}) { let
  defaults = valf(Config.ui.containertitle, {}); defaults.position = 'absolute';
  addKeys(defaults, styles); return styles; }
get_group_rank: function get_group_rank(j) { let non_jolly_key = firstCond(j, x
  => !is_jolly(x)); return non_jolly_key[0]; }
get_joker_info: "function get_joker_info() {\r

  \  return {\r

  \    c52key: `card_0J`, //'card_1J', //`card_${1+n%2}`,\r

  \    color: \"#e6194B\",\r

  \    friendly: \"Joker\",\r

  \    key: '*Hn',\r

  \    h: 100,\r

  \    irank: 14,\r

  \    isort: 100,\r

  \    isuit: 3,\r

  \    ov: 0.25,\r

  \    rank: \"*\",\r

  \    short: \"J\",\r

  \    suit: \"H\",\r

  \    sz: 100,\r

  \    val: 1,\r

  \    w: 70,\r

  \  };\r

  }"
get_sequence_suit: function get_sequence_suit(j) { let non_jolly_key =
  firstCond(j, x => !is_jolly(x)); return non_jolly_key[1]; }
has_at_most_n_jolly: function has_at_most_n_jolly(j, n = 1) { return j.filter(x
  => is_jolly(x)).length <= n; }
has_jolly: function has_jolly(j) { return firstCond(j, x => is_jolly(x)); }
heritage_card_deco: "function heritage_card_deco(card) {\r

  \  let d = iDiv(card); mStyle(d, { position: 'relative' });\r

  \  let d1 = mDiv(d, { fg: 'silver', fz: 11, family: 'tangerine', position:
  'absolute', right: '36%', top: 1 }, null, 'heritage');\r

  }"
is_card_key: "function is_card_key(ckey, rankstr = '*A23456789TJQK', suitstr =
  'SHCD') {\r

  \  return is_nc_card(ckey) || is_color(ckey) || rankstr.includes(ckey[0]) &&
  suitstr.includes(ckey[1]);\r

  }"
is_joker: function is_joker(card) { return is_jolly(card.key); }
is_jolly: function is_jolly(ckey) { return ckey[0] == '*'; }
is_overlapping_set: "function is_overlapping_set(cards, max_jollies_allowed = 1,
  seqlen = 7, group_same_suit_allowed = true) {\r

  \  let istart = 0;\r

  \  let inextstart = 0;\r

  \  let lmin = 3;\r

  \  let legal = true;\r

  \  if (cards.length < lmin) return false;\r

  \  while (legal && istart <= cards.length - lmin) {\r

  \    let cl = cards.slice(istart, istart + lmin);\r

  \    let set = ferro_is_set(cl, max_jollies_allowed, seqlen,
  group_same_suit_allowed);\r

  \    if (set) { istart++; inextstart = Math.min(istart + lmin, cards.length
  - 3); }\r

  \    else if (!set && inextstart == istart) return false;\r

  \    else istart++;\r

  \  }\r

  \  return cards.map(x => x.key);\r

  }"
jolly_matches: "function jolly_matches(key, j, rankstr = 'A23456789TJQKA') {\r

  \  let jolly_idx = find_index_of_jolly(j);\r

  \  if (jolly_idx == -1) return false;\r

  \  if (is_group(j)) {\r

  \    let r = get_group_rank(j);\r

  \    if (key[0] == r) return true;\r

  \  } else if (jolly_idx > 0) {\r

  \    let rank_before_index = j[jolly_idx - 1][0];\r

  \    let suit_needed = j[jolly_idx - 1][1];\r

  \    let rank_needed = rankstr[rankstr.indexOf(rank_before_index) + 1];\r

  \    if (key[0] == rank_needed && key[1] == suit_needed) return true;\r

  \  } else {\r

  \    let rank_after_index = j[jolly_idx + 1][0];\r

  \    let suit_needed = j[jolly_idx + 1][1];\r

  \    let rank_needed = rank_after_index == 'A' ? 'K' :
  rankstr[rankstr.indexOf(rank_after_index) - 1];\r

  \    if (key[0] == rank_needed && key[1] == suit_needed) return true;\r

  \  }\r

  \  return false;\r

  }"
luxury_card_deco: "function luxury_card_deco(card) {\r

  \  let d = iDiv(card); mStyle(d, { position: 'relative' });\r

  \  let d1 = mDiv(d, { fg: 'dimgray', fz: 11, family: 'tangerine', position:
  'absolute', left: 0, top: 0, 'writing-mode': 'vertical-rl', transform:
  'scale(-1)', top: '35%' }, null, 'Luxury');\r

  \  let html = `<img height=${18}
  src=\"../base/assets/images/icons/deco0.svg\"
  style=\"transform:scaleX(-1);\">`;\r

  \  d1 = mDiv(d, { position: 'absolute', bottom: -2, left: 3, opacity: .25 },
  null, html);\r

  }"
pop_top: "function pop_top(o) {\r

  \  if (isEmpty(o.list)) return null;\r

  \  let t = o.get_topcard();  \r

  \  o.list.shift();\r

  \  o.renew(o.list, o.cardcontainer, o.items, o.get_card_func);\r

  \  return t;\r

  }"
remove_card_shadow: function remove_card_shadow(c) {
  iDiv(c).firstChild.setAttribute('class', null); }
replace_jolly: "function replace_jolly(key, j) {\r

  \  let jolly_idx = find_index_of_jolly(j);\r

  \  j[jolly_idx] = key;\r

  }"
set_card_border: "function set_card_border(item, thickness = 1, color = 'black',
  dasharray) {\r

  \  let d = iDiv(item);\r

  \  let rect = lastDescendantOfType('rect', d);\r

  \  if (rect) {\r

  \    rect.setAttribute('stroke-width', thickness);\r

  \    rect.setAttribute('stroke', color);\r

  \    if (isdef(dasharray)) rect.setAttribute('stroke-dasharray',
  dasharray);\r

  \  } else {\r

  \    mStyle(d, { border: `solid ${1}px ${color}` })\r

  \  }\r

  }"
set_card_style: "function set_card_style(item, styles = {}, className) {\r

  \  console.log('set_card_style', item, styles);\r

  \  let d = iDiv(item);\r

  \  let svg = findDescendantOfType('svg', d);\r

  \  let rect = findDescendantOfType('rect', svg);\r

  \  if (isdef(styles.shadow)) {\r

  \    let shadow = styles.shadow;\r

  \    delete styles.shadow;\r

  \    let hexcolor = colorFrom(styles.shadow);\r

  \    svg.style.filter = `drop-shadow(4px 5px 2px ${hexcolor})`;\r

  \  }\r

  \  if (isdef(styles.bg)) {\r

  \    let hexcolor = colorFrom(styles.bg);\r

  \    rect.setAttribute('stroke-width', 14); rect.setAttribute('stroke',
  hexcolor);\r

  \  }\r

  \  assertion(rect, 'NO RECT FOUND IN ELEM', d);\r

  \  mStyle(d, styles);\r

  \  if (isdef(className)) mClass(svg, className);\r

  }"
set_card_style_works: "function set_card_style_works(c, styles, className) {\r

  \  let d = iDiv(c);\r

  \  mStyle(d, styles);\r

  \  d.firstChild.setAttribute('class', className);\r

  }"
sheriff_card: "function sheriff_card(name, color) {\r

  \  let di = SHERIFF.cards;\r

  \  let info = valf(di[name], { ksym: 'crossbow', kcenter: 'green apple',
  label: 'crossbow', type: 'contraband', value: 9, penalty: 4 });\r

  \  let bcolor = SHERIFF.color[info.type]; \r

  \  let c = cPortrait(null, { margin: 12, border: `solid 4px ${bcolor}`, bg:
  valf(color, colorLight('gold', 60)) });\r

  \  let d = iDiv(c);\r

  \  let ds = mSym(info.ksym, d, { sz: 30 }, 'tl');\r

  \  ds = mSymText(info.value, d, { sz: 25, rounding: '50%', bg: 'gold',
  margin: 3 }, 'tr');\r

  \  ds = mText(info.label.toUpperCase(), d, { family: 'Algerian', w: '100%',
  fz: 12, align: 'center', position: 'absolute', bottom: 0 });\r

  \  ds = mText(info.label.toUpperCase(), d, { family: 'Algerian', w: '100%',
  fz: 12, align: 'center', position: 'absolute', top: 0 });\r

  \  ds = mSymText(info.penalty, d, { sz: 25, rounding: '50%', bg: 'crimson',
  margin: 3 }, 'br');\r

  \  ds = mSym(info.kcenter, d, { sz: 70 }, 'cc'); mPos(ds, 'calc( 50% - 35px
  )', 'calc( 50% - 35px )');\r

  \  return c;\r

  }"
sort_cards: "function sort_cards(hand, bySuit = true, suits = 'CDHS', byRank =
  true, rankstr = '23456789TJQKA') {\r

  \  if (bySuit && byRank) {\r

  \    let buckets = arrBuckets(hand, x => x[1], suits);\r

  \    for (const b of buckets) { sort_cards(b.list, false, null, true,
  rankstr); } \r

  \    hand.length = 0; buckets.map(x => x.list.map(y => hand.push(y))); \r

  \  } else if (bySuit) hand.sort((a, b) => suits.indexOf(a[1]) -
  suits.indexOf(b[1])); \r

  \  else if (byRank) hand.sort((a, b) => rankstr.indexOf(a[0]) -
  rankstr.indexOf(b[0]));\r

  \  return hand;\r

  }"
sortByRank: "function sortByRank(ckeys, rankstr = '23456789TJQKA') {\r

  \  let ranks = toLetters(rankstr);\r

  \  ckeys.sort((a, b) => ranks.indexOf(a[0]) - ranks.indexOf(b[0]));\r

  \  return ckeys;\r

  }"
sortCardItemsByRank: "function sortCardItemsByRank(items, rankstr =
  '23456789TJQKA') {\r

  \  let ranks = toLetters(rankstr);\r

  \  items.sort((a, b) => ranks.indexOf(a.key[0]) -
  ranks.indexOf(b.key[0]));\r

  \  return items;\r

  }"
sortCardItemsBySuit: "function sortCardItemsBySuit(items, suitstr = 'CDSH') {\r

  \  let ranks = toLetters(suitstr);\r

  \  items.sort((a, b) => ranks.indexOf(a.key[1]) -
  ranks.indexOf(b.key[1]));\r

  \  return items;\r

  }"
sortCardItemsToSequence: "function sortCardItemsToSequence(items, rankstr =
  '23456789TJQKA', jolly_allowed = 1) {\r

  \  let ranks = toLetters(rankstr);\r

  \  let n = items.length;\r

  \  let jollies = items.filter(x => is_joker(x));\r

  \  if (jollies.length > jolly_allowed) { return null; } \r

  \  let no_jolly = items.filter(x => !is_joker(x));\r

  \  let sorted = sortCardItemsByRank(no_jolly, rankstr);\r

  \  let partial_sequences = [], seq = [sorted[0]], first, second;\r

  \  for (let i = 0; i < sorted.length - 1; i++) {\r

  \    first = sorted[i];\r

  \    second = sorted[i + 1];\r

  \    diff = second.irank - first.irank;\r

  \    if (diff == 1) { seq.push(second); }\r

  \    else {\r

  \      partial_sequences.push({ seq: seq, len: seq.length, diff_to_next:
  diff });\r

  \      seq = [second];\r

  \    }\r

  \  }\r

  \  diff = sorted[0].irank - (sorted[sorted.length - 1].irank -
  rankstr.length)\r

  \  if (!isEmpty(seq)) {\r

  \    partial_sequences.push({ seq: seq, len: seq.length, diff_to_next: diff
  });\r

  \  } else {\r

  \    arrLast(partial_sequences).diff_to_next = diff;\r

  \  }\r

  \  let i_max_diff = partial_sequences.findIndex(x => x.diff_to_next ==
  Math.max(...partial_sequences.map(x => x.diff_to_next)));\r

  \  let max_diff = partial_sequences[i_max_diff].diff_to_next;\r

  \  let istart = (i_max_diff + 1) % partial_sequences.length;\r

  \  let final_sequence = [];\r

  \  let jollies_needed = 0;\r

  \  let len = partial_sequences.length;\r

  \  let ij = 0;\r

  \  for (let i = 0; i < len; i++) {\r

  \    let index = (i + istart) % len;\r

  \    let list = partial_sequences[index].seq;\r

  \    final_sequence = final_sequence.concat(list);\r

  \    let nj = partial_sequences[index].diff_to_next - 1;\r

  \    if (i < len - 1) {\r

  \      for (let j = 0; j < nj; j++) { final_sequence.push(jollies[ij++]);
  }\r

  \      jollies_needed += nj;\r

  \    }\r

  \  }\r

  \  for (let i = 0; i < final_sequence.length; i++) { items[i] =
  final_sequence[i]; }\r

  \  return jollies_needed;\r

  }"
spread_hand: "function spread_hand(path, ov) {\r

  \  let hand = lookup(UI, path.split('.'));\r

  \  assertion(hand, 'hand does NOT exist', path);\r

  \  if (hand.ctype != 'hand') return;\r

  \  if (isEmpty(hand.items)) return;\r

  \  let card = hand.items[0];\r

  \  if (nundef(ov)) ov = card.ov;\r

  \  if (hand.ov == ov) return;\r

  \  hand.ov = ov;\r

  \  let cont = hand.cardcontainer;\r

  \  let items = hand.items;\r

  \  mContainerSplay(cont, hand.splay, card.w, card.h, items.length, ov *
  card.w);\r

  }"
symbolcolor: "function symbolcolor(card, color) {\r

  \  let d = iDiv(card);\r

  \  let els = d.getElementsByTagName('symbol'); \r

  \  console.log('list', els)\r

  \  for (const el of els) {\r

  \    let html = el.innerHTML;\r

  \    let html1 = replaceAll(html, 'red', color);\r

  \    let html2 = replaceAll(html1, 'black', color);\r

  \    el.innerHTML = html2;\r

  \  }\r

  }"
to_aristocard: "function to_aristocard(ckey, sz = 100, color = RED, w) {\r

  \  let info = jsCopy(C52Cards[ckey.substring(0, 2)]);\r

  \  info.key = ckey;\r

  \  info.cardtype = ckey[2];\r

  \  let [r, s] = [info.rank, info.suit];\r

  \  info.val = r == 'A' ? 1 : 'TJQK'.includes(r) ? 10 : Number(r);\r

  \  info.color = color;\r

  \  info.sz = info.h = sz;\r

  \  info.w = valf(w, sz * .7);\r

  \  info.irank = 'A23456789TJQK'.indexOf(r);\r

  \  info.isuit = 'SHCD'.indexOf(s);\r

  \  info.isort = info.isuit * 13 + info.irank;\r

  \  return info;\r

  }"
to_commissioncard: function to_commissioncard(ckey, sz = 40, color = GREEN, w) {
  return to_aristocard(ckey, sz, color); }
to_luxurycard: function to_luxurycard(ckey, sz = 100, color = 'gold', w) {
  return to_aristocard(ckey, sz, color); }
to_rumorcard: function to_rumorcard(ckey, sz = 40, color = GREEN, w) { return
  to_aristocard(ckey, sz, color); }
toggle_face: function toggle_face(item) { if (item.faceUp) face_down(item); else
  face_up(item); }
ui_add_cards_to_deck_container: "function ui_add_cards_to_deck_container(cont,
  items, list) {\r

  \  if (nundef(list)) list = items.map(x => x.key);\r

  \  for (const item of items) {\r

  \    mAppend(cont, iDiv(item));\r

  \    mItemSplay(item, list, 4, Card.ovdeck);\r

  \    face_down(item);\r

  \  }\r

  \  return items[0];\r

  }"
ui_add_cards_to_hand_container: "function ui_add_cards_to_hand_container(cont,
  items, list) {\r

  \  if (nundef(list)) list = items.map(x => x.key);\r

  \  for (const item of items) {\r

  \    mAppend(cont, iDiv(item));\r

  \    mItemSplay(item, list, 2, Card.ovw);\r

  \  }\r

  }"
ui_add_container_title: "function ui_add_container_title(title, cont, items,
  show_if_empty) {\r

  \  if (isdef(title) && (!isEmpty(items) || show_if_empty)) {\r

  \    let st = get_containertitle_styles();\r

  \    let stmeasure = jsCopy(st); delete stmeasure.position;\r

  \    let elem = mText(title, cont, stmeasure);\r

  \    let sz = getSizeNeeded(elem);\r

  \    let offsetx = valf(st.left, 0);\r

  \    let cont_wmin = mGetStyle(cont, 'wmin');\r

  \    let my_min = sz.w + offsetx * 1.5;\r

  \    let wmin = !isNumber(cont_wmin) ? my_min : Math.max(valf(cont_wmin, 0),
  my_min);\r

  \    mStyle(cont, { wmin: wmin });\r

  \    mStyle(elem, st);\r

  \  }\r

  }"
ui_make_container: "function ui_make_container(dParent, styles = { bg: 'random',
  padding: 10 }) {\r

  \  let id = getUID('u');\r

  \  let d = mDiv(dParent, styles, id);\r

  \  return d;\r

  }"
ui_make_deck_container: "function ui_make_deck_container(list, dParent, styles =
  { bg: 'random', padding: 10 }, get_card_func) {\r

  \  let id = getUID('u'); \r

  \  let d = mDiv(dParent, styles, id);\r

  \  if (isEmpty(list)) return d;\r

  \  let c = get_card_func(list[0]);\r

  \  mContainerSplay(d, 4, c.w, c.h, n, 0);\r

  \  return d;\r

  }"
ui_make_hand_container: "function ui_make_hand_container(items, dParent, styles
  = { bg: 'random', padding: 10 }) {\r

  \  let id = getUID('u');\r

  \  let d = mDiv(dParent, styles, id);\r

  \  if (!isEmpty(items)) {\r

  \    let card = items[0];\r

  \    mContainerSplay(d, 2, card.w, card.h, items.length, card.ov *
  card.w);\r

  \  }\r

  \  return d;\r

  }"
ui_type_building: "function ui_type_building(b, dParent, styles = {}, path =
  'farm', title = '', get_card_func = ari_get_card, separate_lead = false,
  ishidden = false) {\r

  \  let cont = ui_make_container(dParent, get_container_styles(styles));\r

  \  let cardcont = mDiv(cont);\r

  \  let list = b.list;\r

  \  let d = mDiv(dParent);\r

  \  let items = list.map(x => get_card_func(x));\r

  \  reindex_items(items);\r

  \  let d_harvest = null;\r

  \  if (isdef(b.h)) {\r

  \    let keycard = items[0];\r

  \    let d = iDiv(keycard);\r

  \    mStyle(d, { position: 'relative' });\r

  \    d_harvest = mDiv(d, { position: 'absolute', w: 20, h: 20, bg: 'orange',
  opacity: .5, fg: 'black', top: '45%', left: -10, rounding: '50%', align:
  'center' }, null, 'H');\r

  \  }\r

  \  let d_rumors = null, rumorItems = [];\r

  \  if (!isEmpty(b.rumors)) {\r

  \    let d = cont;\r

  \    mStyle(d, { position: 'relative' });\r

  \    d_rumors = mDiv(d, { display: 'flex', gap: 2, position: 'absolute', h:
  30, bottom: 0, right: 0 }); \r

  \    for (const rumor of b.rumors) {\r

  \      let dr = mDiv(d_rumors, { h: 24, w: 16, vmargin: 3, align: 'center',
  bg: 'dimgray', rounding: 2 }, null, 'R');\r

  \      rumorItems.push({ div: dr, key: rumor });\r

  \    }\r

  \  }\r

  \  let card = isEmpty(items) ? { w: 1, h: 100, ov: 0 } : items[0];\r

  \  let [ov, splay] = separate_lead ? [card.ov * 1.5, 5] : [card.ov, 2];\r

  \  mContainerSplay(cardcont, 5, card.w, card.h, items.length, card.ov * 1.5
  * card.w);\r

  \  ui_add_cards_to_hand_container(cardcont, items, list);\r

  \  ui_add_container_title(title, cont, items);\r

  \  let uischweine = [];\r

  \  for (let i = 1; i < items.length; i++) {\r

  \    let item = items[i];\r

  \    if (!b.schweine.includes(i)) face_down(item); else add_ui_schwein(item,
  uischweine);\r

  \  }\r

  \  return {\r

  \    ctype: 'hand',\r

  \    list: list,\r

  \    path: path,\r

  \    container: cont,\r

  \    cardcontainer: cardcont,\r

  \    items: items,\r

  \    schweine: uischweine,\r

  \    harvest: d_harvest,\r

  \    rumors: rumorItems,\r

  \    keycard: items[0],\r

  \  };\r

  }"
ui_type_church: "function ui_type_church(list, dParent, styles = {}, path =
  'trick', title = '', get_card_func = ari_get_card, show_if_empty = false) {\r

  \  let cont = ui_make_container(dParent, get_container_styles(styles));\r

  \  let cardcont = mDiv(cont, { display: 'flex' });\r

  \  let items = [];\r

  \  let n = Z.plorder.length;\r

  \  let inc = 90;\r

  \  let rotation = n % 2 ? 0 : 90;\r

  \  for (const ckey of list) {\r

  \    let d = mDiv(cardcont, { origin: 'center', transform: `rotate(
  ${rotation}deg )`, position: 'absolute', left: 8 });\r

  \    let c = get_card_func(ckey);\r

  \    if (ckey != arrLast(list)) face_down(c);\r

  \    mAppend(d, iDiv(c));\r

  \    remove_card_shadow(c);\r

  \    let item = { card: c, div: d };\r

  \    items.push(item);\r

  \    rotation += inc;\r

  \  }\r

  \  ui_add_container_title(title, cont, items, show_if_empty);\r

  \  return {\r

  \    list: list,\r

  \    path: path,\r

  \    container: cont,\r

  \    cardcontainer: cardcont,\r

  \    items: items,\r

  \  }\r

  }"
ui_type_deck: "function ui_type_deck(list, dParent, styles = {}, path = 'deck',
  title = 'deck', get_card_func = ari_get_card, show_if_empty = false) {\r

  \  let cont = ui_make_container(dParent, get_container_styles(styles));\r

  \  let cardcont = mDiv(cont);\r

  \  let items = [];\r

  \  ensure_ui(list, cardcont, items, get_card_func);\r

  \  ui_add_container_title(title, cont, items, show_if_empty);\r

  \  function get_topcard() { return isEmpty(list) ? null : items[0]; }\r

  \  function get_bottomcard() { return isEmpty(list) ? null : arrLast(items);
  }\r

  \  function ensure_ui(list, cardcont, items, get_card_func) {\r

  \    clearElement(cardcont); arrClear(items); if (isEmpty(list)) return;\r

  \    let n = Math.min(2, list.length); let ct = get_card_func(list[0]);
  items.push(ct); if (n > 1) { let cb = get_card_func(arrLast(list));
  items.push(cb); }\r

  \    mStyle(cardcont, { position: 'relative', wmin: ct.w + 8, hmin: ct.h
  });\r

  \    for (let i = items.length - 1; i >= 0; i--) { let x = items[i];
  face_down(x); mAppend(cardcont, iDiv(x)); mStyle(iDiv(x), { position:
  'absolute', top: 0, left: 0 }) }\r

  \    mText(list.length, iDiv(ct), { position: 'absolute', left: list.length
  >= 100 ? '10%' : '25%', top: 10, fz: ct.h / 3 }); \r

  \  }\r

  \  return {\r

  \    ctype: 'deck',\r

  \    container: cont,\r

  \    cardcontainer: cardcont,\r

  \    items: items,\r

  \    list: list,\r

  \    title: title,\r

  \    path: path,\r

  \    func: get_card_func,\r

  \    get_topcard: get_topcard,\r

  \    get_bottomcard: get_bottomcard,\r

  \    get_card_func: get_card_func,\r

  \    renew: ensure_ui,\r

  \  };\r

  }"
ui_type_hand: "function ui_type_hand(list, dParent, styles = {}, path = 'hand',
  title = 'hand', get_card_func = ari_get_card, show_if_empty = false) {\r

  \  let cont = ui_make_container(dParent, get_container_styles(styles));\r

  \  let items = list.map(x => get_card_func(x));\r

  \  let cardcont = mDiv(cont);\r

  \  let card = isEmpty(items) ? { w: 1, h: Config.ui.card.h, ov: 0 } :
  items[0];\r

  \  let splay = 2;\r

  \  mContainerSplay(cardcont, splay, card.w, card.h, items.length, card.ov *
  card.w);\r

  \  ui_add_cards_to_hand_container(cardcont, items, list);\r

  \  ui_add_container_title(title, cont, items, show_if_empty);\r

  \  return {\r

  \    ctype: 'hand',\r

  \    list: list,\r

  \    path: path,\r

  \    container: cont,\r

  \    cardcontainer: cardcont,\r

  \    splay: splay,\r

  \    items: items,\r

  \  };\r

  }"
ui_type_lead_hand: "function ui_type_lead_hand(list, dParent, styles = {}, path
  = 'hand', title = 'hand', get_card_func = ari_get_card, show_if_empty = false)
  {\r

  \  let hcard = isdef(styles.h) ? styles.h - 30 : Config.ui.card.h;\r

  \  addKeys(get_container_styles(styles), styles);\r

  \  let cont = ui_make_container(dParent, styles);\r

  \  let items = list.map(x => get_card_func(x, hcard));\r

  \  let cardcont = mDiv(cont);\r

  \  let card = isEmpty(items) ? { w: 1, h: hcard, ov: 0 } : items[0];\r

  \  let splay = 5;\r

  \  mContainerSplay(cardcont, splay, card.w, card.h, items.length, card.ov *
  card.w);\r

  \  ui_add_cards_to_hand_container(cardcont, items, list);\r

  \  ui_add_container_title(title, cont, items, show_if_empty);\r

  \  return {\r

  \    ctype: 'hand',\r

  \    list: list,\r

  \    path: path,\r

  \    container: cont,\r

  \    cardcontainer: cardcont,\r

  \    splay: splay,\r

  \    items: items,\r

  \  };\r

  }"
ui_type_market: "function ui_type_market(list, dParent, styles = {}, path =
  'market', title = 'market', get_card_func = ari_get_card, show_if_empty =
  false) {\r

  \  let cont = ui_make_container(dParent, get_container_styles(styles));\r

  \  let cardcont = mDiv(cont, { display: 'flex', gap: 2 });\r

  \  let items = list.map(x => get_card_func(x));\r

  \  items.map(x => mAppend(cardcont, iDiv(x)));\r

  \  ui_add_container_title(title, cont, items, show_if_empty);\r

  \  return {\r

  \    ctype: 'market',\r

  \    list: list,\r

  \    path: path,\r

  \    container: cont,\r

  \    cardcontainer: cardcont,\r

  \    items: items,\r

  \  };\r

  }"
ui_type_rank_count: "function ui_type_rank_count(list, dParent, styles, path,
  title, get_card_func, show_if_empty = false) {\r

  \  let cont = ui_make_container(dParent, get_container_styles(styles));\r

  \  let cardcont = mDiv(cont, { display: 'flex' });\r

  \  let items = [];\r

  \  for (const o of list) {\r

  \    let d = mDiv(cardcont, { display: 'flex', dir: 'c', padding: 1, fz: 12,
  align: 'center', position: 'relative' });\r

  \    let c = get_card_func(o.key);\r

  \    mAppend(d, iDiv(c));\r

  \    remove_card_shadow(c);\r

  \    d.innerHTML += `<span style=\"font-weight:bold\">${o.count}</span>`;\r

  \    let item = { card: c, count: o.count, div: d };\r

  \    items.push(item);\r

  \  }\r

  \  ui_add_container_title(title, cont, items, show_if_empty);\r

  \  return {\r

  \    list: list,\r

  \    path: path,\r

  \    container: cont,\r

  \    cardcontainer: cardcont,\r

  \    items: items,\r

  \  }\r

  }"
activate_playerstats: "function activate_playerstats(items) {\r

  \  let fen = Z.fen;\r

  \  for (const plname in fen.players) {\r

  \    let ui = items[plname];\r

  \    let d = iDiv(ui);\r

  \    d.onclick = () => { switch_uname(plname); onclick_reload(); }\r

  \  }\r

  }"
activate_ui: "function activate_ui() {\r

  \  if (uiActivated) { DA.ai_is_moving = false; return; }\r

  \  uiActivated = true; DA.ai_is_moving = false;\r

  }"
aggregate_elements: "function aggregate_elements(list_of_object, propname) {\r

  \  let result = [];\r

  \  for (let i = 0; i < list_of_object.length; i++) {\r

  \    let obj = list_of_object[i];\r

  \    let arr = obj[propname];\r

  \    for (let j = 0; j < arr.length; j++) {\r

  \      result.push(arr[j]);\r

  \    }\r

  \  }\r

  \  return result;\r

  }"
ai_move: "function ai_move(ms = 100) {\r

  \  DA.ai_is_moving = true;\r

  \  let [A, fen] = [valf(Z.A, {}), Z.fen];\r

  \  let selitems;\r

  \  if (Z.game == 'accuse' && Z.stage == 'hand') {\r

  \    selitems = [];\r

  \  } else if (Z.game == 'ferro') {\r

  \    if (Z.stage == 'card_selection') {\r

  \      let uplayer = Z.uplayer;\r

  \      let i1 = firstCond(A.items, x =>
  x.path.includes(`${uplayer}.hand`));\r

  \      let i2 = firstCond(A.items, x => x.key == 'discard');\r

  \      selitems = [i1, i2];\r

  \    } else if (Z.stage == 'buy_or_pass') {\r

  \      selitems = [A.items[1]]; \r

  \    } else selitems = [A.items[0]];\r

  \  } else if (Z.game == 'bluff') {\r

  \    let [newbid, handler] = bluff_ai();\r

  \    if (newbid) { fen.newbid = newbid; UI.dAnzeige.innerHTML =
  bid_to_string(newbid); }\r

  \    else if (handler != handle_gehtHoch) { bluff_generate_random_bid(); }\r

  \    A.callback = handler;\r

  \    selitems = [];\r

  \  } else if (A.command == 'trade') {\r

  \    selitems = ai_pick_legal_trade();\r

  \  } else if (A.command == 'exchange') {\r

  \    selitems = ai_pick_legal_exchange();\r

  \  } else if (A.command == 'upgrade') {\r

  \    selitems = [rChoose(A.items)];\r

  \  } else if (A.command == 'rumor') {\r

  \    selitems = [];\r

  \    let buildings = A.items.filter(x => x.path.includes('building'));\r

  \    let rumors = A.items.filter(x => !x.path.includes('building'));\r

  \    selitems = [rChoose(buildings), rChoose(rumors)];\r

  \  } else if (ARI.stage[Z.stage] == 'rumors_weitergeben') {\r

  \    let players = A.items.filter(x => Z.plorder.includes(x.key))\r

  \    let rumors = A.items.filter(x => !Z.plorder.includes(x.key))\r

  \    selitems = [rChoose(players), rChoose(rumors)];\r

  \  } else if (ARI.stage[Z.stage] == 'journey') {\r

  \    selitems = []; \r

  \  } else {\r

  \    let items = A.items;\r

  \    let nmin = A.minselected;\r

  \    let nmax = Math.min(A.maxselected, items.length);\r

  \    let nselect = rNumber(nmin, nmax);\r

  \    selitems = rChoose(items, nselect); if (!isList(selitems)) selitems =
  [selitems];\r

  \  }\r

  \  for (const item of selitems) {\r

  \    select_last(item, select_toggle);\r

  \    if (isdef(item.submit_on_click)) A.selected.pop();\r

  \  }\r

  \  clearTimeout(TO.ai);\r

  \  loader_on();\r

  \  TO.ai = setTimeout(() => { if (isdef(A.callback)) A.callback();
  loader_off(); }, ms);\r

  }"
ai_schummler: function ai_schummler() { }
animate_card_approx: "function animate_card_approx(card, goal, ms, callback) {\r

  \  let d = iDiv(card);\r

  \  let dgoal = iDiv(goal); \r

  \  let r = getRect(d);\r

  \  let rgoal = getRect(dgoal);\r

  \  let c = { x: r.x + r.w / 2, y: r.y + r.h / 2 };\r

  \  let cgoal = { x: rgoal.x + rgoal.w / 2, y: rgoal.y + rgoal.h / 2 };\r

  \  let v = { x: cgoal.x - c.x, y: cgoal.y - c.y };\r

  \  mAnimateList(d, { transform: `translateX(${v.x}px) translateY(${v.y}px)`,
  opacity: 0 }, callback, ms, 'linear');\r

  }"
animate_card_exchange: "function animate_card_exchange(i0, i1, callback) {\r

  \  ari_make_unselectable(i0);\r

  \  ari_make_unselectable(i1);\r

  \  let d0 = iDiv(i0.o);\r

  \  let d1 = iDiv(i1.o);\r

  \  let r0 = getRect(d0);\r

  \  let r1 = getRect(d1);\r

  \  let c0 = { x: r0.x + r0.w / 2, y: r0.y + r0.h / 2 };\r

  \  let c1 = { x: r1.x + r1.w / 2, y: r1.y + r1.h / 2 };\r

  \  let v = { x: c1.x - c0.x, y: c1.y - c0.y };\r

  \  mTranslateBy(d0, v.x, v.y);\r

  \  mTranslateBy(d1, -v.x, -v.y, 700, callback);\r

  }"
animate_card_transfer: "function animate_card_transfer(card, goal, callback) {\r

  \  let d = iDiv(card);\r

  \  let dgoal = iDiv(goal); \r

  \  let r = getRect(d);\r

  \  let rgoal = getRect(dgoal);\r

  \  let c = { x: r.x + r.w / 2, y: r.y + r.h / 2 };\r

  \  let cgoal = { x: rgoal.x + rgoal.w / 2, y: rgoal.y + rgoal.h / 2 };\r

  \  let v = { x: cgoal.x - c.x, y: cgoal.y - c.y };\r

  \  mTranslateBy(d, v.x, v.y, 700, callback);\r

  }"
animate_title: "function animate_title() {\r

  \  var rev = \"fwd\";\r

  \  function titlebar(val) {\r

  \    var msg = \"Hallodi!\";\r

  \    var res = \" \";\r

  \    var speed = 100;\r

  \    var pos = val;\r

  \    msg = \"   |-\" + msg + \"-|\";\r

  \    var le = msg.length;\r

  \    if (rev == \"fwd\") {\r

  \      if (pos < le) {\r

  \        pos = pos + 1;\r

  \        scroll = msg.substr(0, pos);\r

  \        document.title = scroll;\r

  \        timer = window.setTimeout(\"titlebar(\" + pos + \")\", speed);\r

  \      }\r

  \      else {\r

  \        rev = \"bwd\";\r

  \        timer = window.setTimeout(\"titlebar(\" + pos + \")\", speed);\r

  \      }\r

  \    }\r

  \    else {\r

  \      if (pos > 0) {\r

  \        pos = pos - 1;\r

  \        var ale = le - pos;\r

  \        scrol = msg.substr(ale, le);\r

  \        document.title = scrol;\r

  \        timer = window.setTimeout(\"titlebar(\" + pos + \")\", speed);\r

  \      }\r

  \      else {\r

  \        rev = \"fwd\";\r

  \        timer = window.setTimeout(\"titlebar(\" + pos + \")\", speed);\r

  \      }\r

  \    }\r

  \  }\r

  \  titlebar(0);\r

  }"
animatedTitle: "function animatedTitle(msg = 'DU BIST DRAN!!!!!') {\r

  \  TO.titleInterval = setInterval(() => {\r

  \    let corner = CORNERS[WhichCorner++ % CORNERS.length];\r

  \    document.title = `${corner} ${msg}`; //'&amp;21543;    U+231E
  \\0xE2Fo\\u0027o Bar';\r

  \  }, 1000);\r

  }"
ari_show_handsorting_buttons_for: "function
  ari_show_handsorting_buttons_for(plname) {\r

  \  if (Z.role == 'spectator' || isdef(mBy('dHandButtons'))) return;\r

  \  let fen = Z.fen;\r

  \  let pl = fen.players[plname];\r

  \  if (pl.hand.length <= 1) return;\r

  \  let d = UI.players[plname].hand.container; mStyle(d, { position:
  'relative' });\r

  \  let dHandButtons = mDiv(d, { position: 'absolute', bottom: -2, left: 52,
  height: 25 }, 'dHandButtons');\r

  \  show_player_button('sort', dHandButtons, onclick_by_rank);\r

  }"
beautify_history: "function beautify_history(lines, title, fen, uplayer) {\r

  \  let html = `<div class=\"history\"><span
  style=\"color:red;font-weight:bold;\">${title}: </span>`;\r

  \  for (const l of lines) {\r

  \    let words = toWords(l);\r

  \    for (const w1 of words) {\r

  \      if (is_card_key(w1)) { html += mCardText(w1); continue; }\r

  \      w = w1.toLowerCase();\r

  \      if (isdef(fen.players[w])) {\r

  \        html += `<span
  style=\"color:${get_user_color(w)};font-weight:bold\"> ${w} </span>`;\r

  \      } else html += ` ${w} `;\r

  \    }\r

  \    if (lines.length > 1) html = html.trim() + (l == arrLast(lines) ? '.' :
  ', ');\r

  \  }\r

  \  html += \"</div>\";\r

  \  return html;\r

  }"
clear_screen: "function clear_screen() { mShieldsOff(); clear_status();
  clear_title(); for (const ch of arrChildren('dScreen')) mClear(ch);
  mClassRemove('dTexture', 'wood'); mStyle(document.body, { bg: 'white', fg:
  'black' }); }"
clear_status: function clear_status() { if (nundef(mBy('dStatus'))) return;
  clearTimeout(TO.fleeting); mRemove("dStatus"); }
clear_title: function clear_title() { mClear('dTitleMiddle');
  mClear('dTitleLeft'); mClear('dTitleRight'); }
clearPlayers: "function clearPlayers(){\r

  \  for(const item of DA.allPlayers){\r

  \    if (item.isSelected && !is_loggedin(item.uname)){\r

  \      style_not_playing(item,'',DA.playerlist);\r

  \    }\r

  \  }\r

  \  assertion(!isEmpty(DA.playerlist),\"uname removed from
  playerlist!!!!!!!!!!!!!!!\")\r

  \  DA.lastName = DA.playerlist[0].uname; \r

  }"
collect_game_specific_options: "function collect_game_specific_options(game) {\r

  \  let poss = Config.games[game].options;\r

  \  if (nundef(poss)) return;\r

  \  let di = {};\r

  \  for (const p in poss) {\r

  \    let key = p;\r

  \    let vals = poss[p];\r

  \    if (isString(vals) && vals.split(',').length <= 1) {\r

  \      di[p] = isNumber(vals) ? Number(vals) : vals;\r

  \      continue;\r

  \    }\r

  \    let fs = mBy(`d_${p}`);\r

  \    let val = get_checked_radios(fs)[0];\r

  \    di[p] = isNumber(val) ? Number(val) : val;\r

  \  }\r

  \  return di;\r

  }"
complexCompare: "function complexCompare(obj1, obj2) {\r

  \  const obj1Keys = Object.keys(obj1);\r

  \  const obj2Keys = Object.keys(obj2);\r

  \  if (obj1Keys.length !== obj2Keys.length) {\r

  \    return false;\r

  \  }\r

  \  for (let objKey of obj1Keys) {\r

  \    if (obj1[objKey] !== obj2[objKey]) {\r

  \      if (typeof obj1[objKey] == \"object\" && typeof obj2[objKey] ==
  \"object\") {\r

  \        if (!isEqual(obj1[objKey], obj2[objKey])) {\r

  \          return false;\r

  \        }\r

  \      }\r

  \      else {\r

  \        return false;\r

  \      }\r

  \    }\r

  \  }\r

  \  return true;\r

  }"
compute_hidden: "function compute_hidden(plname) {\r

  \  let [fen, uplayer] = [Z.fen, Z.uplayer];\r

  \  let pl = fen.players[plname];\r

  \  let hidden;\r

  \  if (isdef(fen.winners)) hidden = false;\r

  \  else if (Z.role == 'spectator') hidden = plname != uplayer;\r

  \  else if (Z.mode == 'hotseat') hidden = (pl.playmode == 'bot' || plname !=
  uplayer);\r

  \  else hidden = plname != Z.uname;\r

  \  return hidden;\r

  }"
deactivate_ui: function deactivate_ui() { uiActivated = false; DA.ai_is_moving = true; }
delete_table: "function delete_table(friendly) { stopgame(); phpPost({ friendly:
  friendly }, 'delete_table'); }"
ev_to_gname: function ev_to_gname(ev) { evNoBubble(ev); return
  evToTargetAttribute(ev, 'gamename'); }
exchange_by_index: "function exchange_by_index(arr1, i1, arr2, i2) {\r

  \  let temp = arr1[i1];\r

  \  arr1[i1] = arr2[i2];\r

  \  arr2[i2] = temp;\r

  }"
find_card: function find_card(index, ui_item) { return ui_item.items[index]; }
gamestep: "function gamestep() {\r

  \  show_admin_ui();\r

  \  DA.running = true; clear_screen(); dTable = mBy('dTable');
  mClass('dTexture', 'wood');\r

  \  if (Z.game == 'aristo') { if (Z.role != Clientdata.role || Z.mode ==
  'multi' && Z.role != 'active') mFall(dTable); Clientdata.role = Z.role; }\r

  \  else mFall(dTable);\r

  \  shield_off();\r

  \  show_title();\r

  \  show_role();\r

  \  Z.func.present(dTable);  \r

  \  if (isdef(Z.scoring.winners)) { show_winners();
  animatedTitle('GAMEOVER!'); }\r

  \  else if (Z.func.check_gameover(Z)) {\r

  \    let winners = show_winners();\r

  \    Z.scoring = { winners: winners }\r

  \    sendgameover(winners[0], Z.friendly, Z.fen, Z.scoring);\r

  \  } else if (is_shield_mode()) {\r

  \    staticTitle();\r

  \    if (!DA.no_shield == true) { hide('bRestartMove'); shield_on(); } \r

  \    autopoll();\r

  \  } else {\r

  \    Z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null,
  breadcrumbs: [], sib: [], command: null, autosubmit: Config.autosubmit };\r

  \    copyKeys(jsCopy(Z.fen), Z);\r

  \    copyKeys(UI, Z);\r

  \    activate_ui(Z);\r

  \    Z.func.activate_ui();\r

  \    if (Z.isWaiting == true || Z.mode != 'multi') staticTitle(); else
  animatedTitle();\r

  \    if (Z.options.zen_mode != 'yes' && Z.mode != 'hotseat' &&
  Z.fen.keeppolling) {\r

  \      autopoll();\r

  \      console.log('gamestep autopoll');\r

  \    }\r

  \  }\r

  \  if (TESTING == true) landing();  \r

  }"
generate_table_name: "function generate_table_name(n) {\r

  \  let existing = Serverdata.tables.map(x => x.friendly);\r

  \  while (true) {\r

  \    let cap = rChoose(Info.capital);\r

  \    let parts = cap.split(' ');\r

  \    if (parts.length == 2) cap = stringBefore(cap, ' '); else cap =
  stringBefore(cap, '-');\r

  \    cap = cap.trim();\r

  \    let s = (n == 2 ? 'duel of ' : rChoose(['battle of ', 'war of '])) +
  cap;\r

  \    if (!existing.includes(s)) return s;\r

  \  }\r

  }"
get_admin_player: "function get_admin_player(list) {\r

  \  let res = valf(firstCond(list, x => x == 'mimi'), firstCond(list, x =>
  ['felix', 'amanda', 'lauren'].includes(x)));\r

  \  return res ?? list[0]; \r

  }"
get_checked_radios: "function get_checked_radios(rg) {\r

  \  let inputs = rg.getElementsByTagName('INPUT');\r

  \  let list = [];\r

  \  for (const ch of inputs) {\r

  \    let checked = ch.getAttribute('checked');\r

  \    if (ch.checked) list.push(ch.value);\r

  \  }\r

  \  return list;\r

  }"
get_default_options: "function get_default_options(gamename) {\r

  \  let options = {};\r

  \  for (const k in Config.games[gamename].options) options[k] =
  arrLast(Config.games[gamename].options[k]);\r

  \  return options;\r

  }"
get_game_color: function get_game_color(game) { return colorFrom(Config.games[game].color); }
get_logout_button: "function get_logout_button() {\r

  \  let html = `<a id=\"aLogout\"
  href=\"javascript:onclick_logout()\">logout</a>`;\r

  \  return mCreateFrom(html);\r

  }"
get_multi_trigger: function get_multi_trigger() { return lookup(Z, ['fen', 'trigger']); }
get_next_human_player: "function get_next_human_player(plname) {\r

  \  if (nundef(plname)) return null;\r

  \  let [prevturn, mode, turn, uname, plorder, fen, host] = [Z.prev.turn,
  Z.mode, Z.turn, Z.uname, Z.plorder, Z.fen, Z.host];\r

  \  let same = isString(plname) && isList(prevturn) && sameList(prevturn,
  turn);\r

  \  if (!same) return null;\r

  \  let plnew = get_next_player(Z, plname);\r

  \  while (fen.players[plnew].playmode == 'bot') {\r

  \    plnew = get_next_player(Z, plnew);\r

  \    if (plnew == plname) break;\r

  \  }\r

  \  return plnew;\r

  }"
get_next_in_list: "function get_next_in_list(el, list) {\r

  \  let iturn = list.indexOf(el);\r

  \  let nextplayer = list[(iturn + 1) % list.length];\r

  \  return nextplayer;\r

  }"
get_next_player: "function get_next_player(g, uname) {\r

  \  let plorder = g.fen.plorder;\r

  \  let iturn = plorder.indexOf(uname);\r

  \  let nextplayer = plorder[(iturn + 1) % plorder.length];\r

  \  return nextplayer;\r

  }"
get_playmode: function get_playmode(uname) { return Z.fen.players[uname].playmode; }
get_present_order: "function get_present_order() {\r

  \  let [fen, uplayer, uname] = [Z.fen, Z.uplayer, Z.uname];\r

  \  assertion(is_human_player(uplayer) || uname == Z.host, \"PRESENT ORDER ME
  WRONG!!!!!!!!!!!!!\")\r

  \  let uname_plays = fen.plorder.includes(uname);\r

  \  let is_bot = !is_human_player(uplayer);\r

  \  let show_first = Z.mode == 'multi' && uname_plays && !is_bot ? Z.uname :
  uplayer;\r

  \  return arrCycle(Z.fen.plorder, Z.fen.plorder.indexOf(show_first));\r

  }"
get_present_order_accuse: "function get_present_order_accuse() {\r

  \  let [fen, uplayer] = [Z.fen, Z.uplayer];\r

  \  let show_first = uplayer;\r

  \  console.log('uplayer', uplayer)\r

  \  return arrCycle(Z.fen.plorder, Z.fen.plorder.indexOf(show_first));\r

  }"
get_screen_distance: "function get_screen_distance(child, newParent) {\r

  \  child = toElem(child);\r

  \  newParent = toElem(newParent);\r

  \  const parentOriginal = child.parentNode;\r

  \  let children = arrChildren(parentOriginal);\r

  \  let iChild = children.indexOf(child);\r

  \  let sibling = iChild == children.length - 1 ? null : children[iChild +
  1];\r

  \  const x0 = child.getBoundingClientRect().left;\r

  \  const y0 = child.getBoundingClientRect().top;\r

  \  newParent.appendChild(child);\r

  \  const x1 = child.getBoundingClientRect().left;\r

  \  const y1 = child.getBoundingClientRect().top;\r

  \  if (sibling) parentOriginal.insertBefore(child, sibling); else
  parentOriginal.appendChild(child);\r

  \  return [x1 - x0, y1 - y0];\r

  }"
get_texture: function get_texture(name) { return
  `url(../base/assets/images/textures/${name}.png)`; }
get_user_color: function get_user_color(uname) { let u =
  firstCond(Serverdata.users, x => x.name == uname); return colorFrom(u.color);
  }
get_user_pic: "function get_user_pic(uname, sz = 50, border = 'solid medium
  white') {\r

  \  let html = get_user_pic_html(uname, sz, border); \r

  \  return mCreateFrom(html);\r

  }"
get_user_pic_and_name: "function get_user_pic_and_name(uname, dParent, sz = 50,
  border = 'solid medium white') {\r

  \  let html = `\r

  \      <div username='${uname}' style='text-align:center;font-size:${sz /
  2.8}px'>\r

  \        <img src='../base/assets/images/${uname}.jpg' width='${sz}'
  height='${sz}' class='img_person' style='margin:0;border:${border}'>\r

  \        <div style='margin-top:${-sz / 6}px'>${uname}</div>\r

  \      </div>`;\r

  \  let elem = mCreateFrom(html);\r

  \  mAppend(dParent, elem);\r

  \  return elem;\r

  }"
get_user_pic_html: "function get_user_pic_html(uname, sz = 50, border = 'solid
  medium white') {\r

  \  return `<img src='../base/assets/images/${uname}.jpg' width='${sz}'
  height='${sz}' class='img_person' style='margin:0px 4px;border:${border}'>`\r

  }"
get_waiting_html: function get_waiting_html(sz = 30) { return `<img
  src="../base/assets/images/active_player.gif" height="${sz}" style="margin:0px
  ${sz / 3}px" />`; }
hFunc: "function hFunc(content, funcname, arg1, arg2, arg3) {\r

  \  let html = `<a style='color:blue'
  href=\"javascript:${funcname}('${arg1}','${arg2}','${arg3}');\">${content}</a\
  >`;\r

  \  return html;\r

  }"
hide_buildings: "function hide_buildings() {\r

  \  let uplayer = Z.uplayer;\r

  \  let buildings = UI.players[uplayer].buildinglist;\r

  \  for (const b of buildings) {\r

  \    for (let i = 1; i < b.items.length; i++) {\r

  \      let card = b.items[i];\r

  \      if (b.schweine.includes(card)) continue;\r

  \      face_down(b.items[i]);\r

  \    }\r

  \  }\r

  }"
HPLayout: "function HPLayout() {\r

  \  if (isdef(UI.DRR)) UI.DRR.remove();\r

  \  mInsert(UI.dRechts, UI.dHistory);\r

  \  Clientdata.historyLayout = 'hp';\r

  }"
HRPLayout: "function HRPLayout() {\r

  \  let dr = UI.dRechts;\r

  \  dr.remove();\r

  \  let drr = UI.DRR = mDiv(dTable);\r

  \  mAppend(drr, UI.dHistory);\r

  \  mAppend(dTable, dr);\r

  \  Clientdata.historyLayout = 'hrp';\r

  }"
i_am_acting_host: function i_am_acting_host() { return U.name == Z.fen.acting_host; }
i_am_host: function i_am_host() { return U.name == Z.host; }
i_am_trigger: function i_am_trigger() { return is_multi_trigger(U.name); }
if_hotseat_autoswitch: "function if_hotseat_autoswitch(result) {\r

  \  if (isdef(result.table) && isdef(Z) && Z.mode == 'hotseat') { \r

  \    let turn = lookup(result, ['table', 'fen', 'turn']);\r

  \    assertion(isdef(turn), 'turn is NOT defined (_sendSIMSIM) !!!!');\r

  \    let uname = turn.length == 1 ? turn[0] : get_next_in_list(U.name,
  turn);\r

  \    if (uname != U.name) switch_uname(uname);\r

  \  }\r

  }"
if_plural: "function if_plural(n) { return n == 1 ? '' : 's'; }"
if_stringified: "function if_stringified(obj) { return is_stringified(obj) ?
  JSON.parse(obj) : obj; }"
intersection: "function intersection(arr1, arr2) {\r

  \  let res = [];\r

  \  for (const a of arr1) {\r

  \    if (arr2.includes(a)) {\r

  \      addIf(res, a);\r

  \    }\r

  \  }\r

  \  return res;\r

  }"
is_advanced_user: "function is_advanced_user() {\r

  \  let advancedUsers = ['mimi', 'felix', 'bob', 'buddy', 'minnow', 'nimble',
  'leo']; \r

  \  return isdef(U) && ((advancedUsers.includes(DA.secretuser) ||
  advancedUsers.includes(U.name)));\r

  }"
is_ai_player: "function is_ai_player(plname) {\r

  \  let [fen, name] = [Z.fen, valf(plname, Z.uplayer)];\r

  \  return lookup(fen, ['players', name, 'playmode']) == 'bot';\r

  }"
is_collect_mode: function is_collect_mode() { return Z.turn.length > 1; }
is_color: function is_color(s) { return isdef(ColorDi[s.toLowerCase()]); }
is_current_player_bot: "function is_current_player_bot() {\r

  \  let [fen, uplayer, turn] = [Z.fen, Z.uplayer, Z.turn];\r

  \  let curplayer = Z.turn[0];\r

  \  if (fen.players[curplayer].playmode == 'bot') return true; else return
  false;\r

  }"
is_human_player: "function is_human_player(plname) {\r

  \  let [fen, name] = [Z.fen, valf(plname, Z.uplayer)];\r

  \  return lookup(fen, ['players', name, 'playmode']) == 'human';\r

  }"
is_just_my_turn: "function is_just_my_turn() {\r

  \  return isEmpty(Z.turn.filter(x => x != Z.uplayer));\r

  }"
is_loggedin: function is_loggedin(name){return isdef(U) && U.name == name;}
is_multi_stage: function is_multi_stage() { return isdef(Z.fen.trigger); }
is_multi_trigger: function is_multi_trigger(plname) { return lookup(Z, ['fen',
  'trigger']) == plname; }
is_player: function is_player(s) { return isdef(Z.fen.players[s]); }
is_playerdata_set: "function is_playerdata_set(plname) {\r

  \  return isdef(Z.playerdata) && !isEmpty(Z.playerdata) &&
  !isEmpty(Z.playerdata.find(x => x.name == plname).state);\r

  }"
is_playing: "function is_playing(pl, fen) {\r

  \  return isList(fen.plorder) && fen.plorder.includes(pl) ||
  isList(fen.roundorder) && fen.roundorder.includes(pl) || Z.game == 'feedback'
  && isdef(Z.fen.players[pl]);\r

  }"
is_shield_mode: "function is_shield_mode() {\r

  \  return Z.role == 'spectator'\r

  \    || Z.mode == 'multi' && Z.role == 'inactive' && Z.host != Z.uname\r

  \    || Z.mode == 'multi' && Z.role == 'inactive' && Z.pl.playmode !=
  'bot'\r

  }"
is_stringified: "function is_stringified(obj) {\r

  \  if (isString(obj)) {\r

  \    return '\"\\'{[('.includes(obj[0]);\r

  \  }\r

  \  return false;\r

  }"
mFlip: "function mFlip(card, ms, callback) {\r

  \  let a = mAnimate(iDiv(card), 'transform', [`scale(1,1)`, `scale(0,1)`],\r

  \    () => {\r

  \      if (card.faceUp) face_down(card); else face_up(card);\r

  \      mAnimate(iDiv(card), 'transform', [`scale(0,1)`, `scale(1,1)`],
  callback, ms / 2, 'ease-in', 0, 'both');\r

  \    },\r

  \    ms / 2, 'ease-out', 0, 'both');\r

  }"
new_cards_animation: "function new_cards_animation(n = 2) {\r

  \  let [stage, A, fen, plorder, uplayer, deck] = [Z.stage, Z.A, Z.fen,
  Z.plorder, Z.uplayer, Z.deck];\r

  \  let pl = fen.players[uplayer];\r

  \  if (stage == 'card_selection' && !isEmpty(pl.newcards)) {\r

  \    let anim_elems = [];\r

  \    for (const key of pl.newcards) {\r

  \      let ui = lastCond(UI.players[uplayer].hand.items, x => x.key ==
  key);\r

  \      if (nundef(ui)) { pl.newcards = []; return; }\r

  \      ui = iDiv(ui);\r

  \      anim_elems.push(ui);\r

  \    }\r

  \    delete pl.newcards;\r

  \    anim_elems.map(x => mPulse(x, n * 1000));\r

  \  }\r

  }"
object2string: "function object2string(o, props = [], except_props = []) {\r

  \  let s = '';\r

  \  if (nundef(o)) return s;\r

  \  if (isString(o)) return o;\r

  \  let keys = Object.keys(o).sort();\r

  \  for (const k of keys) {\r

  \    if (!isEmpty(props) && props.includes(k) || !except_props.includes(k))
  {\r

  \      let val = isList(o[k]) ? o[k].join(',') : isDict(o[k]) ?
  object2string(o[k].props, except_props) : o[k];\r

  \      let key_part = isEmpty(s) ? '' : `, ${k}:`;\r

  \      s += val;\r

  \    }\r

  \  }\r

  \  return s;\r

  }"
path2fen: function path2fen(fen, path) { let o = lookup(fen, path.split('.'));
  return o; }
path2UI: "function path2UI(path) {\r

  \  let res = lookup(UI, path.split('.'));\r

  \  return res;\r

  }"
PHLayout: "function PHLayout() {\r

  \  if (isdef(UI.DRR)) UI.DRR.remove();\r

  \  mAppend(UI.dRechts, UI.dHistory);\r

  \  Clientdata.historyLayout = 'ph';\r

  }"
player_stat_count: "function player_stat_count(key, n, dParent, styles = {}) {\r

  \  let sz = valf(styles.sz, 16);\r

  \  addKeys({ display: 'flex', margin: 4, dir: 'column', hmax: 2 * sz,
  'align-content': 'start', fz: sz, align: 'center' }, styles);\r

  \  let d = mDiv(dParent, styles);\r

  \  if (isdef(Syms[key])) mSym(key, d, { h: sz, 'line-height': sz, w: '100%'
  });\r

  \  else mText(key, d, { h: sz, fz: sz, w: '100%' });\r

  \  d.innerHTML += `<span style=\"font-weight:bold\">${n}</span>`;\r

  \  return d;\r

  }"
prep_move: "function prep_move() {\r

  \  let [fen, uplayer, pl] = [Z.fen, Z.uplayer, Z.pl];\r

  \  for (const k of ['round', 'phase', 'stage', 'step', 'turn']) { fen[k] =
  Z[k]; }\r

  \  deactivate_ui();\r

  \  clear_timeouts();\r

  }"
PRHLayout: "function PRHLayout() {\r

  \  let drr = UI.DRR = mDiv(dTable);\r

  \  mAppend(drr, UI.dHistory);\r

  \  Clientdata.historyLayout = 'prh';\r

  }"
remove_hourglass: function remove_hourglass(uname) { let d = mBy(`dh_${uname}`);
  if (isdef(d)) mRemove(d); }
remove_player: "function remove_player(fen, uname) {\r

  \  if (nundef(fen.original_players)) fen.original_players =
  jsCopy(fen.players);\r

  \  removeInPlace(fen.plorder, uname);\r

  \  delete fen.players[uname];\r

  \  return fen.plorder;\r

  }"
round_change_animation: "function round_change_animation(n = 2) {\r

  \  let [stage, A, fen, plorder, uplayer, deck] = [Z.stage, Z.A, Z.fen,
  Z.plorder, Z.uplayer, Z.deck];\r

  \  let pl = fen.players[uplayer];\r

  \  if (pl.roundchange) {\r

  \    let d = mBy('dTitleLeft');\r

  \    mStyle(d, { 'transform-origin': '0% 0%' });\r

  \    mPulse(d, n * 1000);\r

  \    show_special_message(`${fen.round_winner} won round ${Z.round -
  1}!!!`)\r

  \    delete pl.roundchange;\r

  \  }\r

  }"
sendgameover: "function sendgameover(plname, friendly, fen, scoring) {\r

  \  let o = { winners: plname, friendly: friendly, fen: fen, scoring: scoring
  };\r

  \  phpPost(o, 'gameover');\r

  }"
set_player: "function set_player(name, fen) {\r

  \  if (isdef(PL) && PL.name != name) { Z.prev.pl = PL; Z.prev.uplayer =
  PL.name; }\r

  \  PL = Z.pl = firstCond(Serverdata.users, x => x.name == name);\r

  \  copyKeys(fen.players[name], PL);\r

  \  Z.uplayer = name;\r

  }"
set_player_strategy: "function set_player_strategy(val) {\r

  \  Z.strategy = Clientdata.strategy = Z.pl.strategy = val;\r

  \  mRemove('dOptions')\r

  }"
set_user: "function set_user(name) {\r

  \  if (isdef(Z) && isdef(U) && U.name != name) {\r

  \    Z.prev.u = U;\r

  \    Z.prev.uname = U.name;\r

  \  }\r

  \  U = firstCond(Serverdata.users, x => x.name == name);\r

  \  if (isdef(Z)) {\r

  \    Z.u = U;\r

  \    Z.uname = name;\r

  \  }\r

  }"
shield_off: "function shield_off() {\r

  \  mStyle('dAdmin', { bg: 'white' });\r

  }"
shield_on: "function shield_on() {\r

  \  mShield(dTable.firstChild.childNodes[1]);\r

  \  mStyle('dAdmin', { bg: 'silver' });\r

  }"
show_admin_ui: "function show_admin_ui() {\r

  \  for (const id of ['bSpotitStart', 'bClearAck', 'bRandomMove',
  'bSkipPlayer', 'bRestartMove', 'dTakeover', 'bExperience']) hide(id);\r

  \  if (Z.game == 'spotit' && Z.uname == Z.host && Z.stage == 'init')
  show('bSpotitStart');\r

  \  else if (Z.game == 'bluff' && Z.uname == Z.host && Z.stage == 1)
  show('bClearAck');\r

  \  else if (Z.uname == Z.host && Z.stage == 'round_end')
  show('bClearAck');\r

  \  else if (Z.game == 'ferro' && Z.uname == 'mimi' && Z.stage !=
  'card_selection') show('bClearAck');\r

  \  if (Z.game == 'accuse' && lookup(Z, ['fen', 'players', Z.uplayer,
  'experience']) > 0) show('bExperience');\r

  \  if (['ferro', 'bluff', 'aristo', 'a_game'].includes(Z.game) && (Z.role ==
  'active' || Z.mode == 'hotseat')) {\r

  \    show('bRandomMove');\r

  \  }\r

  \  if (Z.uname == Z.host || Z.uname == 'mimi' || Z.uname == 'felix')
  show('dHostButtons'); else hide('dHostButtons');\r

  \  if (DA.showTestButtons == true) show('dTestButtons'); else
  hide('dTestButtons');\r

  }"
show_fleeting_message: "function show_fleeting_message(s, dParent, styles, id,
  ms = 2000) {\r

  \  let d = mDiv(dParent, styles, id, s);\r

  \  mFadeRemove(d, ms);\r

  }"
show_game_menu: "function show_game_menu(gamename) {\r

  \  stopgame();\r

  \  show('dMenu'); mClear('dMenu');\r

  \  let dMenu = mBy('dMenu');\r

  \  let dForm = mDiv(dMenu, { align: 'center' }, 'fMenuInput');\r

  \  let dInputs = mDiv(dForm, {}, 'dMenuInput');\r

  \  let dButtons = mDiv(dForm, {}, 'dMenuButtons');\r

  \  let bstart = mButton('start', () => {\r

  \    let players = DA.playerlist.map(x => ({ name: x.uname, playmode:
  x.playmode }));\r

  \    let game = gamename;\r

  \    let options = collect_game_specific_options(game);\r

  \    for (const pl of players) { if (isEmpty(pl.strategy)) pl.strategy =
  valf(options.strategy, 'random'); }\r

  \    startgame(game, players, options); hide('dMenu');\r

  \  }, dButtons, {}, ['button', 'enabled']);\r

  \  let bcancel = mButton('cancel', () => { hide('dMenu'); }, dButtons, {},
  ['button', 'enabled']);\r

  \  let bclear = mButton('clear players', clearPlayers, dButtons, {},
  ['button', 'enabled']);\r

  \  let d = dInputs; mClear(d); mCenterFlex(d);\r

  \  let dPlayers = mDiv(d, { gap: 6 });\r

  \  mCenterFlex(dPlayers);\r

  \  DA.playerlist = [];\r

  \  DA.allPlayers = [];\r

  \  DA.lastName = null;\r

  \  let params = [gamename, DA.playerlist];\r

  \  let funcs = [style_not_playing, style_playing_as_human,
  style_playing_as_bot];\r

  \  for (const u of Serverdata.users) {\r

  \    let d = get_user_pic_and_name(u.name, dPlayers, 40);\r

  \    mStyle(d, { w: 60, cursor: 'pointer' })\r

  \    let item = { uname: u.name, div: d, state: 0, strategy: '', isSelected:
  false };\r

  \    DA.allPlayers.push(item);\r

  \    if (is_loggedin(u.name)) { toggle_select(item, funcs, gamename,
  DA.playerlist); DA.lastName = U.name; }\r

  \    else d.onclick = ev => {\r

  \      if (ev.shiftKey) {\r

  \        let list = Serverdata.users;\r

  \        if (nundef(DA.lastName)) DA.lastName = list[0].name;\r

  \        let x1 = list.find(x => x.name == DA.lastName);\r

  \        let i1 = list.indexOf(x1);\r

  \        let x2 = list.find(x => x.name == item.uname);\r

  \        let i2 = list.indexOf(x2);\r

  \        if (i1 == i2) return;\r

  \        if (i1 > i2) [i1, i2] = [i2, i1];\r

  \        assertion(i1 < i2, \"NOT IN CORRECT ORDER!!!!!\")\r

  \        for (let i = i1; i <= i2; i++) {\r

  \          let xitem = DA.allPlayers[i];\r

  \          if (xitem.isSelected) continue;\r

  \          style_playing_as_human(xitem, gamename, DA.playerlist);\r

  \        }\r

  \        DA.lastName = item.uname;\r

  \      } else {\r

  \        toggle_select(item, funcs, gamename, DA.playerlist);\r

  \        if (item.isSelected) DA.lastName = item.uname;\r

  \      }\r

  \    }\r

  \  }\r

  \  //
  mDiv(d,{h:40,matop:10,fz:11,fg:'silver',rounding:10,bg:'beige'},null,'use
  SHIFT to multi-select players'); //'SHIFT<br>multiselect');\r

  \  mDiv(d,{w:'100%',fz:11,fg:'#444'},null,'(use SHIFT to multi-select
  players)'); //'SHIFT<br>multiselect');\r

  \  mLinebreak(d, 1);\r

  \  show_game_options(d, gamename);\r

  \  mFall('dMenu');\r

  }"
show_game_options: "function show_game_options(dParent, game) {\r

  \  mRemoveChildrenFromIndex(dParent, 2);\r

  \  let poss = Config.games[game].options;\r

  \  if (nundef(poss)) return;\r

  \  for (const p in poss) {\r

  \    let key = p;\r

  \    let val = poss[p];\r

  \    if (isString(val)) {\r

  \      let list = val.split(','); \r

  \      if (list.length <= 1) continue;\r

  \      let fs = mRadioGroup(dParent, {}, `d_${key}`, key);\r

  \      for (const v of list) { mRadio(v, isNumber(v) ? Number(v) : v, key,
  fs, { cursor: 'pointer' }, null, key, true); }\r

  \      measure_fieldset(fs);\r

  \    }\r

  \  }\r

  }"
show_games: "function show_games(ms = 500) {\r

  \  let dParent = mBy('dGames');\r

  \  mClear(dParent);\r

  \  mText(`<h2>start new game</h2>`, dParent, { maleft: 12 });\r

  \  let d = mDiv(dParent, { fg: 'white', animation: 'appear 1s ease both' },
  'game_menu'); mFlexWrap(d);\r

  \  let gamelist = 'accuse aristo bluff wise spotit ferro'; if (DA.TEST0)
  gamelist += ' a_game';\r

  \  for (const gname of toWords(gamelist)) {\r

  \    let g = Config.games[gname];\r

  \    let [sym, bg, color, id] = [Syms[g.logo], g.color, null, getUID()];\r

  \    let d1 = mDiv(d, { cursor: 'pointer', rounding: 10, margin: 10,
  padding: 0, patop: 15, wmin: 140, height: 90, bg: bg, position: 'relative' },
  g.id);\r

  \    d1.setAttribute('gamename', gname);\r

  \    d1.onclick = onclick_game_menu_item;\r

  \    mCenterFlex(d1);\r

  \    mDiv(d1, { fz: 50, family: sym.family, 'line-height': 55 }, null,
  sym.text);\r

  \    mLinebreak(d1);\r

  \    mDiv(d1, { fz: 18, align: 'center' }, null, g.friendly);\r

  \  }\r

  }"
show_handsorting_buttons_for: "function show_handsorting_buttons_for(plname,
  styles = {}) {\r

  \  if (Z.role == 'spectator' || isdef(mBy('dHandButtons'))) return;\r

  \  let fen = Z.fen;\r

  \  let pl = fen.players[plname];\r

  \  if (pl.hand.length <= 1) return;\r

  \  let d = UI.players[plname].hand.container; mStyle(d, { position:
  'relative', wmin: 155 }); \r

  \  addKeys({ position: 'absolute', left: 58, bottom: -8, height: 25 },
  styles);\r

  \  let dHandButtons = mDiv(d, styles, 'dHandButtons');\r

  \  show_player_button('rank', dHandButtons, onclick_by_rank);\r

  \  show_player_button('suit', dHandButtons, onclick_by_suit);\r

  }"
show_history: "function show_history(fen, dParent) {\r

  \  if (!isEmpty(fen.history)) {\r

  \    let html = '';\r

  \    for (const o of jsCopy(fen.history).reverse()) {\r

  \      html += beautify_history(o.lines, o.title, fen);\r

  \    }\r

  \    let dHistory = mDiv(dParent, { maright: 10, hpadding: 12, bg:
  colorLight('#EDC690', 50), box: true, matop: 4, rounding: 10, patop: 10,
  pabottom: 10, hmax: `calc( 100vh - 250px )`, 'overflow-y': 'auto', w: 260 },
  null, html); \r

  \    UI.dHistoryParent = dParent;\r

  \    UI.dHistory = dHistory;\r

  \    if (isdef(Clientdata.historyLayout)) {
  show_history_layout(Clientdata.historyLayout); }\r

  \  }\r

  }"
show_history_layout: "function show_history_layout(layout) {\r

  \  assertion(isdef(UI.dHistoryParent) && isdef(UI.dHistory),
  'UI.dHistoryParent && UI.dHistory do NOT exist!!!');\r

  \  if (layout == 'ph') PHLayout();\r

  \  else if (layout == 'hp') HPLayout();\r

  \  else if (layout == 'prh') PRHLayout();\r

  \  else if (layout == 'hrp') HRPLayout();\r

  \  else PHLayout();\r

  }"
show_history_popup: "function show_history_popup() {\r

  \  if (isEmpty(Z.fen.history)) return;\r

  \  assertion(isdef(UI.dHistoryParent) && isdef(UI.dHistory),
  'UI.dHistoryParent && UI.dHistory do NOT exist!!!');\r

  \  let l = valf(Clientdata.historyLayout, 'ph');\r

  \  let cycle = ['ph', 'hp', 'prh', 'hrp'];\r

  \  let i = (cycle.indexOf(l) + 1) % cycle.length;\r

  \  show_history_layout(cycle[i]);\r

  }"
show_home_logo: "function show_home_logo() {\r

  \  let bg = colorLight();\r

  \  let dParent = mBy('dAdminLeft');\r

  \  clearElement(dParent);\r

  \  let d = miPic('castle', dParent, { cursor: 'pointer', fz: 24, padding: 6,
  h: 36, box: true, margin: 2 }); \r

  \  d.onclick = onclick_home;\r

  \  let version = 'v0.0.1';\r

  \  let html = `version ${version}`\r

  \  mText(html, dParent, { fz: 12 });\r

  }"
show_hourglass: "function show_hourglass(uname, d, sz, stylesPos = {}) {\r

  \  let html = get_waiting_html(sz);\r

  \  mStyle(d, { position: 'relative' });\r

  \  addKeys({ position: 'absolute' }, stylesPos);\r

  \  let dw = mDiv(d, stylesPos, `dh_${uname}`, html);\r

  }"
show_instruction: function show_instruction(msg) { mBy('dSelections0').innerHTML = msg; }
show_message: "function show_message(msg = '', stay = false) {\r

  \  mStyle(dTable, { transition: 'all 1s ease' });\r

  \  let d = mBy('dMessage'); d.innerHTML = msg;\r

  \  if (stay) return;\r

  \  let ms = 1000, delay = 3000;\r

  \  let anim = d.animate([{ transform: `scale(1,1)`, opacity: 1 }, {
  transform: `scale(1,0)`, opacity: 0 },], { duration: 1000, easing: 'ease',
  delay: delay });\r

  \  dTable.animate([{ transform: 'translateY(0px)' }, { transform:
  'translateY(-56px)' },], { fill: 'none', duration: ms, easing: 'ease', delay:
  delay });\r

  \  anim.onfinish = () => {\r

  \    mClear(d);\r

  \  }\r

  }"
show_MMM: function show_MMM(msg) { show_fleeting_message(msg, mBy('dMMM')); }
show_options_popup: "function show_options_popup(options) {\r

  \  let opresent = {};\r

  \  let di = { mode: 'gamemode', yes: true, no: false };\r

  \  let keys = get_keys(options);\r

  \  keys.sort();\r

  \  for (const k of get_keys(options).sort()) {\r

  \    let key = valf(di[k], k);\r

  \    let val = valf(di[options[k]], options[k]);\r

  \    opresent[key] = val;\r

  \  }\r

  \  let x = mYaml(mCreate('div'), opresent);\r

  \  let dpop = mPopup(x.innerHTML, dTable, { fz: 16, fg: 'white', top: 0,
  right: 0, border: 'white', padding: 10, bg: 'dimgray' }, 'dOptions');\r

  \  mInsert(dpop, mCreateFrom(`<div
  style=\"text-align:center;width:100%;font-family:Algerian;font-size:22px;\">$\
  {Z.game}</div>`));\r

  }"
show_player_button: "function show_player_button(caption, ui_item, handler) {\r

  \  let d = ui_item.container ?? iDiv(ui_item);\r

  \  let styles = { rounding: 6, bg: 'silver', fg: 'black', border: 0, maleft:
  10 };\r

  \  let b = mButton(caption, handler, d, styles, 'enabled');\r

  \  return b;\r

  }"
show_playerdatastate: "function show_playerdatastate() {\r

  \  for (const pldata of Z.playerdata) {\r

  \    console.log('player', pldata.name,
  `status=${isEmpty(pldata.player_status) ? 'none' : pldata.player_status}`,
  pldata.state);\r

  \  }\r

  }"
show_polling_signal: "function show_polling_signal() {\r

  \  if (DA.TEST0 != true) return;\r

  \  let d1 = mDiv(mBy('dAdmin'), { position: 'fixed', top: 10, left: 73 });\r

  \  let bg = Z.skip_presentation == true ? 'grey' : 'green'; \r

  \  let d2 = mDiv(d1, { width: 20, height: 20, bg: bg, rounding: 10, display:
  'inline-block' });\r

  \  mFadeRemove(d1, 1000);\r

  }"
show_progress: "function show_progress() {\r

  \  if (isdef(Z.fen.progress)) {\r

  \    let d = mBy('dTitleLeft');\r

  \    let former = mBy('dProgress');\r

  \    if (isdef(former)) former.remove();\r

  \    let dprogress = mDiv(d, {}, 'dProgress',
  `<div>${Z.fen.progress}</div>`);\r

  \  }\r

  }"
show_role: "function show_role() {\r

  \  if (Z.game == 'accuse'){show_role_accuse(); return;}\r

  \  let d = mBy('dAdminMiddle');\r

  \  clearElement(d);\r

  \  let hotseatplayer = Z.uname != Z.uplayer && Z.mode == 'hotseat' && Z.host
  == Z.uname;\r

  \  let styles, text;\r

  \  let boldstyle = { fg: 'red', weight: 'bold', fz: 20 };\r

  \  let normalstyle = { fg: 'black', weight: null, fz: null };\r

  \  let location = ''; \r

  \  if (hotseatplayer) {\r

  \    styles = boldstyle;\r

  \    text = `your turn for ${Z.uplayer}`;\r

  \  } else if (Z.role == 'spectator') {\r

  \    styles = normalstyle;\r

  \    text = `(spectating)`;\r

  \  } else if (Z.role == 'active') {\r

  \    styles = boldstyle;\r

  \    text = `It's your turn!!!`;\r

  \  } else if (Z.role == 'waiting') {\r

  \    text = `waiting for players to complete their moves...`;\r

  \  } else {\r

  \    assertion(Z.role == 'inactive', 'role is not active or inactive or
  spectating ' + Z.role);\r

  \    styles = normalstyle;\r

  \    text = `(${Z.turn[0]}'s turn)`;\r

  \  }\r

  \  d.innerHTML = location + text;\r

  \  mStyle(d, styles);\r

  }"
show_settings: "function show_settings(dParent) {\r

  \  let [options, fen, uplayer] = [Z.options, Z.fen, Z.uplayer];\r

  \  clearElement(dParent);\r

  \  mFlex(dParent);\r

  \  mStyle(dParent, { 'justify-content': 'end', gap: 12, paright: 10 })\r

  \  let playmode = get_playmode(uplayer); \r

  \  let game_mode = Z.mode;\r

  \  let st = { fz: 20, padding: 0, h: 40, box: true, matop: 2, rounding:
  '50%', cursor: 'pointer' };\r

  \  let dHistoryButton = miPic('scroll', dParent, st);\r

  \  dHistoryButton.onclick = show_history_popup;\r

  \  if (isdef(Config.games[Z.game].options.strategy)) {\r

  \    let dStrategy = miPic('chess pawn', dParent, st);\r

  \    dStrategy.onclick = show_strategy_popup;\r

  \  }\r

  \  let d = miPic('gear', dParent, st);\r

  \  options.playmode = playmode;\r

  \  d.onmouseenter = () => show_options_popup(options);\r

  \  d.onmouseleave = hide_options_popup;\r

  }"
show_status: "function show_status(s) {\r

  \  if (is_advanced_user()) {\r

  \    clear_status();\r

  \    if (!TESTING && !s.includes('reload')) show_fleeting_message(s,
  'dTest', { fz: 14, position: 'absolute', top: 5, right: 10 }, 'dStatus');\r

  \  }\r

  }"
show_strategy_popup: "function show_strategy_popup() {\r

  \  let dpop = mPopup('', dTable, { fz: 16, fg: 'white', top: 0, right: 0,
  border: 'white', padding: 10, bg: 'dimgray' }, 'dOptions');\r

  \  mAppend(dpop, mCreateFrom(`<div
  style=\"text-align:center;width:100%;font-family:Algerian;font-size:22px;\">$\
  {Z.game}</div>`));\r

  \  mDiv(dpop, { matop: 5, maleft: 10 }, null, `choose strategy:`);\r

  \  let vals = Config.games[Z.game].options.strategy.split(',');\r

  \  let key = 'strategy';\r

  \  let fs = mRadioGroup(dpop, { fg: 'white' }, `d_${key}`); \r

  \  for (const v of vals) { mRadio(v, isNumber(v) ? Number(v) : v, key, fs, {
  cursor: 'pointer' }, set_player_strategy, key, v == Z.strategy); }\r

  \  measure_fieldset(fs);\r

  }"
show_tables: "function show_tables(ms = 500) {\r

  \  clear_screen();\r

  \  let dParent = mBy('dTables');\r

  \  mClear(dParent);\r

  \  show_games();\r

  \  let tables = Serverdata.tables;\r

  \  if (isEmpty(tables)) { mText('no active game tables', dParent); return
  []; }\r

  \  tables.map(x => x.game_friendly = Config.games[x.game].friendly);\r

  \  mText(`<h2>game tables</h2>`, dParent, { maleft: 12 })\r

  \  let t = mDataTable(tables, dParent, null, ['friendly', 'game_friendly',
  'players'], 'tables', false);\r

  \  mTableCommandify(t.rowitems, {\r

  \    0: (item, val) => hFunc(val, 'onclick_table', val, item.id),\r

  \  });\r

  \  let d = iDiv(t);\r

  \  for (const ri of t.rowitems) {\r

  \    let r = iDiv(ri);\r

  \    let h = hFunc('delete', 'delete_table', ri.o.friendly);\r

  \    c = mAppend(r, mCreate('td'));\r

  \    c.innerHTML = h;\r

  \  }\r

  }"
show_title: "function show_title() {\r

  \  settingsOn = Z.func.state_info(mBy('dTitleLeft'));\r

  \  if (nundef(settingsOn) || settingsOn)
  show_settings(mBy('dTitleRight'));\r

  \  mBy('dTablename').innerHTML = Z.friendly;\r

  }"
show_username: "function show_username(loadTable = false) {\r

  \  let uname = U.name;\r

  \  let dpic = get_user_pic(uname, 30);\r

  \  let d = mBy('dAdminRight');\r

  \  mClear(d);\r

  \  if (['felix','mimi','lauren','amanda'].includes(uname))
  add_advanced_ui(d); \r

  \  mAppend(d, get_logout_button());\r

  \  mAppend(d, dpic);\r

  \  if (is_advanced_user()) { show('dAdvanced1'); } else { hide('dAdvanced');
  hide('dAdvanced1'); }\r

  \  if (!TESTING && !DA.running) {\r

  \    if (!loadTable) phpPost({ app: 'easy' }, 'tables'); \r

  \    else if (!isEmpty(Serverdata.tables)) {\r

  \      onclick_table(Serverdata.tables[0].friendly);\r

  \    }\r

  \  }\r

  }"
show_users: "function show_users(ms = 300) {\r

  \  let dParent = mBy('dUsers');\r

  \  mClear(dParent);\r

  \  for (const u of Serverdata.users) {\r

  \    if (['ally', 'bob', 'leo'].includes(u.name)) continue;\r

  \    let d = get_user_pic_and_name(u.name, dParent);\r

  \    d.onclick = () => onclick_user(u.name);\r

  \    mStyle(d, { cursor: 'pointer' });\r

  \  }\r

  \  mFall(dParent, ms);\r

  }"
show_view_buildings_button: "function show_view_buildings_button(plname) {\r

  \  if (Z.role == 'spectator' || isdef(mBy('dPlayerButtons'))) return;\r

  \  if (isEmpty(UI.players[plname].buildinglist)) return;\r

  \  let d1 = iDiv(UI.players[plname]); mStyle(d1, { position: 'relative'
  });\r

  \  let d2 = mDiv(d1, { position: 'absolute', top: 8, left: 50, height: 25 },
  'dPlayerButtons');\r

  \  show_player_button('view buildings', d2, onclick_view_buildings);\r

  }"
show_waiting_for_ack_message: "function show_waiting_for_ack_message() {\r

  \  let dInstruction = mBy('dSelections0');\r

  \  mClass(dInstruction, 'instruction');\r

  \  mCenterCenterFlex(dInstruction);\r

  \  mBy('dSelections0').innerHTML = 'waiting for next round to start...'; \r

  }"
show_waiting_message: "function show_waiting_message(msg) {\r

  \  let dInstruction = mBy('dSelections0');\r

  \  mClass(dInstruction, 'instruction');\r

  \  mCenterCenterFlex(dInstruction);\r

  \  mBy('dSelections0').innerHTML = msg;\r

  }"
show_winners: "function show_winners() {\r

  \  let winners = Z.fen.winners;\r

  \  let multiple_winners = winners.length > 1;\r

  \  let winners_html = winners.map(x => get_user_pic_html(x, 35)).join('
  ');\r

  \  let msg = `\r

  \    <div style=\"display:flex;gap:10px;align-items:center\">\r

  \      <div style=\"color:red;font-size:22px;font-weight:bold;\">GAME OVER!
  the winner${multiple_winners ? 's are: ' : ' is '}</div>\r

  \      <div style=\"padding-top:5px;\">${winners_html}</div>\r

  \    </div>\r

  \  `;\r

  \  show_message(msg, true);\r

  \  mShield(dTable);\r

  \  hide('bRestartMove');\r

  \  return Z.fen.winners;\r

  }"
shuffletest: "function shuffletest(list) {\r

  \  for (let i = 0; i < 100; i++) {\r

  \    shuffle(list);\r

  \    console.log('shuffle: ' + jsCopy(list));\r

  \  }\r

  }"
simpleCompare: "function simpleCompare(o1, o2) {\r

  \  let s1 = object2string(o1);\r

  \  let s2 = object2string(o2);\r

  \  return s1 == s2;\r

  }"
sss: function sss() { show_playerdatastate(); }
sss1: "function sss1() {\r

  \  let [fen, A, uplayer, plorder, data] = [Z.fen, Z.A, Z.uplayer, Z.plorder,
  Z.uplayer_data];\r

  \  let s = 'no data.state for player ' + uplayer;\r

  \  if (isDict(data.state)) {\r

  \    s = `${uplayer} passes `;\r

  \    for (const k in data.state.di) {\r

  \      s += `${k} ${data.state.di[k]}, `;\r

  \    }\r

  \  }\r

  \  console.log(s);\r

  }"
start: "function start() {\r

  \  let uname = DA.secretuser = localStorage.getItem('uname');\r

  \  if (isdef(uname)) U = { name: uname };\r

  \  phpPost({ app: 'simple' }, 'assets');\r

  }"
start_game_with_players: "function start_game_with_players(n, game = 'accuse',
  opts = {}) {\r

  \  let numplayers = n;\r

  \  let list = jsCopy(Serverdata.users).map(x => x.name);\r

  \  removeInPlace(list, 'mimi');\r

  \  removeInPlace(list, 'felix');\r

  \  let playernames = rChoose(list, numplayers - 2);\r

  \  playernames = ['mimi', 'felix'].concat(playernames);\r

  \  let uname = U.name;\r

  \  removeInPlace(playernames,uname);\r

  \  playernames.unshift(uname);\r

  \  let playmodes = playernames.map(x => 'human');\r

  \  let players = [];\r

  \  for (let i = 0; i < n; i++) players.push({ name: playernames[i],
  playmode: playmodes[i] });\r

  \  addKeys({ mode: 'multi' }, opts);\r

  \  startgame(game, players, opts);\r

  }"
start_with_assets: "function start_with_assets(reload = false) {\r

  \  DA.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  if (DA.isFirefox) console.log('using Firefox!')\r

  \  show_home_logo();\r

  \  if (nundef(U)) { show_users(); return; }\r

  \  show_username(reload);\r

  \  if (DA.TEST0 || DA.showTestButtons) show('dTestButtons');\r

  \  //#region TESTING\r

  \  //#endregion\r

  }"
startgame: "function startgame(game, players, options = {}) {\r

  \  if (nundef(game)) game = 'a_game';\r

  \  let default_options = {}; for (const k in Config.games[game].options)
  default_options[k] = arrLast(Config.games[game].options[k].split(','));\r

  \  addKeys(default_options, options); \r

  \  if (nundef(players)) players = rChoose(Serverdata.users, 2).map(x => ({
  name: x.name })); \r

  \  let playernames = players.map(x => x.name);\r

  \  let fen = window[game]().setup(playernames, options);\r

  \  if (nundef(fen.round)) fen.round = 1;\r

  \  if (nundef(fen.phase)) fen.phase = '';\r

  \  if (nundef(fen.stage)) fen.stage = 0;\r

  \  if (nundef(fen.step)) fen.step = 0;\r

  \  if (nundef(fen.turn)) fen.turn = [fen.plorder[0]]; else if (DA.TESTSTART1
  && fen.turn.length == 1) fen.turn = [playernames[0]];\r

  \  players.map(x => { let pl = fen.players[x.name]; pl.playmode =
  valf(x.playmode, 'human'); pl.strategy = valf(x.strategy,
  valf(options.strategy, 'random')); });\r

  \  if (options.mode == 'solo') {\r

  \    let me = isdef(U) && isdef(fen.players[U.name]) ? U.name :
  rChoose(playernames);\r

  \    for (const plname of playernames) {\r

  \      if (plname == me) continue;\r

  \      fen.players[plname].playmode = 'bot';\r

  \    }\r

  \    options.mode = 'hotseat';\r

  \  }\r

  \  for (const k in options) { if (isNumber(options[k])) options[k] =
  parseInt(options[k]); }\r

  \  let o = {\r

  \    friendly: generate_table_name(players.length), game: game, host:
  playernames[0], players: playernames,\r

  \    fen: fen, options: options\r

  \  };\r

  \  ensure_polling(); \r

  \  phpPost(o, 'startgame');\r

  }"
staticTitle: "function staticTitle() {\r

  \  clearInterval(TO.titleInterval);\r

  \  let url = window.location.href;\r

  \  let loc = url.includes('telecave') ? 'telecave' : 'local';\r

  \  let game = isdef(Z) ? stringAfter(Z.friendly, 'of ') : ' GAMES ';\r

  \  document.title = `(${loc}) ${game}`;\r

  }"
status_message_new: "function status_message_new(msg, dParent, styles = {}) {\r

  }"
stopgame: "function stopgame() {\r

  \  if (!DA.running) return;\r

  \  DA.running = false;\r

  \  DA.noshow = 0;\r

  \  clear_timeouts();\r

  \  hide('bRestartMove');\r

  \  hide('dHostButtons');\r

  \  mStyle('dAdmin', { bg: 'white' });\r

  \  mClear('dAdminMiddle')\r

  \  for (const id of ['bSpotitStart', 'bClearAck', 'bRandomMove',
  'bSkipPlayer']) hide(id);\r

  \  pollStop();\r

  \  Z = null; delete Serverdata.table; delete Serverdata.playerdata;
  Clientdata = {};\r

  \  staticTitle();\r

  }"
switch_uname: "function switch_uname(plname) {\r

  \  set_user(plname);\r

  \  show_username();\r

  }"
tableLayoutMR: "function tableLayoutMR(dParent, m = 7, r = 1) {\r

  \  let ui = UI; ui.players = {};\r

  \  clearElement(dParent);\r

  \  let bg = 'transparent';\r

  \  let [dMiddle, dRechts] = [ui.dMiddle, ui.dRechts] = mColFlex(dParent, [m,
  r], [bg, bg]);\r

  \  mCenterFlex(dMiddle, false); \r

  \  let dOben = ui.dOben = mDiv(dMiddle, { w: '100%', display: 'block' },
  'dOben');\r

  \  let dSelections = ui.dSelections = mDiv(dOben, {}, 'dSelections');\r

  \  for (let i = 0; i <= 5; i++) { ui[`dSelections${i}`] = mDiv(dSelections,
  {}, `dSelections${i}`); }\r

  \  let dActions = ui.dActions = mDiv(dOben, { w: '100%' });\r

  \  for (let i = 0; i <= 5; i++) { ui[`dActions${i}`] = mDiv(dActions, { w:
  '100%' }, `dActions${i}`); }\r

  \  ui.dError = mDiv(dOben, { w: '100%', bg: 'red', fg: 'yellow', hpadding:
  12, box: true }, 'dError');\r

  \  let dSubmitOrRestart = ui.dSubmitOrRestart = mDiv(dOben, { w: '100%'
  });\r

  \  let dOpenTable = ui.dOpenTable = mDiv(dMiddle, { w: '100%', padding: 10
  }); mFlexWrap(dOpenTable);\r

  \  return [dOben, dOpenTable, dMiddle, dRechts];\r

  }"
take_feedback_host: "function take_feedback_host(write_fen = true, write_player
  = false, clear_players = false, player_status = null) {\r

  \  prep_move();\r

  \  let o = { uname: Z.uplayer, friendly: Z.friendly };\r

  \  if (isdef(Z.fen)) o.fen = Z.fen;\r

  \  if (write_fen) { assertion(isdef(Z.fen) && isdef(Z.fen.turn), 'write_fen
  without fen!!!!'); o.write_fen = true; }\r

  \  if (write_player) { o.write_player = true; o.state = Z.state; } \r

  \  if (clear_players) o.clear_players = true;\r

  \  o.player_status = player_status;\r

  \  o.auto = true;\r

  \  let cmd = 'table';\r

  \  send_or_sim(o, cmd);\r

  }"
take_turn: "function take_turn(write_fen = true, write_player = false,
  clear_players = false, player_status = null) {\r

  \  prep_move();\r

  \  let o = { uname: Z.uplayer, friendly: Z.friendly };\r

  \  if (isdef(Z.fen)) o.fen = Z.fen;\r

  \  if (write_fen) { assertion(isdef(Z.fen) && isdef(Z.fen.turn), 'write_fen
  without fen!!!!'); o.write_fen = true; }\r

  \  if (write_player) {\r

  \    o.write_player = true;\r

  \    if (isdef(Z.state)) o.state = Z.state;\r

  \    if (isdef(Z.state1)) o.state1 = Z.state1;\r

  \    if (isdef(Z.state2)) o.state2 = Z.state2;\r

  \  }\r

  \  if (clear_players) {\r

  \    o.clear_players = true; delete Z.playerdata; delete o.fen.pldata;\r

  \  }\r

  \  o.player_status = player_status;\r

  \  let cmd = 'table';\r

  \  send_or_sim(o, cmd);\r

  }"
take_turn_fen: function take_turn_fen() { take_turn(); }
take_turn_fen_clear: function take_turn_fen_clear() { take_turn(true, false, true); }
take_turn_fen_write: function take_turn_fen_write() { take_turn(true, true); }
take_turn_multi: function take_turn_multi() { if (isdef(Z.state))
  take_turn(false, true); else take_turn(false, false); }
take_turn_spotit: function take_turn_spotit() { take_turn(true, true); }
take_turn_state1: function take_turn_state1() { if (isdef(Z.state1))
  take_turn(false, true); else take_turn(false, false); }
take_turn_state2: function take_turn_state2() { if (isdef(Z.state2))
  take_turn(false, true); else take_turn(false, false); }
take_turn_waiting: function take_turn_waiting() { take_turn(true, false, false, null); }
take_turn_write: function take_turn_write() { take_turn_multi(); }
ui_player_info: "function ui_player_info(dParent, outerStyles = { dir: 'column'
  }, innerStyles = {}) {\r

  \  let fen = Z.fen;\r

  \  if (nundef(outerStyles.display)) outerStyles.display = 'flex';\r

  \  mStyle(dParent, outerStyles);\r

  \  let items = {};\r

  \  let styles = jsCopy(innerStyles); addKeys({ rounding: 10, bg:
  '#00000050', margin: 4, padding: 4, patop: 12, box: true, 'border-style':
  'solid', 'border-width': 6 }, styles);\r

  \  let order = get_present_order();\r

  \  for (const plname of order) {\r

  \    let pl = fen.players[plname];\r

  \    let uname = pl.name;\r

  \    let imgPath = `../base/assets/images/${uname}.jpg`;\r

  \    styles['border-color'] = get_user_color(uname);\r

  \    let item = mDivItem(dParent, styles, name2id(uname));\r

  \    let d = iDiv(item);\r

  \    let picstyle = { w: 50, h: 50, box: true };\r

  \    let ucolor = get_user_color(uname);\r

  \    if (pl.playmode == 'bot') {\r

  \      copyKeys({ rounding: 0, border: `double 6px ${ucolor}` },
  picstyle);\r

  \    } else {\r

  \      copyKeys({ rounding: '50%', border: `solid 2px white` }, picstyle);\r

  \    }\r

  \    let img = mImage(imgPath, d, picstyle, 'img_person');\r

  \    items[uname] = item;\r

  \  }\r

  \  if (DA.SIMSIM || is_advanced_user()) activate_playerstats(items)\r

  \  return items;\r

  }"
_calc_hex_col_array: "function _calc_hex_col_array(rows, cols) {\r

  \  let colarr = []; \r

  \  let even = rows % 2 == 0;\r

  \  for (let i = 0; i < rows; i++) {\r

  \    colarr[i] = cols;\r

  \    if (even && i < (rows / 2) - 1) cols += 1;\r

  \    else if (even && i > rows / 2) cols -= 1;\r

  \    else if (!even && i < (rows - 1) / 2) cols += 1;\r

  \    else if (!even || i >= (rows - 1) / 2) cols -= 1;\r

  \  }\r

  \  return colarr;\r

  }"
_calc_hex_col_array_old: "function _calc_hex_col_array_old(rows, cols) {\r

  \  let colarr = []; \r

  \  for (let i = 0; i < rows; i++) {\r

  \    colarr[i] = cols;\r

  \    if (i < (rows - 1) / 2) cols += 1;\r

  \    else cols -= 1;\r

  \  }\r

  \  return colarr;\r

  }"
addRowsCols: "function addRowsCols(items) {\r

  \  let byrc = {};\r

  \  let byx = sortBy(items, 'x');\r

  \  let c = 0, x = byx[0].x;\r

  \  for (let i = 0; i < byx.length; i++) {\r

  \    let item = byx[i];\r

  \    if (!isCloseTo(item.x, x, 2)) { c += 1; x = item.x; }\r

  \    item.col = c;\r

  \  }\r

  \  let byy = sortBy(items, 'y');\r

  \  let r = 0, y = byy[0].y;\r

  \  for (let i = 0; i < byy.length; i++) {\r

  \    let item = byy[i];\r

  \    if (!isCloseTo(item.y, y, 2)) { r += 1; y = item.y; }\r

  \    item.row = r;\r

  \    lookupSet(byrc, [item.row, item.col], item);\r

  \  }\r

  \  return byrc;\r

  }"
anim1: "function anim1(elem, prop, from, to, ms) {\r

  \  if (prop == 'left') elem.style.position = 'absolute';\r

  \  if (isNumber(from)) from = '' + from + 'px';\r

  \  if (isNumber(to)) to = '' + to + 'px';\r

  }"
applyStyles: "function applyStyles(g, id, styles) { g.mStyle(id, styles,
  isdef(g.getNode(id)) ? 'node' : 'edge'); }"
ari_deck_add_safe: "function ari_deck_add_safe(otree, n, arr) {\r

  \  ari_ensure_deck(otree, n);\r

  \  deck_add(otree.deck, n, arr);\r

  }"
aristoUi: "function aristoUi(dParent, g) {\r

  \  clearTable();\r

  \  let d1 = mDiv(dParent, { w: '100%' }); mFlex(d1, 'v');\r

  \  let dWorld = mDiv(d1, { bg: 'random', hmin: 170, flex: 1 });\r

  \  mFlex(dWorld);\r

  \  iAdd(g.me, { div: cardZone(d1, g.me, 2) });\r

  \  let others = g.others;\r

  \  for (let i = 0; i < others.length; i++) {\r

  \    let pl = others[i];\r

  \    iAdd(pl, { div: cardZone(d1, pl) });\r

  \  }\r

  \  for (const o of [g.draw_pile, g.market, g.buy_cards, g.discard_pile]) {
  iAdd(o, { div: cardZone(dWorld, o) }); }\r

  \  for (const name of ['draw_pile', 'market', 'buy_cards', 'discard_pile'])
  { g[name + 'Items'] = showCards(g[name]); }\r

  \  for (const pl of g.allPlayers) {\r

  \    pl.handItems = showCards({ div: iDiv(pl), type: pl == g.me ? 'hand' :
  'handHidden', cards: pl.hand });\r

  \    if (isdef(pl.stall)) pl.stallItems = showCards({ div: iDiv(pl), type:
  g.stallsHidden ? 'cardsHidden' : 'cards', cards: pl.stall });\r

  \    if (isdef(pl.buildings)) {\r

  \      for (const building of pl.buildings) {\r

  \        let bItem = showCards({ div: iDiv(pl), type: 'hand', cards:
  building });\r

  \        lookupAddToList(pl, ['buildingItems'], bItem);\r

  \      }\r

  \    }\r

  \  }\r

  }"
arrToMatrix: "function arrToMatrix(arr, rows, cols) {\r

  \  let i = 0, res = [];\r

  \  for (let r = 0; r < rows; r++) {\r

  \    let rarr = [];\r

  \    for (let c = 0; c < cols; c++) {\r

  \      let a = arr[i]; i++;\r

  \      rarr.push(a);\r

  \    }\r

  \    res.push(rarr);\r

  \  }\r

  \  return res;\r

  }"
bCapturedPieces: "function bCapturedPieces(plSym, arr, idx, rows, cols,
  includeDiagonals = true) {\r

  \  let res = [];\r

  \  let nei = bNei(arr, idx, rows, cols, includeDiagonals);\r

  \  for (let dir = 0; dir < 8; dir++) {\r

  \    let i = nei[dir];\r

  \    if (nundef(i)) continue;\r

  \    let el = arr[i];\r

  \    if (EmptyFunc(el) || el == plSym) continue;\r

  \    let inew = [];\r

  \    let MAX = 100, cmax = 0;\r

  \    while (isOppPiece(el, plSym)) {\r

  \      if (cmax > MAX) break; cmax += 1;\r

  \      inew.push(i);\r

  \      i = bNeiDir(arr, i, dir, rows, cols);\r

  \      if (nundef(i)) break;\r

  \      el = arr[i];\r

  \    }\r

  \    if (el == plSym) {\r

  \      res = res.concat(inew);\r

  \    }\r

  \  }\r

  \  return res;\r

  }"
bCheck: "function bCheck(r, c, rows, cols) { return r >= 0 && r < rows && c >= 0
  && c < cols ? r * cols + c : null; }"
bCreateEmpty: function bCreateEmpty(rows, cols) { return new Array(rows * cols).fill(null); }
bFreeRayDir: "function bFreeRayDir(arr, idx, dir, rows, cols) {\r

  \  let indices = [];\r

  \  let i = idx;\r

  \  while (i < arr.length) {\r

  \    i = bNeiDir(arr, i, dir, rows, cols);\r

  \    if (!i || !EmptyFunc(arr[i])) break; else indices.push(i);\r

  \  }\r

  \  return indices;\r

  }"
bFreeRayDir1: "function bFreeRayDir1(arr, idx, dir, rows, cols) {\r

  \  let indices = [];\r

  \  let i = idx;\r

  \  while (i < arr.length) {\r

  \    i = bNeiDir(arr, i, dir, rows, cols);\r

  \    if (!i) break;\r

  \    else indices.push(i);\r

  \    if (!EmptyFunc(arr[i])) break;\r

  \  }\r

  \  return indices;\r

  }"
bFullCol: "function bFullCol(arr, icol, rows, cols) {\r

  \  let iStart = icol;\r

  \  let x = arr[iStart]; if (EmptyFunc(x)) return null;\r

  \  for (let i = iStart + cols; i < iStart + (cols * rows); i += cols) if
  (arr[i] != x) return null;\r

  \  return x;\r

  }"
bFullDiag: "function bFullDiag(arr, rows, cols) {\r

  \  let iStart = 0;\r

  \  let x = arr[iStart]; if (EmptyFunc(x)) return null;\r

  \  for (let i = iStart + cols + 1; i < arr.length; i += cols + 1) { if
  (arr[i] != x) return null; }\r

  \  return x;\r

  }"
bFullDiag2: "function bFullDiag2(arr, rows, cols) {\r

  \  let iStart = cols - 1;\r

  \  let x = arr[iStart]; if (EmptyFunc(x)) return null;\r

  \  for (let i = iStart + cols - 1; i < arr.length - 1; i += cols - 1) { if
  (arr[i] != x) return null; }\r

  \  return x;\r

  }"
bFullRow: "function bFullRow(arr, irow, rows, cols) {\r

  \  let iStart = irow * cols;\r

  \  let x = arr[iStart]; if (EmptyFunc(x)) return null;\r

  \  for (let i = iStart + 1; i < iStart + cols; i++) if (arr[i] != x) return
  null;\r

  \  return x;\r

  }"
bGetChunks: "function bGetChunks(arr2d, rowsEach, colsEach) {\r

  \  let res = [];\r

  \  let [rTotal, cTotal] = [arr2d.length, arr2d[0].length];\r

  \  for (let r = 0; r < rTotal; r += rowsEach) {\r

  \    let m1 = [];\r

  \    for (let c = 0; c < cTotal; c += colsEach) {\r

  \      m1 = bGetSubMatrix(arr2d, r, rowsEach, c, colsEach);\r

  \      res.push(arrFlatten(m1));\r

  \    }\r

  \  }\r

  \  return res;\r

  }"
bGetChunksWithIndices: "function bGetChunksWithIndices(arr2d, rowsEach,
  colsEach) {\r

  \  let res = [];\r

  \  let [rTotal, cTotal] = [arr2d.length, arr2d[0].length];\r

  \  for (let r = 0; r < rTotal; r += rowsEach) {\r

  \    let m1 = [];\r

  \    for (let c = 0; c < cTotal; c += colsEach) {\r

  \      m1 = bGetSubMatrixWithIndices(arr2d, r, rowsEach, c, colsEach);\r

  \      res.push(arrFlatten(m1));\r

  \    }\r

  \  }\r

  \  return res;\r

  }"
bGetCol: "function bGetCol(arr, icol, rows, cols) {\r

  \  let iStart = icol;\r

  \  let res = [];\r

  \  for (let i = iStart; i < iStart + (cols * rows); i += cols)
  res.push(arr[i]);\r

  \  return res;\r

  }"
bGetCols: "function bGetCols(arr2d) {\r

  \  let rows = arr2d.length;\r

  \  let cols = arr2d[0].length;\r

  \  let res = [];\r

  \  for (let c = 0; c < cols; c++) { res.push([]); }\r

  \  for (let r = 0; r < rows; r++) {\r

  \    for (let c = 0; c < cols; c++) {\r

  \      res[c].push(arr2d[r][c]);\r

  \    }\r

  \  }\r

  \  return res;\r

  }"
bGetRow: "function bGetRow(arr, irow, rows, cols) {\r

  \  let iStart = irow * cols;\r

  \  let arrNew = arr.slice(iStart, iStart + cols);\r

  \  let res = [];\r

  \  for (let i = iStart; i < iStart + cols; i++) res.push(arr[i]);\r

  \  console.assert(sameList(arrNew, res), 'NOOOOOO');\r

  \  return res;\r

  }"
bGetRows: "function bGetRows(arr2d) {\r

  \  return arr2d;\r

  }"
bGetSubMatrix: "function bGetSubMatrix(arr2d, rFrom, rows, cFrom, cols) {\r

  \  let res = []; for (let i = 0; i < rows; i++) res.push([]);\r

  \  let [rTotal, cTotal] = [arr2d.length, arr2d[0].length];\r

  \  let rIndex = 0;\r

  \  for (let r = rFrom; r < rFrom + rows; r++) {\r

  \    for (let c = cFrom; c < cFrom + cols; c++) {\r

  \      res[rIndex].push(arr2d[r][c]);\r

  \    }\r

  \    rIndex += 1;\r

  \  }\r

  \  return res;\r

  }"
bGetSubMatrixWithIndices: "function bGetSubMatrixWithIndices(arr2d, rFrom, rows,
  cFrom, cols) {\r

  \  let res = []; for (let i = 0; i < rows; i++) res.push([]);\r

  \  let [rTotal, cTotal] = [arr2d.length, arr2d[0].length];\r

  \  let rIndex = 0;\r

  \  for (let r = rFrom; r < rFrom + rows; r++) {\r

  \    for (let c = cFrom; c < cFrom + cols; c++) {\r

  \      res[rIndex].push({ row: r, col: c, val: arr2d[r][c] });\r

  \    }\r

  \    rIndex += 1;\r

  \  }\r

  \  return res;\r

  }"
bNei: "function bNei(arr, idx, rows, cols, includeDiagonals = true) {\r

  \  let nei = [];\r

  \  let [r, c] = iToRowCol(idx, rows, cols);\r

  \  if (r > 0) nei.push(idx - cols); else nei.push(null);\r

  \  if (r > 0 && c < cols - 1 && includeDiagonals) nei.push(idx - cols + 1);
  else nei.push(null);\r

  \  if (c < cols - 1) nei.push(idx + 1); else nei.push(null);\r

  \  if (r < rows - 1 && c < cols - 1 && includeDiagonals) nei.push(idx + cols
  + 1); else nei.push(null);\r

  \  if (r < rows - 1) nei.push(idx + cols); else nei.push(null);\r

  \  if (r < rows - 1 && c > 0 && includeDiagonals) nei.push(idx + cols - 1);
  else nei.push(null);\r

  \  if (c > 0) nei.push(idx - 1); else nei.push(null);\r

  \  if (r > 0 && c > 0 && includeDiagonals) nei.push(idx - cols - 1); else
  nei.push(null);\r

  \  return nei;\r

  }"
bNeiDir: "function bNeiDir(arr, idx, dir, rows, cols, includeDiagonals = true)
  {\r

  \  let [r, c] = iToRowCol(idx, rows, cols);\r

  \  switch (dir) {\r

  \    case 0: if (r > 0) return (idx - cols); else return (null);\r

  \    case 1: if (r > 0 && c < cols - 1 && includeDiagonals) return (idx -
  cols + 1); else return (null);\r

  \    case 2: if (c < cols - 1) return (idx + 1); else return (null);\r

  \    case 3: if (r < rows - 1 && c < cols - 1 && includeDiagonals) return
  (idx + cols + 1); else return (null);\r

  \    case 4: if (r < rows - 1) return (idx + cols); else return (null);\r

  \    case 5: if (r < rows - 1 && c > 0 && includeDiagonals) return (idx +
  cols - 1); else return (null);\r

  \    case 6: if (c > 0) return (idx - 1); else return (null);\r

  \    case 7: if (r > 0 && c > 0 && includeDiagonals) return (idx - cols -
  1); else return (null);\r

  \  }\r

  \  return null;\r

  }"
boardArrOmitFirstRowCol: "function boardArrOmitFirstRowCol(boardArr, rows, cols)
  {\r

  \  let res = [];\r

  \  for (let r = 1; r < rows; r++) {\r

  \    for (let c = 1; c < cols; c++) {\r

  \      let i = iFromRowCol(r, c, rows, cols);\r

  \      res.push(boardArr[i]);\r

  \    }\r

  \  }\r

  \  return res;\r

  }"
boardToNode: "function boardToNode(state) {\r

  \  let res = new Array();\r

  \  for (let i = 0; i < state.length; i++) {\r

  \    if (state[i] == null) res[i] = ' ';\r

  \    else res[i] = state[i];\r

  \  }\r

  \  return res;\r

  }"
bPartialCol: "function bPartialCol(arr, icol, rows, cols) {\r

  \  let iStart = icol;\r

  \  let x = null;\r

  \  for (let i = iStart; i < iStart + (cols * rows); i += cols) { if
  (EmptyFunc(arr[i])) continue; else if (EmptyFunc(x)) x = arr[i]; else if
  (arr[i] != x) return null; }\r

  \  return x;\r

  }"
bPartialDiag: "function bPartialDiag(arr, rows, cols) {\r

  \  let iStart = 0;\r

  \  let x = null;\r

  \  for (let i = iStart; i < arr.length; i += cols + 1) { if
  (EmptyFunc(arr[i])) continue; else if (EmptyFunc(x)) x = arr[i]; else if
  (arr[i] != x) return null; }\r

  \  return x;\r

  }"
bPartialDiag2: "function bPartialDiag2(arr, rows, cols) {\r

  \  let iStart = cols - 1;\r

  \  let x = null;\r

  \  for (let i = iStart; i < arr.length - 1; i += cols - 1) {\r

  \    if (EmptyFunc(arr[i])) continue; else if (EmptyFunc(x)) x = arr[i];
  else if (arr[i] != x) return null;\r

  \  }\r

  \  return x;\r

  }"
bPartialRow: "function bPartialRow(arr, irow, rows, cols) {\r

  \  let iStart = irow * cols;\r

  \  let x = null;\r

  \  for (let i = iStart; i < iStart + cols; i++) {\r

  \    if (EmptyFunc(arr[i])) continue;\r

  \    else if (EmptyFunc(x)) x = arr[i];\r

  \    else if (arr[i] != x) return null;\r

  \  }\r

  \  return x;\r

  }"
bRayDir: "function bRayDir(arr, idx, dir, rows, cols) {\r

  \  let indices = [];\r

  \  let i = idx;\r

  \  while (i < arr.length) {\r

  \    let i = bNeiDir(arr, i, dir, rows, cols);\r

  \    if (!i) break; else indices.push(i);\r

  \  }\r

  \  return indices;\r

  }"
bStrideCol: "function bStrideCol(arr, icol, rows, cols, stride) {\r

  \  for (let i = 0; i <= rows - stride; i++) {\r

  \    let ch = bStrideColFrom(arr, i, icol, rows, cols, stride);\r

  \    if (ch) return ch;\r

  \  }\r

  \  return null;\r

  }"
bStrideColFrom: "function bStrideColFrom(arr, irow, icol, rows, cols, stride)
  {\r

  \  if (rows - irow < stride) return null;\r

  \  let iStart = irow * cols + icol;\r

  \  let x = arr[iStart];\r

  \  if (EmptyFunc(x)) return null;\r

  \  for (let i = iStart + cols; i < iStart + cols * stride; i += cols) if
  (arr[i] != x) return null;\r

  \  return x;\r

  }"
bStrideDiag2From: "function bStrideDiag2From(arr, irow, icol, rows, cols,
  stride) {\r

  \  if (rows - irow < stride || icol - stride + 1 < 0) return null;\r

  \  let iStart = irow * cols + icol;\r

  \  let x = arr[iStart];\r

  \  if (EmptyFunc(x)) return null;\r

  \  for (let i = iStart + cols - 1; i < iStart + (cols - 1) * stride; i +=
  cols - 1) if (arr[i] != x) return null;\r

  \  return x;\r

  }"
bStrideDiagFrom: "function bStrideDiagFrom(arr, irow, icol, rows, cols, stride)
  {\r

  \  if (rows - irow < stride || cols - icol < stride) return null;\r

  \  let iStart = irow * cols + icol;\r

  \  let x = arr[iStart];\r

  \  if (EmptyFunc(x)) return null;\r

  \  for (let i = iStart + cols + 1; i < iStart + (cols + 1) * stride; i +=
  cols + 1) if (arr[i] != x) return null;\r

  \  return x;\r

  }"
bStrideRow: "function bStrideRow(arr, irow, rows, cols, stride) {\r

  \  for (let i = 0; i <= cols - stride; i++) {\r

  \    let ch = bStrideRowFrom(arr, irow, i, rows, cols, stride);\r

  \    if (ch) return ch;\r

  \  }\r

  \  return null;\r

  }"
bStrideRowFrom: "function bStrideRowFrom(arr, irow, icol, rows, cols, stride)
  {\r

  \  if (cols - icol < stride) return null;\r

  \  let iStart = irow * cols + icol;\r

  \  let x = arr[iStart];\r

  \  if (EmptyFunc(x)) return null;\r

  \  for (let i = iStart + 1; i < iStart + stride; i++) if (arr[i] != x)
  return null;\r

  \  return x;\r

  }"
cardInno1: "function cardInno1(key, wCard = 420) {\r

  \  if (nundef(key)) key = chooseRandom(Object.keys(Cinno));\r

  \  let f = wCard / 420;\r

  \  let [w, h, szSym, paSym, fz, pa, bth, vGapTxt, rnd, gap] = [420 * f, 200
  * f, 100 * f, 8 * f, 100 * f * .8, 20 * f, 4 * f, 8 * f, 10 * f, 6 * f].map(x
  => Math.ceil(x));\r

  \  let info = Cinno[key];\r

  \  info.key = key;\r

  \  let cdict = { red: RED, blue: 'royalblue', green: 'green', yellow:
  'yelloworange', purple: 'indigo' };\r

  \  info.c = getColorDictColor(cdict[info.color]);\r

  \  let d = mDiv();\r

  \  mSize(d, w, h);\r

  \  mStyle(d, { fz: pa, margin: 8, align: 'left', bg: info.c, rounding: rnd,
  patop: paSym, paright: pa, pabottom: szSym, paleft: szSym + paSym, border: ''
  + bth + 'px solid silver', position: 'relative' })\r

  \  mText(info.key.toUpperCase(), d, { fz: pa, weight: 'bold', margin: 'auto'
  });\r

  \  mLinebreak(d);\r

  \  for (const dog of info.dogmas) {\r

  \    let text = replaceSymbols(dog);\r

  \    let d1 = mText(text, d); \r

  \    d1.style.marginBottom = '' + vGapTxt + 'px';\r

  \  }\r

  \  let syms = []; let d1;\r

  \  szSym -= gap;\r

  \  let sdict = {\r

  \    tower: { k: 'white-tower', bg: 'dimgray' }, clock: { k: 'watch', bg:
  'navy' }, crown: { k: 'crown', bg: 'black' },\r

  \    tree: { k: 'tree', bg: GREEN },\r

  \    bulb: { k: 'lightbulb', bg: 'purple' }, factory: { k: 'factory', bg:
  'red' }\r

  \  };\r

  \  for (const s in sdict) { sdict[s].sym = Syms[sdict[s].k]; }\r

  \  for (const sym of info.resources) {\r

  \    let isEcho = false;\r

  \    if (sym == 'None') {\r

  \      d1 = mDiv(d, { fz: fz * .75, fg: 'black', bg: 'white', rounding:
  '50%', display: 'inline' });\r

  \      let d2 = mText('' + info.age, d1, {});\r

  \      mClass(d2, 'centerCentered');\r

  \    } else if (sym == 'echo') {\r

  \      let text = info.echo;\r

  \      console.log('info.echo', info.echo);\r

  \      if (isList(info.echo)) text = info.echo[0];\r

  \      text = replaceSymbols(text);\r

  \      wEcho = szSym;\r

  \      let [w1, h1, w2, h2] = [wEcho, szSym, wEcho - 8, szSym - 8];\r

  \      d1 = mDiv(d, { display: 'inline', fg: 'white', bg: 'dimgray',
  rounding: 6, h: h1, w: w1 });\r

  \      let [bestFont, w3, h3] = fitFont(text, 20, w2, h2);\r

  \      let d2 = mDiv(d1, { w: w3, h: h3, fz: bestFont }, null, text);\r

  \      mCenterCenterFlex(d1);\r

  \      isEcho = true;\r

  \    } else if (isNumber(sym)) {\r

  \      d1 = mDiv(d, { fz: fz * .75, fg: 'white', bg: 'brown', border: '2px
  solid black', rounding: '50%', display: 'inline' });\r

  \      mCenterCenterFlex(d1);\r

  \      let d2 = mText('' + info.age, d1, {});\r

  \    } else {\r

  \      let key = sdict[sym].k;\r

  \      let mi = mPic(key, d, { w: szSym, fz: szSym * .8, bg: sdict[sym].bg,
  rounding: '10%' });\r

  \      d1 = iDiv(mi);\r

  \    }\r

  \    syms.push({ isEcho: isEcho, div: d1 });\r

  \  }\r

  \  placeSymbol(syms[0], szSym, gap, { left: 0, top: 0 });\r

  \  placeSymbol(syms[1], szSym, gap, { left: 0, bottom: 0 });\r

  \  placeSymbol(syms[2], szSym, gap, { left: w / 2, bottom: 0 });\r

  \  placeSymbol(syms[3], szSym, gap, { right: 0, bottom: 0 });\r

  \  info.div = d;\r

  \  return info;\r

  }"
cardPattern: "function cardPattern(n, sym) {\r

  \  let di = {\r

  \    1: [sym],\r

  \    2: [[sym], [sym]],\r

  \    3: [[sym], [sym], [sym]],\r

  \    4: [[sym, sym], [sym, sym]],\r

  \    5: [[sym, sym], [sym], [sym, sym]],\r

  \    6: [[sym, sym], [sym, sym], [sym, sym]],\r

  \    7: [[sym, sym], [sym, sym, sym], [sym, sym]],\r

  \    8: [[sym, sym, sym], [sym, sym], [sym, sym, sym]],\r

  \    9: [[sym, sym, sym], [sym, sym, sym], [sym, sym, sym]],\r

  \    10: [[sym, sym, sym], [sym, sym, sym, sym], [sym, sym, sym]],\r

  \    11: [[sym, sym, sym, sym], [sym, sym, sym], [sym, sym, sym, sym]],\r

  \    12: [[sym, sym, sym, sym], [sym, sym, sym, sym], [sym, sym, sym,
  sym]],\r

  \    13: [[sym, sym, sym], [sym, sym], [sym, sym, sym], [sym, sym], [sym,
  sym, sym]],\r

  \    14: [[sym, sym, sym, sym], [sym, sym, sym, sym], [sym, sym, sym,
  sym]],\r

  \    15: [[sym, sym, sym, sym], [sym, sym, sym, sym], [sym, sym, sym,
  sym]],\r

  \  };\r

  \  return di[n];\r

  }"
cardZone: "function cardZone(dParent, o, flex = 1, hmin = 170) {\r

  \  let dOuter = mDiv(dParent, { bg: o.color, fg: 'contrast', flex: flex,
  hmin: hmin }, 'd' + o.name, o.name);\r

  \  let dInner = mDiv(dOuter);\r

  \  mFlex(dInner); dInner.style.alignContent = 'flex-start';\r

  \  return dInner;\r

  }"
catanBoard: "function catanBoard(dParent, rows, topcols, styles = {}) {\r

  \  let g = hex1Board(dParent, rows, topcols, styles);\r

  \  hexCornerNodes(g);\r

  }"
cBlank: "function cBlank(dParent, styles = {}, id) {\r

  \  if (nundef(styles.h)) styles.h = Card.sz;\r

  \  if (nundef(styles.w)) styles.w = styles.h * .7;\r

  \  if (nundef(styles.bg)) styles.bg = 'white';\r

  \  styles.position = 'relative';\r

  \  let [w, h, sz] = [styles.w, styles.h, Math.min(styles.w, styles.h)];\r

  \  if (nundef(styles.rounding)) styles.rounding = sz * .05;\r

  \  let d = mDiv(dParent, styles, id, null, 'card');\r

  \  return d;\r

  \  let item = mItem(null, { div: d }, { type: 'card', sz: sz, rounding:
  styles.rounding });\r

  \  copyKeys(styles, item);\r

  \  return item;\r

  }"
cBlankSvg: "function cBlankSvg(dParent, styles = {}) {\r

  \  if (nundef(styles.h)) styles.h = Card.sz;\r

  \  if (nundef(styles.w)) styles.w = styles.h * .7;\r

  \  if (nundef(styles.bg)) styles.bg = 'white';\r

  \  styles.position = 'relative';\r

  \  let [w, h, sz] = [styles.w, styles.h, Math.min(styles.w, styles.h)];\r

  \  if (nundef(styles.rounding)) styles.rounding = sz * .05;\r

  \  let d = mDiv(dParent, styles, null, null, 'card');\r

  \  let svg = mgTag('svg', d, { width: '100%', height: '100%' }); \r

  \  let g = mgTag('g', svg);\r

  \  let item = mItem(null, { div: d, svg: svg, g: g }, { type: 'card', sz: sz
  });\r

  \  copyKeys(styles, item);\r

  \  return item;\r

  }"
cCircle: "function cCircle(c, sz, n, disp = -90) {\r

  \  let rad = sz / 2;\r

  \  centers = getEllipsePoints(rad, rad, n, disp)\r

  \  centers = centers.map(pt => ({ x: pt.X + c.x, y: pt.Y + c.y }));\r

  \  return centers;\r

  }"
check_complete_set: "function check_complete_set(fenlist) {\r

  \  if (fenlist.length != 3) return false;\r

  \  let [f1, f2, f3] = fenlist;\r

  \  console.log('set clicked', f1, f2, f3)\r

  \  for (let i = 0; i < f1.length; i++) {\r

  \    let [a, b, c] = [f1[i], f2[i], f3[i]];\r

  \    console.log('...set clicked', a, b, c)\r

  \    let correct = (a == b && b == c) || (a != b && b != c && a != c);\r

  \    if (!correct) return false;\r

  \  }\r

  \  return true;\r

  }"
checkBoardEmpty: function checkBoardEmpty(arr) { for (const x of arr) { if
  (!EmptyFunc(x)) return false; } return true; }
checkBoardFull: function checkBoardFull(arr) { for (const x of arr) if
  (EmptyFunc(x)) return false; return true; }
checkPotentialTTT: function checkPotentialTTT(arr, rows, cols) { return
  checkwinnersPossible(arr, rows, cols); }
checkSudokuRule: "function checkSudokuRule(matrix) {\r

  \  let i = 0;\r

  \  for (const arr of matrix) {\r

  \    let dd = hasDuplicate(arr);\r

  \    if (dd) {\r

  \      let err = { type: 'row', row: i, col: dd.i, val: dd.val, info: dd, i:
  i };\r

  \      return err;\r

  \    }\r

  \    i += 1;\r

  \  }\r

  \  i = 0;\r

  \  for (const arr of bGetCols(matrix)) {\r

  \    let dd = hasDuplicate(arr);\r

  \    if (dd) {\r

  \      let err = { type: 'column', col: i, row: dd.i, val: dd.val, i: i,
  info: dd };\r

  \      return err;\r

  \    }\r

  \    i += 1;\r

  \  }\r

  \  let [rows, cols] = [matrix.length, matrix[0].length];\r

  \  let rowsEach = rows == 9 ? 3 : 2;\r

  \  let colsEach = cols == 4 ? 2 : 3;\r

  \  let chunks = bGetChunksWithIndices(matrix, rowsEach, colsEach);\r

  \  i = 0;\r

  \  for (const arr of chunks) {\r

  \    let dd = hasDuplicate(arr);\r

  \    if (dd) {\r

  \      let val = dd.val;\r

  \      let err = { type: 'quadrant', row: val.row, col: val.col, val:
  val.val, i: i, info: dd };\r

  \    }\r

  \    i += 1;\r

  \  }\r

  \  return null;\r

  }"
checkSudokuRule_trial1: "function checkSudokuRule_trial1(matrix) {\r

  \  for (const arr of matrix) { let dd = hasDuplicate(arr); if (dd) return {
  type: 'row', info: dd }; }\r

  \  for (const arr of bGetCols(matrix)) { let dd = hasDuplicate(arr); if (dd)
  return { type: 'column', info: dd }; }\r

  \  let chunks = bGetChunks(matrix, 2, 2);\r

  \  for (const arr of chunks) { let dd = hasDuplicate(arr); if (dd) return {
  type: 'quadrant', info: dd }; }\r

  \  return null;\r

  }"
checkwinners: "function checkwinners(arr, rows, cols) {\r

  \  for (i = 0; i < rows; i++) { let ch = bFullRow(arr, i, rows, cols); if
  (ch) return ch; }\r

  \  for (i = 0; i < cols; i++) { let ch = bFullCol(arr, i, rows, cols); if
  (ch) return ch; }\r

  \  let ch = bFullDiag(arr, rows, cols); if (ch) return ch;\r

  \  ch = bFullDiag2(arr, rows, cols); if (ch) return ch;\r

  \  return null;\r

  }"
checkwinnersC4: "function checkwinnersC4(arr, rows = 6, cols = 7, stride = 4)
  {\r

  \  for (i = 0; i < rows; i++) { let ch = bStrideRow(arr, i, rows, cols,
  stride); if (ch) return ch; }\r

  \  for (i = 0; i < cols; i++) { let ch = bStrideCol(arr, i, rows, cols,
  stride); if (ch) return ch; }\r

  \  for (i = 0; i < rows; i++) {\r

  \    for (j = 0; j < cols; j++) {\r

  \      let ch = bStrideDiagFrom(arr, i, j, rows, cols, stride); if (ch)
  return ch;\r

  \      ch = bStrideDiag2From(arr, i, j, rows, cols, stride); if (ch) return
  ch;\r

  \    }\r

  \  }\r

  \  return null;\r

  }"
checkwinnersPossible: "function checkwinnersPossible(arr, rows, cols) {\r

  \  for (i = 0; i < rows; i++) { let ch = bPartialRow(arr, i, rows, cols); if
  (ch) return ch; }\r

  \  for (i = 0; i < cols; i++) { let ch = bPartialCol(arr, i, rows, cols); if
  (ch) return ch; }\r

  \  let ch = bPartialDiag(arr, rows, cols); if (ch) return ch;\r

  \  ch = bPartialDiag2(arr, rows, cols); if (ch) return ch;\r

  \  return null;\r

  }"
checkwinnersTTT: function checkwinnersTTT(arr, rows, cols) { return
  checkwinners(arr, rows, cols); }
circleCenters: "function circleCenters(rows, cols, wCell, hCell) {\r

  \  let [w, h] = [cols * wCell, rows * hCell];\r

  \  let cx = w / 2;\r

  \  let cy = h / 2;\r

  \  let centers = [{ x: cx, y: cy }];\r

  \  let rx = cx + wCell / 2; let dradx = rx / wCell;\r

  \  let ry = cy + hCell / 2; let drady = ry / hCell;\r

  \  let nSchichten = Math.floor(Math.min(dradx, drady));\r

  \  for (let i = 1; i < nSchichten; i++) {\r

  \    let [newCenters, wsch, hsch] = oneCircleCenters(i * 2 + 1, i * 2 + 1,
  wCell, hCell);\r

  \    for (const nc of newCenters) {\r

  \      centers.push({ x: nc.x + cx - wsch / 2, y: nc.y + cy - hsch / 2 });\r

  \    }\r

  \  }\r

  \  return [centers, wCell * cols, hCell * rows];\r

  }"
cLandscape: "function cLandscape(dParent, styles = {}, id) {\r

  \  if (nundef(styles.w)) styles.w = Card.sz;\r

  \  if (nundef(styles.h)) styles.h = styles.w * .65;\r

  \  return cBlank(dParent, styles, id);\r

  }"
clearStatus: function clearStatus() { clearFleetingMessage(); }
clearTable: "function clearTable() {\r

  \  clearElement('dTable');\r

  \  clearElement('dHistory');\r

  \  show_title();\r

  \  clearElement('dMessage');\r

  \  clearElement('dInstruction');\r

  \  clearElement('dTitleRight');\r

  \  hide('bPauseContinue');\r

  }"
correctPolys: "function correctPolys(polys, approx = 10) {\r

  \  let clusters = [];\r

  \  for (const p of polys) {\r

  \    for (const pt of p) {\r

  \      let found = false;\r

  \      for (const cl of clusters) {\r

  \        for (const v of cl) {\r

  \          let dx = Math.abs(v.x - pt.x);\r

  \          let dy = Math.abs(v.y - pt.y);\r

  \          if (dx < approx && dy < approx) {\r

  \            cl.push(pt);\r

  \            found = true;\r

  \            break;\r

  \          }\r

  \        }\r

  \        if (found) break;\r

  \      }\r

  \      if (!found) {\r

  \        clusters.push([pt]);\r

  \      }\r

  \    }\r

  \  }\r

  \  let vertices = [];\r

  \  for (const cl of clusters) {\r

  \    let sumx = 0;\r

  \    let sumy = 0;\r

  \    let len = cl.length;\r

  \    for (const pt of cl) {\r

  \      sumx += pt.x;\r

  \      sumy += pt.y;\r

  \    }\r

  \    vertices.push({ x: Math.round(sumx / len), y: Math.round(sumy / len)
  });\r

  \  }\r

  \  for (const p of polys) {\r

  \    for (const pt of p) {\r

  \      let found = false;\r

  \      for (const v of vertices) {\r

  \        let dx = Math.abs(v.x - pt.x);\r

  \        let dy = Math.abs(v.y - pt.y);\r

  \        if (dx < approx && dy < approx) {\r

  \          if (dx != 0 || dy != 0) {\r

  \            pt.x = v.x;\r

  \            pt.y = v.y;\r

  \          }\r

  \          found = true;\r

  \        }\r

  \        if (found) break;\r

  \      }\r

  \      if (!found) {\r

  \        error('point not found in vertices!!! ' + pt.x + ' ' + pt.y);\r

  \      }\r

  \    }\r

  \  }\r

  \  return vertices;\r

  }"
cPortrait: "function cPortrait(dParent, styles = {}, id) {\r

  \  if (nundef(styles.h)) styles.h = Card.sz;\r

  \  if (nundef(styles.w)) styles.w = styles.h * .7;\r

  \  return cBlank(dParent, styles, id);\r

  }"
create_set_card: "function create_set_card(fen, dParent, card_styles) {\r

  \  let myinfo = info_from_fen(fen);\r

  \  let info = { shape: 'circle', color: BLUE, num: 1, shading: 'solid',
  background: 'white', text: 'none' };\r

  \  copyKeys(myinfo, info);\r

  \  let card = draw_set_card(dParent, info, card_styles);\r

  \  card.fen = fen; \r

  \  return card;\r

  }"
cRound: "function cRound(dParent, styles = {}, id) {\r

  \  styles.w = valf(styles.w, Card.sz);\r

  \  styles.h = valf(styles.h, Card.sz);\r

  \  styles.rounding = '50%';\r

  \  return cBlank(dParent, styles, id);\r

  }"
cTitleArea: "function cTitleArea(card, h, styles, classes) {\r

  \  let dCard = iDiv(card);\r

  \  let dTitle = mDiv(dCard, { w: '100%', h: h, overflow: 'hidden',
  upperRounding: card.rounding });\r

  \  let dMain = mDiv(dCard, { w: '100%', h: card.h - h, lowerRounding:
  card.rounding });\r

  \  iAdd(card, { dTitle: dTitle, dMain: dMain });\r

  \  if (isdef(styles)) mStyle(dTitle, styles);\r

  \  return [dTitle, dMain];\r

  }"
dachain: "function dachain(ms = 0) {\r

  \  console.log('TestInfo', TestInfo)\r

  \  if (!isEmpty(DA.chain) && !(DA.test.running && DA.test.step == true)) {\r

  \    dachainext(ms);\r

  \  } else if (isEmpty(DA.chain)) console.log('DA.chain EMPTY ' +
  DA.test.iter)\r

  }"
dachainext: "function dachainext(ms = 0) {\r

  \  let f = DA.chain.shift();\r

  \  if (ms > 0) TOMan.TO[getUID('f')] = setTimeout(f, ms);\r

  \  else f();\r

  }"
deck_add: function deck_add(deck, n, arr) { let els = deck_deal(deck, n);
  els.map(x => arr.push(x)); return arr; }
deck_deal: function deck_deal(deck, n) { return deck.splice(0, n); }
destroySudokuRule: "function destroySudokuRule(pattern, rows, cols) {\r

  \  let sz = Math.min(rows, cols);\r

  \  let [r1, r2] = choose(range(0, sz - 1), 2);\r

  \  let c = chooseRandom(range(0, sz - 1));\r

  \  if (coin(50)) { arrSwap2d(pattern, r1, c, r2, c); }\r

  \  else if (coin(50)) { arrSwap2d(pattern, c, r1, c, r2); }\r

  }"
draw_set_card: "function draw_set_card(dParent, info, card_styles) {\r

  \  let card = cLandscape(dParent, card_styles);\r

  \  card.info = info;\r

  \  let d = iDiv(card);\r

  \  mCenterCenterFlex(d);\r

  \  let sz = card.sz / 2.8;\r

  \  let bg, shape = info.shape, text;\r

  \  switch (info.shading) {\r

  \    case 'solid': bg = info.color; break;\r

  \    case 'gradient': bg = `linear-gradient(${info.color}, silver)`;
  break;\r

  \    case 'empty': bg = `repeating-linear-gradient(\r

  \      45deg,\r

  \      ${info.color},\r

  \      ${info.color} 10px,\r

  \      silver 10px,\r

  \      silver 20px\r

  \    )`; break;\r

  \  }\r

  \  mStyle(d, { bg: info.background });\r

  \  switch (info.text) {\r

  \    case 'none': text = null; break;\r

  \    case 'letter': text = randomLetter(); break;\r

  \    case 'number': text = '' + randomDigit(); break;\r

  \  }\r

  \  let styles = { w: sz, h: sz, margin: sz / 10 };\r

  \  for (let i = 0; i < info.num; i++) {\r

  \    let d1 = drawShape(shape, d, styles);\r

  \    if (info.shading == 'gradient') { d1.style.backgroundColor =
  info.color; mClass(d1, 'polka-dot'); } else mStyle(d1, { bg: bg });\r

  \    if (shape == 'circle') console.log('circle', d1);\r

  \    if (isdef(text)) { mCenterCenterFlex(d1); mText(text, d1, { fz: sz /
  1.75, fg: 'black', family: 'impact' }); }\r

  \  }\r

  \  return card;\r

  }"
draw_set_card_test: "function draw_set_card_test(dParent) {\r

  \  let card = cLandscape(dParent, { w: 120 });\r

  \  let d = iDiv(card, { h: '100%' });\r

  \  mCenterCenterFlex(d);\r

  \  let sz = card.sz / 4;\r

  \  let styles = { w: sz, h: sz, bg: `linear-gradient(${RED},black`, margin:
  sz / 10, border: `solid 3px ${GREEN}` };\r

  \  let d1 = drawShape('circle', d, styles); mCenterCenterFlex(d1);
  mText('A', d1, { fz: sz / 4, fg: 'white' });\r

  \  drawShape('circle', d, styles);\r

  \  drawShape('circle', d, styles);\r

  }"
expandBoard: "function expandBoard(board, rNew, cNew, iInsert) {\r

  \  let [boardArrOld, rOld, cOld] = [board.fields.map(x => isdef(x.item) ?
  x.item.index : null), board.rows, board.cols];\r

  \  let boardArrNew = new Array(rNew * cNew);\r

  \  for (let r = 0; r < rNew; r++) {\r

  \    for (let c = 0; c < cNew; c++) {\r

  \      let i = iFromRowCol(r, c, rNew, cNew);\r

  \      let x = (rOld != rNew) ? r : c;\r

  \      if (x < iInsert) {\r

  \        let iOld = iFromRowCol(r, c, rOld, cOld);\r

  \        boardArrNew[i] = boardArrOld[iOld];\r

  \      }\r

  \      else if (x == iInsert) boardArrNew[i] = null;\r

  \      else {\r

  \        let [ir, ic] = (rOld != rNew) ? [r - 1, c] : [r, c - 1];\r

  \        let iOld = iFromRowCol(ir, ic, rOld, cOld);\r

  \        boardArrNew[i] = boardArrOld[iOld];\r

  \      }\r

  \    }\r

  \  }\r

  \  return { rows: rNew, cols: cNew, boardArr: boardArrNew, extras: [] };\r

  }"
fen_from_info: "function fen_from_info(info) {\r

  \  let all_attrs = gSet_attributes();\r

  \  let keys = get_keys(all_attrs);\r

  \  let fen = '';\r

  \  for (const prop of keys) {\r

  \    let val = info[prop];\r

  \    let i = all_attrs[prop].indexOf(val);\r

  \    fen += '' + i;\r

  \  }\r

  \  return fen;\r

  }"
fillColarr: "function fillColarr(colarr, items) {\r

  \  let i = 0;\r

  \  let result = [];\r

  \  for (const r of colarr) {\r

  \    let arr = [];\r

  \    for (let c = 0; c < r; c++) {\r

  \      arr.push(items[i]); i++;\r

  \    }\r

  \    result.push(arr);\r

  \  }\r

  \  return result;\r

  }"
fitFont: "function fitFont(text, fz = 20, w2 = 200, h2 = 100) {\r

  \  let e1, e2, r1, r2;\r

  \  e1 = mDiv(dTable, { w: w2, h: h2, display: 'inline-block' });\r

  \  do {\r

  \    e2 = mDiv(e1, { fz: fz, display: 'inline-block' }, null, text);\r

  \    r1 = getRect(e1);\r

  \    r2 = getRect(e2);\r

  \    e2.remove();\r

  \    fz -= 1;\r

  \  } while (r1.w * r1.h < r2.w * r2.h);\r

  \  e1.remove();\r

  \  return [fz + 1, r2.w, r2.h];\r

  }"
fitSvg: "function fitSvg(el) {\r

  \  const box = el.querySelector('text').getBBox();\r

  \  el.style.width = `${box.width}px`;\r

  \  el.style.height = `${box.height}px`;\r

  }"
gameItem: "function gameItem(name, color) { return mItem(name2id(name), null, {
  color: isdef(color) ? color : randomColor(), name: name }); }"
get_card_div: "function get_card_div(R1 = '1', SB = 'B') {\r

  \  let key52 = get_card_key52(R1, SB);\r

  \  let svgCode = C52['card_1B']; \r

  \  svgCode = '<div>' + svgCode + '</div>';\r

  \  let el = mCreateFrom(svgCode);\r

  \  [w, h] = [isdef(w) ? w : Card.w, isdef(h) ? h : Card.sz];\r

  \  mSize(el, w, h);\r

  \  return el;\r

  }"
get_card_key52: "function get_card_key52(R1 = '1', SB = 'B') {\r

  \  return `card_${Rank1}${SuitB}`;\r

  }"
get_create_staged: "function get_create_staged(fen, options, player_names) {\r

  \  let t = create_table(options, player_names);\r

  \  t.fen = fen;\r

  \  to_server({ table: t }, 'delete_and_create_staged');\r

  }"
get_random_attr_val: "function get_random_attr_val(attr_list) {\r

  \  let all_attrs = gSet_attributes();\r

  \  return attr_list.map(x => chooseRandom(all_attrs[x]));\r

  }"
get_splay_number: "function get_splay_number(wsplay) { return wsplay == 'none' ?
  0 : wsplay == 'left' ? 1 : wsplay == 'right' ? 2 : wsplay == 'up' ? 3 : 4; }"
get_splay_word: "function get_splay_word(nsplay) { return nsplay == 0 ? 'none' :
  nsplay == 1 ? 'left' : nsplay == 2 ? 'right' : dsplay == 3 ? 'up' : 'deck'; }"
getCenters: "function getCenters(layout, rows, cols, wCell, hCell,) {\r

  \  if (layout == 'quad') { return quadCenters(rows, cols, wCell, hCell); }\r

  \  else if (layout == 'hex') { return hexCenters(rows, cols, wCell, hCell);
  }\r

  \  else if (layout == 'circle') { return circleCenters(rows, cols, wCell,
  hCell); }\r

  }"
getCentersFromAreaSize: "function getCentersFromAreaSize(layout, wBoard, hBoard,
  wCell, hCell) {\r

  \  let info;\r

  \  if (layout == 'quad') { info = quadCenters(rows, cols, wCell, hCell); }\r

  \  else if (layout == 'hex') { info = hexCenters(rows, cols, wCell, hCell);
  }\r

  \  else if (layout == 'hex1') { info = hex1Centers(rows, cols, wCell,
  hCell); }\r

  \  else if (layout == 'circle') { info = circleCenters(rows, cols, wCell,
  hCell); }\r

  \  return info;\r

  }"
getCentersFromRowsCols: "function getCentersFromRowsCols(layout, rows, cols,
  wCell, hCell) {\r

  \  let info;\r

  \  if (layout == 'quad') { info = quadCenters(rows, cols, wCell, hCell); }\r

  \  else if (layout == 'hex') { info = hexCenters(rows, cols, wCell, hCell);
  }\r

  \  else if (layout == 'hex1') { info = hex1Centers(rows, cols, wCell,
  hCell); }\r

  \  else if (layout == 'circle') { info = circleCenters(rows, cols, wCell,
  hCell); }\r

  \  return info;\r

  }"
getCornerVertices: "function getCornerVertices(centers, w = 100, h = 100) {\r

  \  let polys = [];\r

  \  for (const pt of centers) {\r

  \    let poly = getHexPoly(pt.x, pt.y, w, h);\r

  \    polys.push(poly);\r

  \  }\r

  \  let vertices = correctPolys(polys, 1);\r

  \  return vertices;\r

  }"
getSudokuPattern: "function getSudokuPattern(r, c) {\r

  \  let patterns = {\r

  \    44: [\r

  \      [[0, 1, 2, 3], [2, 3, 0, 1], [3, 0, 1, 2], [1, 2, 3, 0]],\r

  \      [[0, 1, 2, 3], [3, 2, 0, 1], [2, 3, 1, 0], [1, 0, 3, 2]],\r

  \      [[0, 1, 2, 3], [2, 3, 0, 1], [1, 0, 3, 2], [3, 2, 1, 0]],\r

  \    ],\r

  \  };\r

  \  return chooseRandom(patterns['' + r + c]);\r

  }"
getSudokuPatternFromDB: "function getSudokuPatternFromDB(r, c, index) {\r

  \  let key = '' + r + 'x' + c;\r

  \  let numSamples = Object.keys(DB.games.gColoku.samples[key]).length;\r

  \  if (nundef(index)) index = randomNumber(0, numSamples - 1); else if
  (index >= numSamples) index = 1;\r

  \  let sample = DB.games.gColoku.samples[key][index];\r

  \  let pattern = sudokuSampleToIndexMatrix(sample.sol, r, c);\r

  \  let puzzle = sudokuSampleToIndexMatrix(sample.min, r, c);\r

  \  return { pattern: pattern, puzzle: puzzle };\r

  }"
giRep: "function giRep(gi, dParent, styles, shape, prefix, content) {\r

  \  gi = isString(gi) ? gi[1] == '_' ? Items[gi] : Items[name2id(gi)] : gi;\r

  \  let id = gi.id;\r

  \  let name = gi.name;\r

  \  let d = mShape(shape, dParent, styles);\r

  \  d.id = (isdef(prefix) ? prefix : '') + id;\r

  \  let key = isdef(prefix) ? prefix : 'div';\r

  \  d.innerHTML = content;\r

  \  let di = {}; di[key] = d; iAdd(gi, di);\r

  \  return d;\r

  }"
gSet_attributes: "function gSet_attributes() {\r

  \  const all_attrs = {\r

  \    shape: ['circle', 'triangle', 'square'],\r

  \    color: [RED, BLUE, GREEN],\r

  \    num: [1, 2, 3],\r

  \    shading: ['solid', 'empty', 'gradient'],\r

  \    background: ['white', 'grey', 'black'],\r

  \    text: ['none', 'letter', 'number'],\r

  \  };\r

  \  return all_attrs;\r

  }"
has_farm: function has_farm(uname) { return
  firstCond(UI.players[uname].buildinglist, x => x.type == 'farm'); }
hasDuplicate: "function hasDuplicate(arr, efunc) {\r

  \  let di = {};\r

  \  if (nundef(efunc)) efunc = x => { return x === ' ' };\r

  \  let i = -1;\r

  \  for (const a of arr) {\r

  \    i += 1;\r

  \    if (efunc(a)) continue; \r

  \    if (a in di) return { i: i, val: a };\r

  \    di[a] = true;\r

  \  }\r

  \  return false;\r

  }"
hex1Board: "function hex1Board(dParent, rows, topcols, styles = {}) {\r

  \  let g = new UIGraph(dParent, styles);\r

  \  let [w, h] = [valf(lookup(styles, ['node', 'w']), 50),
  valf(lookup(styles, ['node', 'h']), 50)];\r

  \  let total = hex1Count(rows, topcols);\r

  \  let nids = g.addNodes(total);\r

  \  g.hex1(rows, topcols, w + 4, h + 4);\r

  \  let indices = hex1Indices(rows, topcols);\r

  \  let ids = g.getNodeIds();\r

  \  let di = {};\r

  \  for (let i = 0; i < ids.length; i++) {\r

  \    let [row, col] = [indices[i].row, indices[i].col];\r

  \    let id = ids[i];\r

  \    lookupSet(di, [row, col], id);\r

  \    g.setProp(id, 'row', row);\r

  \    g.setProp(id, 'col', col);\r

  \    g.setProp(id, 'label', `${row},${col}`);\r

  \  }\r

  \  for (let i = 0; i < ids.length; i++) {\r

  \    let [row, col] = [indices[i].row, indices[i].col];\r

  \    let id = ids[i];\r

  \    let nid2 = lookup(di, [row, col + 2]); if (nid2) g.addEdge(id, nid2);\r

  \    nid2 = lookup(di, [row + 1, col - 1]); if (nid2) g.addEdge(id, nid2);\r

  \    nid2 = lookup(di, [row + 1, col + 1]); if (nid2) g.addEdge(id, nid2);\r

  \  }\r

  \  let byrc = {};\r

  \  for (const r in di) {\r

  \    byrc[r] = {};\r

  \    for (const c in di[r]) {\r

  \      byrc[r][c] = g.getNode(di[r][c]).data();\r

  \    }\r

  \  }\r

  \  g.di = di;\r

  \  g.byrc = byrc;\r

  \  g.rc = (i, j, f) => (isdef(f)) ? f(g.getNode(di[i][j])) :
  g.getNode(di[i][j]);\r

  \  return g;\r

  }"
hex1Centers: "function hex1Centers(rows, cols, wCell = 100, hCell = null) {\r

  \  let colarr = _calc_hex_col_array(rows, cols);\r

  \  let maxcols = arrMax(colarr);\r

  \  if (nundef(hCell)) hCell = (hCell / .866);\r

  \  let hline = hCell * .75;\r

  \  let offX = wCell / 2, offY = hCell / 2;\r

  \  let centers = [];\r

  \  let x = 0; y = 0;\r

  \  for (let r = 0; r < colarr.length; r++) {\r

  \    let n = colarr[r];\r

  \    for (let c = 0; c < n; c++) {\r

  \      let dx = (maxcols - n) * wCell / 2;\r

  \      let dy = r * hline;\r

  \      let center = { x: dx + c * wCell + offX, y: dy + offY };\r

  \      centers.push(center);\r

  \    }\r

  \  }\r

  \  return [centers, wCell * maxcols, hCell / 4 + rows * hline];\r

  }"
hex1Count: "function hex1Count(rows, topcols) {\r

  \  let colarr = _calc_hex_col_array(rows, topcols);\r

  \  let total = 0;\r

  \  for (let r = 0; r < colarr.length; r++) { total += colarr[r]; }\r

  \  return total;\r

  }"
hex1Indices: "function hex1Indices(rows, topcols) {\r

  \  let colarr = _calc_hex_col_array(rows, topcols);\r

  \  let iStart = Math.floor(rows / 2);\r

  \  let inc = -1;\r

  \  let res = [];\r

  \  for (let r = 0; r < colarr.length; r++) {\r

  \    let n = colarr[r];\r

  \    for (let c = 0; c < n; c++) {\r

  \      let icol = iStart + 2 * c;\r

  \      let irow = r;\r

  \      res.push({ row: irow, col: icol });\r

  \    }\r

  \    if (iStart == 0) inc = 1;\r

  \    iStart += inc;\r

  \  }\r

  \  return res;\r

  }"
hexCenters: "function hexCenters(rows, cols, wCell = 100, hCell) {\r

  \  if (nundef(hCell)) hCell = (hCell / .866);\r

  \  let hline = hCell * .75;\r

  \  let offX = wCell / 2, offY = hCell / 2;\r

  \  let centers = [];\r

  \  let startSmaller = Math.floor(rows / 2) % 2 == 1;\r

  \  let x = 0; y = 0;\r

  \  for (let r = 0; r < rows; r++) {\r

  \    let isSmaller = startSmaller && r % 2 == 0 || !startSmaller && r % 2 ==
  1;\r

  \    let curCols = isSmaller ? cols - 1 : cols;\r

  \    let dx = isSmaller ? wCell / 2 : 0;\r

  \    dx += offX;\r

  \    for (let c = 0; c < curCols; c++) {\r

  \      let center = { x: dx + c * wCell, y: offY + r * hline };\r

  \      centers.push(center);\r

  \    }\r

  \  }\r

  \  return [centers, wCell * cols, hCell / 4 + rows * hline];\r

  }"
hexCornerNodes: "function hexCornerNodes(g) {\r

  \  let nodes = g.getNodes();\r

  \  let centers = nodes.map(x => x.data('center'));\r

  \  let vertices = getCornerVertices(centers);\r

  \  for (const f of nodes) {\r

  \    let center = f.data('center');\r

  \    console.log('center', center)\r

  \  }\r

  }"
hide_history_popup: function hide_history_popup() {	let d =
  mBy('dHistoryPopup');	if (isdef(d))
  {mAppend(UI.dHistoryParent,UI.dHistory);mRemove(d);}}
hide_options_popup: function hide_options_popup() {	let d = mBy('dOptions');	if
  (isdef(d)) mRemove(d);}
i52: "function i52(i) { return isList(i) ? i.map(x => Card52.getItem(x)) :
  Card52.getItem(i); }"
iAppend52: "function iAppend52(i, dParent, faceUp) {\r

  \  let item = i52(i);\r

  \  iFace(item, faceUp);\r

  \  mAppend(dParent, item.div);\r

  \  return item;\r

  }"
id2name: function id2name(id) { id.substring(2).split('_').join(' '); }
iFace: "function iFace(item, faceUp) { if (isdef(faceUp)) faceUp ? iFaceUp(item)
  : iFaceDown(item); }"
iFaceDown: function iFaceDown(item) { Card52.turnFaceDown(item); }
iFaceUp: function iFaceUp(item) { Card52.turnFaceUp(item); }
iFromRowCol: function iFromRowCol(row, col, rows, cols) { return row * cols + col; }
iH00: "function iH00(iarr, dParent, styles, id) {\r

  \  function iH00Zone(dTable, nmax = 7, padding = 10) {\r

  \    let sz = netHandSize(nmax);\r

  \    return mZone(dTable, { wmin: sz.w, h: sz.h, padding: padding }); \r

  \  }\r

  \  let h = isdef(Items[id]) ? Items[id] : { arr: iarr, styles: styles, id:
  id };\r

  \  if (nundef(h.zone)) h.zone = iH00Zone(dParent); else
  clearElement(h.zone);\r

  \  let items = i52(iarr);\r

  \  h.iHand = iSplay(items, h.zone);\r

  \  return h;\r

  }"
iH00_dep: "function iH00_dep(iarr, dParent, styles, id) {\r

  \  function iH00Zone(dTable, nmax = 3, padding = 10) {\r

  \    let sz = netHandSize(nmax);\r

  \    return mZone(dTable, { wmin: sz.w, h: sz.h, padding: padding, rounding:
  10 });\r

  \  }\r

  \  let data = DA[id] = {};\r

  \  let h = data.deck = new DeckClass();\r

  \  h.init(iarr);\r

  \  h = data;\r

  \  if (nundef(h.zone)) h.zone = iH00Zone(dParent); else
  clearElement(h.zone);\r

  \  if (nundef(h.iHand)) {\r

  \    let items = i52(h.deck.cards());\r

  \    h.iHand = iSplay(items, h.zone);\r

  \  } else if (redo) {\r

  \    clearElement(h.zone);\r

  \    let items = i52(h.deck.cards());\r

  \    h.iHand = iSplay(items, h.zone);\r

  \  }\r

  \  return h;\r

  }"
iH01: "function iH01(iarr, dParent, styles, id, overlap) {\r

  \  function iH01Zone(dTable, nmax = 3, padding = 10) {\r

  \    let sz = netHandSize(nmax);\r

  \    return mZone(dTable, { wmin: sz.w, h: sz.h, padding: padding }); \r

  \  }\r

  \  let h = isdef(Items[id]) ? Items[id] : { arr: iarr, styles: styles, id:
  id };\r

  \  if (nundef(h.zone)) h.zone = iH01Zone(dParent); else
  clearElement(h.zone);\r

  \  let items = i52(iarr);\r

  \  h.iHand = iSplay(items, h.zone, {}, 'right', overlap);\r

  \  return h;\r

  }"
iHand52: "function iHand52(i) {\r

  \  let hand = iSplay(i, dTable);\r

  }"
iHandZone: "function iHandZone(dParent, styles, nmax) {\r

  \  if (nundef(styles)) styles = { bg: 'random', rounding: 10 };\r

  \  if (isdef(nmax)) {\r

  \    console.log('nmax', nmax)\r

  \    let sz = netHandSize(nmax);\r

  \    styles.w = sz.w;\r

  \    styles.h = sz.h;\r

  \  }\r

  \  return mZone(dParent, styles);\r

  }"
iHandZone_test: "function iHandZone_test(dTable, nmax = 10, padding = 10) {\r

  \  let sz = netHandSize(nmax);\r

  \  return mZone(dTable, { wmin: sz.w, h: sz.h, bg: 'random', padding:
  padding, rounding: 10 });\r

  }"
iMakeHand: "function iMakeHand(iarr, dParent, styles, id) {\r

  \  let data = DA[id] = {};\r

  \  let h = data.deck = new DeckClass();\r

  \  h.init(iarr);\r

  \  iPresentHand(data, dParent, styles);\r

  \  return data;\r

  }"
iMakeHand_test: "function iMakeHand_test(dParent, iarr, id) {\r

  \  let data = DA[id] = {};\r

  \  let h = data.deck = new DeckClass();\r

  \  h.init(iarr);\r

  \  iPresentHand_test(dParent, data);\r

  \  return data;\r

  }"
indexDiff: "function indexDiff(a, b, s) {\r

  \  let ia = s.indexOf(a);\r

  \  let ib = s.indexOf(b);\r

  \  console.log('index of', a, 'is', ia)\r

  \  console.log('index of', b, 'is', ib)\r

  \  return ia - ib;\r

  }"
info_from_fen: "function info_from_fen(fen) {\r

  \  let all_attrs = gSet_attributes();\r

  \  let keys = get_keys(all_attrs);\r

  \  let info = {};\r

  \  for (let i = 0; i < fen.length; i++) {\r

  \    let prop = keys[i];\r

  \    let val = all_attrs[prop][Number(fen[i])];\r

  \    info[prop] = val;\r

  \  }\r

  \  return info;\r

  }"
inno_calc_visible_syms: "function inno_calc_visible_syms(board, splays = {}) {\r

  \  let res = {};\r

  \  INNO.symNames.map(x => res[x] = 0);\r

  \  for (const color in board) {\r

  \    let res_color = inno_calc_visible_syms_pile(board[color],
  splays[color]);\r

  \    for (const k in res) { res[k] += res_color[k]; }\r

  \  }\r

  \  return res;\r

  }"
inno_calc_visible_syms_pile: "function inno_calc_visible_syms_pile(keys, dir)
  {\r

  \  let [cards, totals] = [keys.map(x => InnoById[x]), {}];\r

  \  INNO.symNames.map(x => totals[x] = 0);\r

  \  if (isEmpty(keys)) return totals;\r

  \  let top = cards.shift();\r

  \  for (const k of top.resources) {\r

  \    if (isdef(totals[k])) totals[k] += 1;\r

  \  }\r

  \  if (nundef(dir) || dir == 0) return totals;\r

  \  if (dir == 1) {\r

  \  } else if (dir == 2) {\r

  \    for (const c of cards) {\r

  \      for (const k in totals) {\r

  \        if (c.resources[0] == k) totals[k]++;\r

  \        if (c.resources[1] == k) totals[k]++;\r

  \      }\r

  \    }\r

  \  }\r

  \  return totals;\r

  }"
inno_card: "function inno_card(dParent, keyOrName) {\r

  \  if (nundef(keyOrName)) keyOrName = chooseRandom(get_keys(InnoById));\r

  \  let cardInfo, name, key, id;\r

  \  if (isdef(InnoById[keyOrName])) { id = key = keyOrName; cardInfo =
  InnoById[id]; name = cardInfo.name; }\r

  \  else if (isdef(InnoByName[keyOrName])) { name = keyOrName; cardInfo =
  InnoByName[name]; id = key = cardInfo.id; };\r

  \  let sym = INNO.sym[cardInfo.type];\r

  \  let info = Syms[sym.key];\r

  \  let card = cBlank(dParent, { fg: 'black', bg: INNO.color[cardInfo.color],
  w: Card.sz, h: Card.sz * .65, margin: 10 });\r

  \  let [dCard, sz, szTitle, margin] = [iDiv(card), Card.sz / 5,
  cardInfo.exp[0] == 'A' ? Card.sz / 12 : Card.sz / 8, 4];\r

  \  let [dTitle, dMain] = cTitleArea(card, szTitle);\r

  \  let d = mAddContent(dTitle, name, {\r

  \    patop: 4, bg: sym.bg, fg: 'white', h: szTitle, fz: szTitle * .7, align:
  'center',\r

  \    position: 'relative'\r

  \  });\r

  \  mAddContent(d, cardInfo.age, { hpadding: szTitle / 4, float: 'right'
  });\r

  \  let s = mSym(sym.key, d, { hpadding: szTitle / 4, h: szTitle * .7, fg:
  sym.fg, float: 'left' });\r

  \  let positions = ['tl', 'bl', 'bc', 'br'];\r

  \  for (let i = 0; i < 4; i++) {\r

  \    let r = cardInfo.resources[i];\r

  \    let pos = positions[i];\r

  \    if (r in INNO.sym) { innoSym(r, dMain, sz, pos, margin); }\r

  \    else if (r == 'None') { innoAgeNumber(cardInfo.age, dMain, sz, pos,
  margin); }\r

  \    else if (isNumber(r)) { innoBonusNumber(r, dMain, sz, pos, margin); }\r

  \    else if (r == 'echo') { innoEcho(cardInfo.echo, dMain, sz, pos,
  margin); }\r

  \    else if (r == 'inspire') { innoInspire(cardInfo.inspire, dMain, sz,
  pos, margin); }\r

  \  }\r

  \  if (isdef(cardInfo.dogmas)) {\r

  \    let box = mBoxFromMargins(dMain, 10, margin, sz + margin, sz + 2 *
  margin); \r

  \    mStyle(box, { align: 'left' });\r

  \    let text = '';\r

  \    for (const dog of cardInfo.dogmas) {\r

  \      let t = startsWith(dog, 'I demand') ? ('I <b>demand</b>' +
  dog.substring(8)) : startsWith(dog, 'I compell') ? ('I <b>compell</b>' +
  dog.substring(8)) : dog;\r

  \      text += `<span
  style=\"color:${sym.bg};font-family:${info.family}\">${info.text}</span>` +
  '&nbsp;' + t + '<br>';\r

  \    }\r

  \    let t2 = innoText(text);\r

  \    mFillText(t2, box);\r

  \  } else if (isdef(cardInfo.res_city)) {\r

  \    let positions = ['tc', 'tr'];\r

  \    for (let i = 0; i < 2; i++) {\r

  \      let r = cardInfo.res_city[i];\r

  \      let pos = positions[i];\r

  \      if (r == 'flag') { innoFlag(cardInfo.type, dMain, sz, pos, margin);
  }\r

  \      else if (r in INNO.sym) { innoSym(r, dMain, sz, pos, margin); }\r

  \      else if (r == 'None') { innoAgeNumber(cardInfo.age, dMain, sz, pos,
  margin); }\r

  \      else if (isNumber(r)) { innoBonusNumber(r, dMain, sz, pos, margin);
  }\r

  \      else if (r == 'echo') { innoEcho(cardInfo.echo, dMain, sz, pos,
  margin); }\r

  \      else if (r == 'inspire') { innoInspire(cardInfo.inspire, dMain, sz,
  pos, margin); }\r

  \    }\r

  \  }\r

  \  card.info = cardInfo;\r

  \  return card;\r

  }"
inno_card_fixed_font: "function inno_card_fixed_font(dParent, keyOrName) {\r

  \  if (nundef(keyOrName)) keyOrName = chooseRandom(get_keys(InnoById));\r

  \  let cardInfo, name, key, id;\r

  \  if (isdef(InnoById[keyOrName])) { id = key = keyOrName; cardInfo =
  InnoById[id]; name = cardInfo.name; }\r

  \  else if (isdef(InnoByName[keyOrName])) { name = keyOrName; cardInfo =
  InnoByName[name]; id = key = cardInfo.id; };\r

  \  let sym = INNO.sym[cardInfo.type];\r

  \  let info = Syms[sym.key];\r

  \  let card = cBlank(dParent, { fg: 'black', bg: INNO.color[cardInfo.color],
  w: Card.sz, h: Card.sz * .65, margin: 10 });\r

  \  let [dCard, sz, szTitle, margin] = [iDiv(card), Card.sz / 5,
  cardInfo.exp[0] == 'A' ? Card.sz / 12 : Card.sz / 8, 4];\r

  \  let [dTitle, dMain] = cTitleArea(card, szTitle);\r

  \  let d = mAddContent(dTitle, name, {\r

  \    patop: 4, bg: sym.bg, fg: 'white', h: szTitle, fz: szTitle * .7, align:
  'center',\r

  \    position: 'relative'\r

  \  });\r

  \  mAddContent(d, cardInfo.age, { hpadding: szTitle / 4, float: 'right'
  });\r

  \  let s = mSym(sym.key, d, { hpadding: szTitle / 4, h: szTitle * .7, fg:
  sym.fg, float: 'left' });\r

  \  let positions = ['tl', 'bl', 'bc', 'br'];\r

  \  for (let i = 0; i < 4; i++) {\r

  \    let r = cardInfo.resources[i];\r

  \    let pos = positions[i];\r

  \    if (r in INNO.sym) { innoSym(r, dMain, sz, pos, margin); }\r

  \    else if (r == 'None') { innoAgeNumber(cardInfo.age, dMain, sz, pos,
  margin); }\r

  \    else if (isNumber(r)) { innoBonusNumber(r, dMain, sz, pos, margin); }\r

  \    else if (r == 'echo') { innoEcho(cardInfo.echo, dMain, sz, pos,
  margin); }\r

  \  }\r

  \  let box = mBoxFromMargins(dMain, 10, margin, sz + margin, sz + 2 *
  margin); \r

  \  console.log('box', box);\r

  \  mStyle(box, { align: 'left', padding: 4 });\r

  \  let text = '';\r

  \  for (const dog of cardInfo.dogmas) {\r

  \    let t = startsWith(dog, 'I demand') ? ('I <b>demand</b>' +
  dog.substring(8)) : startsWith(dog, 'I compell') ? ('I <b>compell</b>' +
  dog.substring(8)) : dog;\r

  \    text += `<span
  style=\"color:${sym.bg};font-family:${info.family}\">${info.text}</span>` +
  '&nbsp;' + t + '<br>';\r

  \  }\r

  \  let t2 = innoText(text);\r

  \  mText(t2, box, { fz: 10 });\r

  \  card.info = cardInfo;\r

  \  return card;\r

  }"
inno_create_card_assets: "function inno_create_card_assets() {\r

  \  Dinno = { A: {}, B: {}, C: {}, E: {}, F: {} };\r

  \  InnoById = {}; \r

  \  InnoByName = {};\r

  \  for (const exp in Cinno) {\r

  \    for (const name in Cinno[exp]) {\r

  \      let c = Cinno[exp][name];\r

  \      c.name = name;\r

  \      c.exp = exp;\r

  \      let id = inno_get_id(c); \r

  \      c.id = c.key = id;\r

  \      if (isdef(InnoById[id])) { console.log('duplicate id', id,
  InnoById[id].name, c.name); }\r

  \      InnoById[id] = c;\r

  \      let key_name = name.toLowerCase().trim();\r

  \      if (isdef(InnoByName[key_name])) console.log('duplicate name',
  name);\r

  \      InnoByName[key_name] = c;\r

  \      lookupAddToList(Dinno, [exp[0], c.age], c.id);\r

  \    }\r

  \  }\r

  }"
inno_get_basic_deck_age: "function inno_get_basic_deck_age(otree, min_age) {\r

  \  for (let i = min_age; i <= 10; i++) {\r

  \    let deck = otree.decks.B[i];\r

  \    let len = deck.length;\r

  \    if (len > 0) return i;\r

  \  }\r

  \  return 11;\r

  }"
inno_get_cardinfo: function inno_get_cardinfo(key) { return InnoById[key]; }
inno_get_deck_age: "function inno_get_deck_age(otree, deck_letter, min_age = 1)
  {\r

  \  let deck_age = inno_get_basic_deck_age(otree, min_age);\r

  \  if (deck_letter == 'B') return deck_age;\r

  \  let deck = otree.decks[deck_letter][deck_age];\r

  \  while (deck_age <= 10 && isEmpty(deck)) { deck_age += 1; deck =
  otree.decks[deck_letter][deck_age]; }\r

  \  return deck_age;\r

  }"
inno_get_hand_actions: "function inno_get_hand_actions(otree, uname) {\r

  \  let actions = [];\r

  \  otree[uname].hand.map(x => actions.push(`${uname}.hand.${x}`));\r

  \  return actions;\r

  }"
inno_get_id: function inno_get_id(c) { return normalize_string(c.name); }
inno_get_object_keys: "function inno_get_object_keys(otree) {\r

  \  let keys = {}; for (const k in InnoById) keys[k] = true;\r

  \  for (const k of otree.plorder) keys[k] = true;\r

  \  for (const k of ['decks', 'board', 'splays', 'hand', 'green', 'purple',
  'blue', 'red', 'yellow', 'forecast', 'scored', 'artifact',
  'special_achievements', 'achievements']) keys[k] = true;\r

  \  let decknames = 'ABCEF';\r

  \  for (let i = 0; i < decknames.length; i++) { keys[decknames[i]] = true;
  }\r

  \  for (let age = 1; age <= 10; age++) { keys['' + age] = true; }\r

  \  return keys;\r

  }"
inno_get_phase: function inno_get_phase(iphase) { return INNO.phases[iphase].key; }
inno_get_player_age: "function inno_get_player_age(otree, uname) {\r

  \  let top = inno_get_top_card_info(otree, uname);\r

  \  let maxage = arrMinMax(top, x => x.age).max;\r

  \  return maxage;\r

  }"
inno_get_splay: "function inno_get_splay(otree, path) {\r

  \  let [uname, x, color, y] = path.split('.');\r

  \  let splay = otree[uname].splays[color];\r

  \  return splay;\r

  }"
inno_get_top_card_actions: "function inno_get_top_card_actions(otree, uname) {\r

  \  let keys = inno_get_top_card_keys(otree, uname);\r

  \  let res = keys.map(x =>
  `${uname}.board.${inno_get_cardinfo(x).color}.${x}`);\r

  \  return res;\r

  }"
inno_get_top_card_info: function inno_get_top_card_info(otree, uname) { return
  inno_get_top_card_keys(otree, uname).map(x => inno_get_cardinfo(x)); }
inno_get_top_card_keys: "function inno_get_top_card_keys(otree, uname) {\r

  \  let pl = otree[uname];\r

  \  let board = pl.board;\r

  \  let top = [];\r

  \  for (const k in board) { if (!isEmpty(board[k]))
  top.push(arrFirst(board[k])); }\r

  \  return top;\r

  }"
inno_present_board: "function inno_present_board(dParent, board) {\r

  \  let dBoard = mDiv(dParent, {}, null, 'board');\r

  \  mFlex(dBoard);\r

  \  let boardItemLists = [];\r

  \  for (const color in board) {\r

  \    let cardlist = board[color];\r

  \    let d = mDiv(dBoard);\r

  \    let items = inno_present_cards(d, cardlist);\r

  \    boardItemLists.push(items);\r

  \  }\r

  \  return boardItemLists;\r

  }"
inno_present_card: function inno_present_card(dParent, k) { let card =
  inno_card(dParent, k); card.key = card.info.key; return card; }
inno_present_cards: "function inno_present_cards(dParent, keys) {\r

  \  let items = [];\r

  \  for (const k of keys) {\r

  \    let card = inno_present_card(dParent, k);\r

  \    items.push(card);\r

  \  }\r

  \  return items;\r

  }"
inno_present_hand: "function inno_present_hand(dParent, hand) {\r

  \  let dHand = mDiv(dParent, {}, null, 'hand');\r

  \  mFlexWrap(dHand); mLinebreak(dHand);\r

  \  let handItems = inno_present_cards(dHand, hand);\r

  \  return handItems;\r

  }"
inno_setup: "function inno_setup(player_names) {\r

  \  inno_shuffle_decks();\r

  \  let pre_fen = {};\r

  \  let decks = pre_fen.decks = jsCopy(Dinno);\r

  \  pre_fen.achievements = [];\r

  \  for (const age in decks.B) { last_elem_from_to(decks.B[age],
  pre_fen.achievements); }\r

  \  pre_fen.special_achievements = ['monument', 'empire', 'world', 'wonder',
  'universe', 'legend', 'repute', 'fame', 'glory', 'victory', 'supremacy',
  'destiny', 'wealth', 'heritage', 'history'];\r

  \  let pls = pre_fen.players = {};\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  for (const plname of player_names) {\r

  \    let pl = pls[plname] = {\r

  \      hand: [],\r

  \      board: { blue: [], red: [], green: [], yellow: [], purple: [] },\r

  \      splays: { blue: 0, red: 0, green: 0, yellow: 0, purple: 0 },\r

  \      achievements: [],\r

  \      scored: [],\r

  \      forecast: [],\r

  \      artifact: null\r

  \    };\r

  \    last_elem_from_to(deck1, pl.hand); last_elem_from_to(deck2, pl.hand);\r

  \  }\r

  \  pre_fen.plorder = jsCopy(player_names); \r

  \  let fen = {\r

  \    players: pre_fen.players,\r

  \    decks: pre_fen.decks,\r

  \  };\r

  \  addKeys(pre_fen, fen);\r

  \  return fen; \r

  }"
inno_show_other_player_info: "function inno_show_other_player_info(ev) {\r

  \  console.log('enter', ev.target);\r

  \  let id = evToId(ev);\r

  \  let g = Session;\r

  \  let plname = stringAfter(id, '_');\r

  \  let pl = firstCond(g.players, x => x.name == plname);\r

  \  console.log('player info for', pl);\r

  }"
inno_shuffle_decks: "function inno_shuffle_decks() {\r

  \  for (const exp in Dinno) {\r

  \    for (const age in Dinno[exp]) {\r

  \      shuffle(Dinno[exp][age]);\r

  \    }\r

  \  }\r

  }"
inno_stat_sym: "function inno_stat_sym(key, n, dParent, sz) {\r

  \  let d = mDiv(dParent, { display: 'flex', dir: 'c', fz: sz });\r

  \  let s = mSym(INNO.sym[key].key, d, { h: sz, fz: sz, fg: INNO.sym[key].fg
  });\r

  \  d.innerHTML += `<span>${n}</span>`;\r

  \  return d;\r

  }"
innoAgeNumber: "function innoAgeNumber(n, dParent, sz, pos, margin = 10) {\r

  \  let x = Card.sz * .04; sz -= x; \r

  \  let hOff = 0; \r

  \  let styles = { wmin: sz * 1.1, h: sz, bg: '#131313', align: 'center' };\r

  \  let box = mShape('hexFlat', dParent, styles); mPlace(box, pos, margin,
  margin - hOff / 2); \r

  \  s = mDiv(box, { fz: sz * .6, fg: 'white', display: 'inline-block' },
  null, n);\r

  \  mPlace(s, 'cc'); \r

  \  return box;\r

  }"
innoBonusNumber: "function innoBonusNumber(n, dParent, sz, pos, margin = 10) {\r

  \  let hOff = margin / 2;\r

  \  let styles = { w: sz, h: sz - hOff, bg: 'brown', box: true, align:
  'center' };\r

  \  let box = mShape('circle', dParent, styles); mPlace(box, pos, margin +
  hOff / 2, margin);\r

  \  let dText = mDiv(box, { fz: sz * .1, fg: 'black', 'line-height': sz * .1,
  matop: sz * .05 }, null, 'bonus');\r

  \  let dNum = mDiv(box, { fz: sz * .7, fg: 'black', 'line-height': sz * .65
  }, null, n);\r

  \  return box;\r

  }"
innoEcho: "function innoEcho(text, dParent, sz, pos, margin = 10) {\r

  \  if (isList(text)) text = text.join('<br>');\r

  \  margin /= 2;\r

  \  sz += margin / 4;\r

  \  let box = mDiv(dParent, { w: sz, h: sz, bg: 'black', fg: 'white',
  rounding: 10 });\r

  \  mPlace(box, pos, margin);\r

  \  box.onclick = (ev) => makeInfobox(ev, box, 3);\r

  \  let t2 = innoText(text);\r

  \  mFillText(t2, box);\r

  \  return box;\r

  }"
innoFlag: "function innoFlag(cardType, dParent, sz, pos, margin = 10) {\r

  \  let box = mDiv(dParent, { w: sz, h: sz, bg: INNO.sym.flag.bg, rounding:
  10 }); if (isdef(pos)) mPlace(box, pos, margin);\r

  \  s = mSym(INNO.sym.flag.key, box, { sz: sz * .75, fg:
  INNO.sym[cardType].bg }, 'cc');\r

  \  return box;\r

  }"
innoInspire: "function innoInspire(text, dParent, sz, pos, margin = 10) {\r

  \  if (isList(text)) text = text.join('<br>');\r

  \  margin /= 2;\r

  \  sz += margin / 4;\r

  \  let box = mDiv(dParent, { w: sz, h: sz, bg: '#ffffff80', fg: 'black',
  rounding: 10 });\r

  \  mPlace(box, pos, margin);\r

  \  box.onclick = (ev) => makeInfobox(ev, box, 3);\r

  \  let t2 = innoText(text);\r

  \  mFillText(t2, box);\r

  \  return box;\r

  }"
innoSym: "function innoSym(key, dParent, sz, pos, margin = 10) {\r

  \  let box = mDiv(dParent, { w: sz, h: sz, bg: INNO.sym[key].bg, rounding:
  10 }); if (isdef(pos)) mPlace(box, pos, margin);\r

  \  s = mSym(INNO.sym[key].key, box, { sz: sz * .75, fg: INNO.sym[key].fg },
  'cc');\r

  \  return box;\r

  }"
innoSymInline: "function innoSymInline(key, dParent) {\r

  \  s = mSymInline(INNO.sym[key].key, dParent, { fg: INNO.sym[key].fg, bg:
  INNO.sym[key].bg, rounding: 10 });\r

  \  return s;\r

  }"
innoText: "function innoText(text) {\r

  \  for (const s in INNO.sym) { INNO.sym[s].sym = Syms[INNO.sym[s].key]; }\r

  \  let parts = text.split('[');\r

  \  let s = parts[0];\r

  \  for (let i = 1; i < parts.length; i++) {\r

  \    let part = parts[i];\r

  \    let kw = stringBefore(part, ']');\r

  \    let sp;\r

  \    let fz = Card.sz * .04;\r

  \    if (Object.keys(INNO.sym).includes(kw)) { let o = INNO.sym[kw]; sp =
  makeSymbolSpan(o.sym, o.bg, o.fg, fz * .9, '20%'); }\r

  \    else if (isNumber(kw)) { sp = makeNumberSpan(kw, '#232323', 'white', fz
  * .9, '20%'); }\r

  \    s += sp + stringAfter(part, ']');\r

  \  }\r

  \  return s;\r

  }"
insertColNew: function insertColNew(board, cClick) { return expandBoard(board,
  board.rows, board.cols + 1, cClick + 1); }
insertRowNew: function insertRowNew(board, cClick) { return expandBoard(board,
  board.rows + 1, board.cols, cClick + 1); }
iPresentHand: "function iPresentHand(h, dParent, styles, redo = true) {\r

  \  if (nundef(h.zone)) h.zone = iHandZone(dParent, styles); else
  clearElement(h.zone);\r

  \  if (nundef(h.iHand)) {\r

  \    let items = i52(h.deck.cards());\r

  \    h.iHand = iSplay(items, h.zone);\r

  \  } else if (redo) {\r

  \    clearElement(h.zone);\r

  \    let items = i52(h.deck.cards());\r

  \    h.iHand = iSplay(items, h.zone);\r

  \  }\r

  \  return h;\r

  }"
iPresentHand_test: "function iPresentHand_test(dParent, h, redo = true) {\r

  \  if (nundef(h.zone)) h.zone = iHandZone_test(dParent); else
  clearElement(h.zone);\r

  \  if (nundef(h.iHand)) {\r

  \    let items = i52(h.deck.cards());\r

  \    h.iHand = iSplay(items, h.zone);\r

  \  } else if (redo) {\r

  \    clearElement(h.zone);\r

  \    let items = i52(h.deck.cards());\r

  \    h.iHand = iSplay(items, h.zone);\r

  \  }\r

  \  return h;\r

  }"
iRemakeHand: "function iRemakeHand(data) {\r

  \  let zone = data.zone;\r

  \  let deck = data.deck;\r

  \  let items = i52(deck.cards());\r

  \  clearElement(zone);\r

  \  data.iHand = iSplay(items, zone);\r

  \  return data;\r

  }"
iResize52: function iResize52(i, h) { let w = h * .7; return iResize(i, w, h); }
is_card: function is_card(o) { return isdef(o.rank) || isdef(o.o) && isdef(o.o.rank); }
isOppPiece: function isOppPiece(sym, plSym) { return sym && sym != plSym; }
iSortHand: "function iSortHand(dParent, h) {\r

  \  let d = h.deck;\r

  \  d.sort();\r

  \  iPresentHand(dParent, h);\r

  }"
iSortHand_test: "function iSortHand_test(dParent, h) {\r

  \  let d = h.deck;\r

  \  d.sort();\r

  \  iPresentHand_test(dParent, h);\r

  }"
iSplay52: "function iSplay52(i, iContainer, splay = 'right', ov = 20, ovUnit =
  '%', createiHand = true, rememberFunc = true) {\r

  \  let ilist = !isList(i) ? i : [i];\r

  \  let items = isNumber(i[0]) ? i52(ilist) : ilist;\r

  \  let res = iSplay(items, iContainer, null, 'right', 20, '%', true);\r

  \  return res;\r

  }"
iTableBounds: function iTableBounds(i) { return iBounds(i, dTable); }
iToRowCol: function iToRowCol(idx, rows, cols) { let c = idx % cols; let r =
  (idx - c) / rows; return [r, c]; }
make_goal_set: "function make_goal_set(deck, prob_different) {\r

  \  let [fen1, fen2, fen3] = [deck[0], '', ''];  \r

  \  let n = fen1.length;\r

  \  let different = randomNumber(0, n - 1);\r

  \  for (let i = 0; i < n; i++) {\r

  \    let l1 = fen1[i];\r

  \    let same = i == different ? false : coin(prob_different);\r

  \    let inc = coin() ? 1 : -1;\r

  \    let [l2, l3] = same ? [l1, l1] : ['' + (3 + Number(l1) + inc * 1) % 3,
  '' + (3 + Number(l1) + inc * 2) % 3];\r

  \    fen2 += l2; fen3 += l3;\r

  \  }\r

  \  return [fen1, fen2, fen3];\r

  }"
make_set_deck: "function make_set_deck(n_or_attr_list) {\r

  \  let all_attrs = gSet_attributes();\r

  \  let keys = get_keys(all_attrs);\r

  \  let n = isNumber(n_or_attr_list) ? n_or_attr_list :
  n_or_attr_list.length;\r

  \  let attrs = isNumber(n_or_attr_list) ? arrTake(keys, n) :
  n_or_attr_list;\r

  \  let list = ['0', '1', '2']; \r

  \  let i = 1;\r

  \  while (i < n) {\r

  \    let [l1, l2, l3] = [jsCopy(list), jsCopy(list), jsCopy(list)];\r

  \    l1 = l1.map(x => '0' + x); l2 = l2.map(x => '1' + x); l3 = l3.map(x =>
  '2' + x);\r

  \    list = l1.concat(l2).concat(l3);\r

  \    i++;\r

  \  }\r

  \  return list;\r

  }"
makeEdge: "function makeEdge(dParent, v1, v2, dFromEdge, ew = 20) {\r

  \  let switched = false;\r

  \  if (v1.x == v2.x) {\r

  \    if (v1.y > v2.y) { let h = v2; v2 = v1; v1 = h; switched = true; }\r

  \    let w = ew / 2;\r

  \    let sp = `polygon(${v1.x - w + ew}px ${v1.y + dFromEdge + ew}px, ${v1.x
  + w + ew}px ${v1.y + dFromEdge + ew}px, ${v2.x + w + ew}px ${v2.y - dFromEdge
  + ew}px, ${v2.x - w + ew}px ${v2.y - dFromEdge + ew}px)`;\r

  \    let de = mDiv(dParent, { position: 'absolute', left: -ew, top: -ew, w:
  '120%', h: '120%' });\r

  \    mClass(de, 'edge');\r

  \    mStyle(de, { 'clip-path': sp });\r

  \    return mItem(null, { div: de }, { type: 'edge' }, true);\r

  \  }\r

  \  if (v1.x > v2.x) { let h = v2; v2 = v1; v1 = h; switched = true; }\r

  \  let dx = v2.x - v1.x;\r

  \  let dy = v2.y - v1.y;\r

  \  let m = dy / dx;\r

  \  let [x1, y1, x2, y2] = [v1.x, v1.y, v2.x, v2.y];\r

  \  let alpha = Math.atan(m);\r

  \  let xa = x1 + dFromEdge * Math.cos(alpha);\r

  \  let ya = y1 + dFromEdge * Math.sin(alpha);\r

  \  let xe = x2 - dFromEdge * Math.cos(alpha);\r

  \  let ye = y2 - dFromEdge * Math.sin(alpha);\r

  \  let m2 = -1 / m;\r

  \  let beta = Math.atan(m2);\r

  \  let w = ew / 2;\r

  \  let x1t = xa + w * Math.cos(beta);\r

  \  let y1t = ya + w * Math.sin(beta);\r

  \  let x1b = xa - w * Math.cos(beta);\r

  \  let y1b = ya - w * Math.sin(beta);\r

  \  let x2t = xe + w * Math.cos(beta);\r

  \  let y2t = ye + w * Math.sin(beta);\r

  \  let x2b = xe - w * Math.cos(beta);\r

  \  let y2b = ye - w * Math.sin(beta);\r

  \  let de = mDiv(dParent, { position: 'absolute', left: 0, top: 0, w:
  '120%', h: '120%' });\r

  \  mStyle(de, { 'clip-path': `polygon(${x1t}px ${y1t}px, ${x2t}px ${y2t}px,
  ${x2b}px ${y2b}px, ${x1b}px ${y1b}px)` });\r

  \  mClass(de, 'edge');\r

  \  return mItem(null, { div: de }, { type: 'edge' }, true);\r

  }"
makeInfobox: "function makeInfobox(ev, elem, scale) {\r

  \  let t = ev.target; while (isdef(t) && t != elem) t = t.parentNode; if
  (nundef(t)) { console.log('WRONG click', ev.target); return; }\r

  \  let di = DA.infobox; if (isdef(di)) {\r

  \    let inner = di.innerHTML;\r

  \    di.remove();\r

  \    DA.infobox = null;\r

  \    if (inner == elem.innerHTML) return;\r

  \  }\r

  \  let r = getRectInt(elem, dTable);\r

  \  let d = DA.infobox = mDiv(dTable, {\r

  \    bg: 'black', rounding: 10, fz: 24, position: 'absolute',\r

  \    w: r.w, h: r.h, left: r.l, top: r.t, transform: `scale(${scale})`\r

  \  }, 'dInfoBox', elem.innerHTML);\r

  \  d.innerHTML += '<div style=\"font-size:6px\">click to close</div><br>';\r

  \  d.onclick = () => { d.remove(); DA.infobox = null; }\r

  }"
makeInnoNumberDiv: "function makeInnoNumberDiv(n, fz) {\r

  \  return `<span style='background:white;color:black;padding:2px
  10px;border-radius:50%'>${n}</span>`;\r

  }"
makeInnoSymbolDiv: "function makeInnoSymbolDiv(info, bg, fz = 20) {\r

  \  return `<div
  style='text-align:center;display:inline;background-color:${bg};width:40px;pad\
  ding:2px ${fz / 2}px;\r

  \  font-size:${fz}px;font-family:${info.family}'>${info.text}</div>`;\r

  }"
makeNumberSpan: "function makeNumberSpan(n, bg, fg, fz, rounding = '50%') {\r

  \  return `<span
  style='font-size:${fz}px;background:${bg};color:${fg};padding:0px
  5px;border-radius:${rounding}'>${n}</span>`;\r

  }"
makeSymbolSpan: "function makeSymbolSpan(info, bg, fg, fz, rounding = '50%') {\r

  \  let patop = Math.min(2, fz * .2);\r

  \  let pad = '5% 10%'; pad = '3px 5px'; pad = `${patop}px ${patop * 2}px`;\r

  \  if (info.key == 'queen-crown') pad = `${patop}px ${patop}px ${1}px
  ${patop}px`;\r

  \  else if (info.key == 'leaf') pad = `${1}px ${patop}px ${patop}px
  ${patop}px`;\r

  \  else if (info.key == 'white-tower') pad = `${patop}px ${patop * 2}px
  ${patop - 1}px ${patop * 2}px`;\r

  \  return `<div style='box-sizing:border-box;padding:${pad};min-height:${fz
  +
  3}px;display:inline-block;font-family:${info.family};font-size:${fz}px;backgr\
  ound:${bg};color:${fg};border-radius:${rounding}'>${info.text}</div>`;\r

  }"
mCols: "function mCols(dParent, arr, itemStyles = { bg: 'random' }, rowStyles,
  colStyles, akku) {\r

  \  let d0 = mDiv100(dParent, { display: 'flex', 'justify-content':
  'space-between' }); \r

  \  if (isdef(colStyles)) mStyle(d0, colStyles);\r

  \  for (let i = 0; i < arr.length; i++) {\r

  \    let content = arr[i];\r

  \    if (isList(content)) {\r

  \      d1 = mDiv(d0); \r

  \      mRows(d1, content, itemStyles, rowStyles, colStyles, akku);\r

  \    } else {\r

  \      d1 = mContent(content, d0, itemStyles); \r

  \      akku.push(d1);\r

  \    }\r

  \  }\r

  }"
mColsX: "function mColsX(dParent, arr, itemStyles = { bg: 'random' }, rowStyles,
  colStyles, akku) {\r

  \  let d0 = mDiv100(dParent, { display: 'flex', 'justify-content':
  'space-between' }); \r

  \  if (isdef(colStyles)) mStyle(d0, colStyles);\r

  \  for (let i = 0; i < arr.length; i++) {\r

  \    let content = arr[i];\r

  \    if (isList(content)) {\r

  \      d1 = mDiv(d0); \r

  \      mRowsX(d1, content, itemStyles, rowStyles, colStyles, akku);\r

  \    } else {\r

  \      d1 = mContentX(content, d0, itemStyles); \r

  \      akku.push(d1);\r

  \    }\r

  \  }\r

  }"
mContainerSplay: "function mContainerSplay(d, splay, w, h, num, ov) {\r

  \  if (nundef(splay)) splay = 2;\r

  \  if (!isNumber(splay)) splay = get_splay_number(splay);\r

  \  if (isString(ov) && ov[ov.length - 1] == '%') ov = splay == 0 ? 1 : splay
  == 3 ? Number(ov) * h / 100 : Number(ov) * w / 100;\r

  \  if (splay == 3) {\r

  \    d.style.display = 'grid';\r

  \    d.style.gridTemplateRows = `repeat(${num},${ov}px)`;\r

  \    console.log('HAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLOOOOOOOOOOOOOOOOOO\
  OOOOOOO')\r

  \    d.style.minHeight = `${h + (num - 1) * (ov * 1.1)}px`;\r

  \  } else if (splay == 2 || splay == 1) {\r

  \    d.style.display = 'grid';\r

  \    d.style.gridTemplateColumns = `repeat(${num},${ov}px)`;\r

  \    let wnew = w + (num - 1) * (ov * 1.1);\r

  \    d.style.minWidth = `${w + (num - 1) * (ov * 1.1)}px`;\r

  \  } else if (splay == 0) {\r

  \    d.style.display = 'grid'; ov = .5\r

  \    d.style.gridTemplateColumns = `repeat(${num},${ov}px)`;\r

  \    d.style.minWidth = `${w + (num - 1) * (ov * 1.1)}px`;\r

  \  } else if (splay == 5) { \r

  \    d.style.display = 'grid';\r

  \    d.style.gridTemplateColumns = `${ov}px repeat(${num-1},${ov/2}px)`; \r

  \    d.style.minWidth = `${w + (num) * (ov/2 * 1.1)}px`;\r

  \  } else if (splay == 4) {\r

  \    d.style.position = 'relative';\r

  \    if (nundef(ov)) ov = .5;\r

  \    d.style.minWidth = `${w + (num - 1) * (ov * 1.1)}px`;\r

  \    d.style.minHeight = `${h + (num - 1) * (ov * 1.1)}px`;\r

  \  }\r

  }"
mContainerSplay_WORKS: "function mContainerSplay_WORKS(d, splay, w, h, num, ov)
  {\r

  \  if (!isNumber(splay)) splay = get_splay_number(splay);\r

  \  if (isString(ov) && ov[ov.length - 1] == '%') ov = splay == 0 ? 1 : splay
  == 3 ? Number(ov) * h / 100 : Number(ov) * w / 100;\r

  \  if (splay == 3) {\r

  \    d.style.display = 'grid';\r

  \    d.style.gridTemplateRows = `repeat(${num},${ov}px)`;\r

  \    d.style.height = `${h + (num - 1) * (ov * 1.1)}px`;\r

  \  } else if (splay == 2 || splay == 1) {\r

  \    d.style.display = 'grid';\r

  \    d.style.gridTemplateColumns = `repeat(${num},${ov}px)`;\r

  \    d.style.width = `${w + (num - 1) * (ov * 1.1)}px`;\r

  \  } else if (splay == 0) {\r

  \    d.style.display = 'grid'; ov = .5\r

  \    d.style.gridTemplateColumns = `repeat(${num},${ov}px)`;\r

  \    d.style.width = `${w + (num - 1) * (ov * 1.1)}px`;\r

  \  } else if (splay == 4) {\r

  \    d.style.position = 'relative';\r

  \    if (nundef(ov)) ov = .5;\r

  \    d.style.width = `${w + (num - 1) * (ov * 1.1)}px`;\r

  \    d.style.height = `${h + (num - 1) * (ov * 1.1)}px`;\r

  \  }\r

  }"
mContent: "function mContent(content, dParent, styles) {\r

  \  let d1 = isdef(Syms[content]) ? mSymInDivShrink(content, dParent, styles)
  : mDiv(dParent, styles, null, content);\r

  \  return d1;\r

  }"
mContentX: "function mContentX(content, dParent, styles = { sz: Card.sz / 5, fg:
  'random' }) {\r

  \  let [key, scale] = isDict(content) ? [content.key, content.scale] :
  [content, 1];\r

  \  if (scale != 1) { styles.transform =
  `scale(${scale},${Math.abs(scale)})`; }\r

  \  let dResult = mDiv(dParent);\r

  \  let ds = isdef(Syms[key]) ? mSym(key, dResult, styles) : mDiv(dResult,
  styles, null, key);\r

  \  return dResult;\r

  }"
mFillText: "function mFillText(text, box, padding = 10, perleft = 10, pertop =
  20) {\r

  \  let r = mMeasure(box);\r

  \  let [fz, w, h] = fitFont(text, 14, r.w - padding, r.h - padding);\r

  \  let dText = mDiv(box, {\r

  \    w: w, h: h, fz: fz,\r

  \    position: 'absolute', transform: `translate(-${perleft}%,-${pertop}%)`,
  top: `${pertop}%`, left: `${perleft}%`\r

  \  }, null, text);\r

  \  return dText;\r

  }"
mgPos: "function mgPos(card, el, x = 0, y = 0, unit = '%', anchor = 'center')
  {\r

  \  mAppend(iG(card), el);\r

  \  let box = el.getBBox();\r

  \  console.log('rect', box);\r

  \  el.setAttribute('x', x);\r

  \  el.setAttribute('y', y);\r

  }"
mgShape: "function mgShape(key) {\r\n}"
mgSize: "function mgSize(el, h, w) {\r

  \  el.setAttribute('height', h);\r

  \  if (isdef(w)) el.setAttribute('width', w);\r

  }"
mgSuit: "function mgSuit(key) {\r

  \  let el = gCreate('use');\r

  \  el.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' +
  key);\r

  \  return el;\r

  }"
mgSuit1: "function mgSuit1(card, key, h, x, y) {\r

  \  el = document.createElementNS('http://www.w3.org/2000/svg', 'use');\r

  \  el.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href',
  `#${key}`);\r

  \  el.setAttribute('height', h);\r

  \  el.setAttribute('width', h);\r

  \  el.setAttribute('x', x);\r

  \  el.setAttribute('y', y);\r

  \  mAppend(iG(card), el);\r

  \  return el;\r

  }"
mgSym: "function mgSym(key) {\r

  \  let el = gCreate('text');\r

  \  let info = Syms[key];\r

  \  mStyle(el, { family: info.family });\r

  \  el.innerHTML = info.text;\r

  \  return el;\r

  }"
mItemSplay: "function mItemSplay(item, list, splay, ov = .5) {\r

  \  if (!isNumber(splay)) splay = get_splay_number(splay);\r

  \  let d = iDiv(item);\r

  \  let idx = list.indexOf(item.key);\r

  \  if (splay == 4) {\r

  \    let offset = (list.length - idx) * ov;\r

  \    mStyle(d, { position: 'absolute', left: offset, top: offset }); \r

  \    d.style.zIndex = list.length - idx;\r

  \  } else {\r

  \    d.style.zIndex = splay != 2 ? list.length - idx : 0;\r

  \  }\r

  }"
mPlaceText: "function mPlaceText(text, where, dParent, styles, innerStyles,
  classes) {\r

  \  let box;\r

  \  if (where.length == 4) {\r

  \    let [t, r, b, l] = where;\r

  \    box = mBoxFromMargins(dParent, t, r, b, l);\r

  \  } else if (where.length == 3) {\r

  \    let [wb, hb, place] = where;\r

  \    box = mDiv(dParent, { w: wb, h: hb });\r

  \    mPlace(box, place);\r

  \  }\r

  \  let r = mMeasure(box);\r

  \  let [fz, w, h] = fitFont(text, 20, r.w, r.h);\r

  \  console.log('res', fz, w, h);\r

  \  let dText = mDiv(box, {\r

  \    w: w, h: h, fz: fz,\r

  \    position: 'absolute', transform: 'translate(-50%,-50%)', top: '50%',
  left: '50%'\r

  \  }, null, text);\r

  \  if (isdef(styles)) mStyle(box, styles);\r

  \  if (isdef(innerStyles)) mStyle(dText, innerStyles);\r

  \  if (isdef(classes)) mStyle(box, classes);\r

  \  return box;\r

  }"
mRows: "function mRows(dParent, arr, itemStyles = { bg: 'random' }, rowStyles,
  colStyles, akku) {\r

  \  let d0 = mDiv100(dParent, { display: 'flex', dir: 'column',
  'justify-content': 'space-between' });\r

  \  if (isdef(rowStyles)) mStyle(d0, rowStyles);\r

  \  for (let i = 0; i < arr.length; i++) {\r

  \    let content = arr[i];\r

  \    if (isList(content)) {\r

  \      let d1 = mDiv(d0); \r

  \      mCols(d1, content, itemStyles, rowStyles, colStyles, akku);\r

  \    } else {\r

  \      d1 = mContent(content, d0, itemStyles); \r

  \      akku.push(d1);\r

  \    }\r

  \  }\r

  }"
mRowsX: "function mRowsX(dParent, arr, itemStyles = { bg: 'random' }, rowStyles,
  colStyles, akku) {\r

  \  let d0 = mDiv100(dParent, { display: 'flex', dir: 'column',
  'justify-content': 'space-between' });\r

  \  if (isdef(rowStyles)) mStyle(d0, rowStyles);\r

  \  for (let i = 0; i < arr.length; i++) {\r

  \    let content = arr[i];\r

  \    if (isList(content)) {\r

  \      let d1 = mDiv(d0); \r

  \      mColsX(d1, content, itemStyles, rowStyles, colStyles, akku);\r

  \    } else {\r

  \      d1 = mContentX(content, d0, itemStyles); \r

  \      akku.push(d1);\r

  \    }\r

  \  }\r

  }"
mSymbol: "function mSymbol(key, dParent, sz, styles = {}) {\r

  \  console.log('key', key)\r

  \  let info = symbolDict[key];\r

  \  fzStandard = info.fz;\r

  \  hStandard = info.h[0];\r

  \  wStandard = info.w[0];\r

  \  let fzMax = fzStandard * sz / Math.max(hStandard, wStandard);\r

  \  fzMax *= .9;\r

  \  let fz = isdef(styles.fz) && styles.fz < fzMax ? styles.fz : fzMax;\r

  \  let wi = wStandard * fz / 100;\r

  \  let hi = hStandard * fz / 100;\r

  \  let vpadding = 2 + Math.ceil((sz - hi) / 2); console.log('***vpadding',
  vpadding)\r

  \  let hpadding = Math.ceil((sz - wi) / 2);\r

  \  let margin = '' + vpadding + 'px ' + hpadding + 'px'; //''+vpadding+'px
  '+hpadding+' ';\r

  \  let newStyles = deepmergeOverride({ fz: fz, align: 'center', w: sz, h:
  sz, bg: 'white' }, styles);\r

  \  newStyles.fz = fz;\r

  \  let d = mDiv(dParent, newStyles);\r

  \  console.log(key, info)\r

  \  let txt = mText(info.text, d, { family: info.family });\r

  \  console.log('-----------', margin, hpadding, vpadding);\r

  \  mStyle(txt, { margin: margin, 'box-sizing': 'border-box' });\r

  \  return d;\r

  }"
mSymFramed: "function mSymFramed(info, bg, sz) {\r

  \  let [w, h, fz] = [sz, sz, sz * .7];\r

  \  return mCreateFrom(`<div style='\r

  \  text-align:center;display:inline;background-color:${bg};\r

  \  font-size:${fz}px;overflow:hidden;\r

  \  font-family:${info.family}'>${info.text}</div>`);\r

  }"
mSymInDiv: "function mSymInDiv(sym, dParent, styles = { sz: Card.sz / 5, fg:
  'random' }) {\r

  \  dResult = mDiv(dParent);\r

  \  ds = mSym(sym, dResult, styles);\r

  \  return dResult;\r

  }"
mSymInDivShrink: "function mSymInDivShrink(sym, dParent, styles = { sz: Card.sz
  / 5, fg: 'random' }) {\r

  \  dResult = mDiv(dParent);\r

  \  let ds = mSym(sym, dResult, styles);\r

  \  let scale = chooseRandom([.5, .75, 1, 1.25]);\r

  \  let [scaleX, scaleY] = [coin() ? scale : -scale, scale];\r

  \  if (coin()) ds.style.transform = `scale(${scaleX},${scaleY})`;\r

  \  return dResult;\r

  }"
mSymInline: "function mSymInline(key, dParent, styles) {\r

  \  let info = Syms[key];\r

  \  styles.family = info.family;\r

  \  let el = mSpan(dParent, styles, null, info.text);\r

  \  return text;\r

  }"
mSymSizeToBox: "function mSymSizeToBox(info, w, h) {\r

  \  let fw = w / info.w;\r

  \  let fh = h / info.h;\r

  \  let f = Math.min(fw, fh);\r

  \  return { fz: 100 * f, w: info.w * f, h: info.h * f };\r

  }"
mSymSizeToFz: "function mSymSizeToFz(info, fz) { let f = fz / 100; return { fz:
  fz, w: info.w * f, h: info.h * f }; }"
mSymSizeToH: "function mSymSizeToH(info, h) { let f = h / info.h; return { fz:
  100 * f, w: info.w * f, h: h }; }"
mSymSizeToW: "function mSymSizeToW(info, w) { let f = w / info.w; return { fz:
  100 * f, w: w, h: info.h * f }; }"
mTableCommands: "function mTableCommands(rowitems, di) {\r

  \  let t = rowitems[0].div.parentNode;\r

  \  mTableHeader(t, 'commands');\r

  \  for (const item of rowitems) {\r

  \    let drow = item.div;\r

  \    let dcol = mTableCol(drow);\r

  \    let colitem = { div: dcol, key: 'commands', val: null };\r

  \    item.colitems.push(colitem);\r

  \    let html = '';\r

  \    for (const k in di) {\r

  \      html += di[k](item); \r

  \    }\r

  \    dcol.innerHTML = html;\r

  \  }\r

  }"
name2id: function name2id(name) { return 'd_' + name.split(' ').join('_'); }
neighborhood: "function neighborhood(items, byrc) {\r

  \  let adjList = [];\r

  \  let di = {};\r

  \  for (const info of items) {\r

  \    if (info.type != 'field') continue;\r

  \    let [r, c] = [info.row, info.col];\r

  \    info.nodeItems = [\r

  \      lookup(byrc, [r - 2, c]),\r

  \      lookup(byrc, [r - 1, c + 1]),\r

  \      lookup(byrc, [r + 1, c + 1]),\r

  \      lookup(byrc, [r + 2, c]),\r

  \      lookup(byrc, [r + 1, c - 1]),\r

  \      lookup(byrc, [r - 1, c - 1]),\r

  \    ];\r

  \    info.nodes = info.nodeItems.map(x => isdef(x) ? x.id : null);\r

  \    delete info.nodeItems;\r

  \    for (let i = 0; i < 6; i++) {\r

  \      let n1 = info.nodes[i];\r

  \      if (n1 == null) continue;\r

  \      let n2 = info.nodes[(i + 1 % 6)];\r

  \      if (n2 == null) continue;\r

  \      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;\r

  \      lookupSet(di, [n1, n2], true);\r

  \      adjList.push([n1, n2]);\r

  \    }\r

  \    info.neiItems = [\r

  \      lookup(byrc, [r - 3, c + 1]),\r

  \      lookup(byrc, [r, c + 2]),\r

  \      lookup(byrc, [r + 3, c + 1]),\r

  \      lookup(byrc, [r + 3, c - 1]),\r

  \      lookup(byrc, [r, c - 2]),\r

  \      lookup(byrc, [r - 3, c - 1]),\r

  \    ];\r

  \    info.nei = info.neiItems.map(x => isdef(x) ? x.id : null);\r

  \    delete info.neiItems;\r

  \  }\r

  }"
netHandSize: "function netHandSize(nmax, hCard, wCard, ovPercent = 20, splay =
  'right') {\r

  \  let isHorizontal = splay == 'right' || splay == 'left';\r

  \  if (nundef(hCard)) hCard = 110;\r

  \  if (nundef(wCard)) wCard = Math.round(hCard * .7);\r

  \  return isHorizontal ? { w: wCard + (nmax - 1) * wCard * ovPercent / 100,
  h: hCard } : { w: wCard, h: hCard + (nmax - 1) * hCard * ovPercent / 100 };\r

  }"
onclick_lamp: "function onclick_lamp() {\r

  \  DA.simple = !DA.simple;\r

  \  if (DA.simple) show_simple_ui(); else show_advanced_ui();\r

  \  if (isVisible('dTables')) onclick_tables();\r

  }"
onclick_last_test: "function onclick_last_test() {\r

  \  stop_game();\r

  \  stop_polling();\r

  \  DA.test.iter = 0;\r

  \  DA.test.suiteRunning = false;\r

  \  onclick_ut_n('ari', DA.test.number);\r

  }"
onclick_pause_continue: "function onclick_pause_continue() {\r

  \  let b = mBy('bPauseContinue');\r

  \  clearTimeout(TO.ai);\r

  \  onclick_stoppolling();\r

  \  show_status('game is paused', true);\r

  \  mStyle(b, { fg: 'grey' });\r

  }"
onclick_player_in_gametable: "function onclick_player_in_gametable(uname,
  tablename, rid) {\r

  \  stopgame();\r

  \  U = firstCond(Serverdata.users, x => x.name == uname);\r

  \  send_or_sim({ friendly: tablename, uname: U.name,  }, 'table');\r

  }"
onclick_reset_past: "function onclick_reset_past() { stopgame(); phpPost({ app:
  'simple' }, 'delete_past'); }"
onclick_run_tests: "function onclick_run_tests() {\r

  \  stop_game();\r

  \  stop_polling();\r

  \  shield_on();\r

  \  DA.test.iter = 0;\r

  \  DA.test.suiteRunning = true;\r

  \  if (nundef(DA.test.list)) {\r

  \    console.log('taking default DA.test.list');\r

  \    DA.test.list = [100, 101];\r

  \  }\r

  \  test_engine_run_next(DA.test.list);\r

  }"
onclick_step: "function onclick_step() {\r

  \  DA.test.step = true;\r

  \  DA.test.running = true;\r

  \  if (!isEmpty(DA.chain)) { dachainext(1000); return; }\r

  \  let testnumber = valf(mBy('intestnumber').value, 110);\r

  \  if (!isNumber(testnumber)) testnumber = 110;\r

  \  console.log('test for step is', testnumber);\r

  \  DA.test.number = testnumber;\r

  \  onclick_last_test();\r

  }"
onclick_ut_n: "function onclick_ut_n(g, n) {\r

  \  DA.test.running = true;\r

  \  let [fen, player_names] = window[`${g}_ut${n}_create_staged`]();\r

  \  get_create_staged(fen, { level_setting: 'min' }, player_names);\r

  }"
oneCircleCenters: "function oneCircleCenters(rows, cols, wCell, hCell) {\r

  \  let [w, h] = [cols * wCell, rows * hCell];\r

  \  let cx = w / 2;\r

  \  let cy = h / 2;\r

  \  let centers = [{ x: cx, y: cy }];\r

  \  let n = 8;\r

  \  let radx = cx - wCell / 2;\r

  \  let rady = cy - hCell / 2;\r

  \  let peri = Math.min(radx, rady) * 2 * Math.PI;\r

  \  n = Math.floor(peri / Math.min(wCell, hCell));\r

  \  while (n > 4 && n % 4 != 0 && n % 6 != 0) n -= 1;\r

  \  centers = getEllipsePoints(radx, rady, n)\r

  \  centers = centers.map(pt => ({ x: pt.X + cx, y: pt.Y + cy }));\r

  \  return [centers, wCell * cols, hCell * rows];\r

  }"
placeSymbol: "function placeSymbol(sym, szSym, margin, posStyles) {\r

  \  let d = iDiv(sym);\r

  \  posStyles.position = 'absolute';\r

  \  posStyles.margin = margin;\r

  \  posStyles.h = szSym;\r

  \  posStyles.w = szSym; \r

  \  mStyle(d, posStyles); \r

  }"
printBoard: "function printBoard(arr, rows, cols, reduced = true) {\r

  \  let arrR = boardArrOmitFirstRowCol(arr, rows, cols);\r

  \  let s = toBoardString(arrR, rows, cols);\r

  \  console.log('board', s);\r

  }"
printMatrix: "function printMatrix(arr2d, title = 'result') {\r

  \  let rows = arr2d.length;\r

  \  let cols = arr2d[0].length;\r

  \  let arr = arrFlatten(arr2d);\r

  \  let s = toBoardString(arr, rows, cols);\r

  \  console.log(title, s)\r

  }"
printState: "function printState(state, cols, rows) {\r

  \  let formattedString = '';\r

  \  state.forEach((cell, index) => {\r

  \    formattedString += isdef(cell) ? ` ${cell == '0' ? ' ' : cell} |` :
  '   |';\r

  \    if ((index + 1) % cols == 0) {\r

  \      formattedString = formattedString.slice(0, -1);\r

  \      if (index < rows * cols - 1) {\r

  \        let s = '\\u2015\\u2015\\u2015 '.repeat(cols);\r

  \        formattedString += '\\n' + s + '\\n'; \r

  \      }\r

  \    }\r

  \  });\r

  \  console.log('%c' + formattedString, 'color: #6d4e42;font-size:10px');\r

  \  console.log();\r

  }"
quadCenters: "function quadCenters(rows, cols, wCell, hCell) {\r

  \  let offX = wCell / 2, offY = hCell / 2;\r

  \  let centers = [];\r

  \  let x = 0; y = 0;\r

  \  for (let i = 0; i < rows; i++) {\r

  \    for (let j = 0; j < cols; j++) {\r

  \      let center = { x: x + offX, y: y + offY };\r

  \      centers.push(center);\r

  \      x += wCell;\r

  \    }\r

  \    y += hCell; x = 0;\r

  \  }\r

  \  return [centers, wCell * cols, hCell * rows];\r

  }"
randomC52: function randomC52() { return Card52.getShortString(randomCard52()); }
randomCard52: function randomCard52() { return Card52.random(); }
randomRank: function randomRank() { return Card52.randomRankSuit[0]; }
randomSuit: function randomSuit() { return Card52.randomRankSuit[1]; }
reduceBoard: "function reduceBoard(board, rNew, cNew, iModify) {\r

  \  let [boardArrOld, rOld, cOld] = [board.fields.map(x => isdef(x.item) ?
  x.item.index : null), board.rows, board.cols];\r

  \  let rest = [];\r

  \  if (rOld > rNew) { rest = bGetRow(boardArrOld, iModify, rOld,
  cOld).filter(x => x != null); }\r

  \  else if (cOld > cNew) { rest = bGetCol(boardArrOld, iModify, rOld,
  cOld).filter(x => x != null); }\r

  \  let boardArrNew = new Array(rNew * cNew);\r

  \  for (let r = 0; r < rNew; r++) {\r

  \    for (let c = 0; c < cNew; c++) {\r

  \      let i = iFromRowCol(r, c, rNew, cNew);\r

  \      let x = (rOld != rNew) ? r : c;\r

  \      if (x < iModify) {\r

  \        let iOld = iFromRowCol(r, c, rOld, cOld);\r

  \        boardArrNew[i] = boardArrOld[iOld];\r

  \      }\r

  \      else {\r

  \        let [ir, ic] = (rOld != rNew) ? [r + 1, c] : [r, c + 1];\r

  \        let iOld = iFromRowCol(ir, ic, rOld, cOld);\r

  \        boardArrNew[i] = boardArrOld[iOld];\r

  \      }\r

  \    }\r

  \  }\r

  \  return { rows: rNew, cols: cNew, boardArr: boardArrNew, extras: rest };\r

  }"
removeColNew: function removeColNew(board, cClick) { return reduceBoard(board,
  board.rows, board.cols - 1, cClick); }
removeRowNew: function removeRowNew(board, cClick) { return reduceBoard(board,
  board.rows - 1, board.cols, cClick); }
rPlayerOrder: function rPlayerOrder(players) { return shuffle(jsCopy(players)); }
set_card_constants: "function set_card_constants(w, h, ranks, suits,
  deckletters, numjokers = 0, ovdeck = .25, ovw = '20%', ovh = '20%') {\r

  \  Card = {};\r

  \  Card.sz = valf(h, 300);\r

  \  Card.h = h;\r

  \  Card.w = isdef(w) ? w : Card.sz * .7;\r

  \  Card.gap = Card.sz * .05;\r

  \  Card.ovdeck = ovdeck;\r

  \  Card.ovw = isString(ovw) ? Card.w * firstNumber(ovw) / 100 : ovw;\r

  \  Card.ovh = isString(ovh) ? Card.h * firstNumber(ovh) / 100 : ovh;\r

  \  Card.ranks = valf(ranks, '23456789TJQKA');\r

  \  Card.suits = valf(suits, 'SHDC');\r

  \  Card.decks = valf(deckletters, 'rb'); \r

  \  Card.numdecks = deckletters.length;\r

  \  Card.numjokers = numjokers;\r

  }"
setSymLabel: "function setSymLabel(g, id, key, styles = {}) {\r

  \  if (nundef(Syms[key])) return;\r

  \  let info = Syms[key];\r

  \  console.log('family', info.family);\r

  \  g.setLabel(id, info.text, addKeys({ fz: 40, family: info.family },
  styles));\r

  }"
show_advanced_ui: "function show_advanced_ui() {\r

  \  show('dButtons');\r

  \  show('dTest0');\r

  \  show('dTopAdvanced');\r

  \  DA.testing = true;\r

  \  DA.test = { iter: 0, maxiter: 200, running: false, step: true,
  suiteRunning: false, number: 0, list: [100, 101] };\r

  \  DA.test.list = arrRange(100, 101); \r

  \  DA.test.number = 306; \r

  \  DA.staged_moves = []; DA.iter = 100; DA.auto_moves = {};\r

  }"
show_card: "function show_card(dParent, key, type = 'aristo') {\r

  \  if (type == 'spotit') {\r

  \    Card.sz = 200;\r

  \    let [rows, cols, numCards, setName] = [3, 2, 2, valf(key,
  'animals')];\r

  \    let infos = spotitDeal(rows, cols, numCards, setName); \r

  \    let items = [];\r

  \    for (const info of infos) {\r

  \      let item = spotitCard(info, dParent, { margin: 10 },
  spotitOnClickSymbol);\r

  \      mStyle(iDiv(item), { padding: 12 });\r

  \      items.push(item);\r

  \    }\r

  \  } else if (type == 'aristo') {\r

  \    let card = ari_get_card(valf(key, 'ASr'));\r

  \    mAppend(dParent, iDiv(card))\r

  \  }\r

  }"
show_medium_ui: function show_medium_ui() { DA.testing = false;
  hide('dButtons'); hide('dTest0'); hide('dTopAdvanced'); toggle_games_off(); }
show_settings_orig: "function show_settings_orig(options) {\r

  \  clearElement('dTitleRight');\r

  \  let dParent = mDiv(mBy('dTitleRight'), { display: 'flex', fg: 'red' },
  null, options.mode == 'hotseat' ? 'h' : '');\r

  \  let d = miPic('gear', dParent, { fz: 20, padding: 6, h: 40, box: true,
  matop: 2, rounding: '50%', cursor: 'pointer' });\r

  \  d.onmouseenter = () => show_options_popup(options);\r

  \  d.onmouseleave = hide_options_popup;\r

  }"
show_simple_ui_orig: "function show_simple_ui_orig() {\r

  \  DA.testing = false;\r

  \  hide('dButtons');\r

  \  hide('dTest0');\r

  \  hide('dTopAdvanced');\r

  \  toggle_games_off();\r

  \  toggle_tables_off();\r

  \  toggle_users_on();\r

  }"
show_status_orig: "function show_status_orig(msg = '', stay) {\r

  \  if (isdef(stay)) showFleetingMessage(msg, mBy('dStatus'), { fg: 'red' },
  1000, 0, false);\r

  \  else showFleetingMessage(msg, mBy('dStatus'), { fg: 'black' });  \r

  }"
show_title_left: "function show_title_left(s, styles, funnyLetters = false) {\r

  \  let d = mBy('dTitleLeft');\r

  \  d.innerHTML = `${funnyLetters ? mColorLetters(s) : s}`;\r

  \  if (isdef(styles)) mStyle(d, styles);\r

  }"
show_title_right: "function show_title_right(s, styles, funnyLetters = false)
  {\r

  \  let d = mBy('dTitleRight');\r

  \  d.innerHTML = `${funnyLetters ? mColorLetters(s) : s}`;\r

  \  if (isdef(styles)) mStyle(d, styles);\r

  }"
show_user: "function show_user() {\r

  \  if (isdef(U) && U.name != 'anonymous') {\r

  \    let uname = U.name;\r

  \    let sz = 36;\r

  \    let html = `\r

  \    <div username='${uname}'
  style='display:flex;align-items:center;gap:6px;height:100%'>\r

  \      <img src='../base/assets/images/${uname}.jpg' width='${sz}'
  height='${sz}' class='img_person' style='border:3px solid
  ${U.color};margin:0'>\r

  \      <span>${uname}</span>\r

  \    </div>`;\r

  \    show_title_left(html, { fg: U.color });\r

  \  }\r

  \  else show_home_logo();\r

  }"
show_x_button: "function show_x_button(dParent) {\r

  \  let b = mButton('close', () => hide(dParent), dParent, { maleft: '95%'
  });\r

  }"
showCards: "function showCards(o, type) {\r

  \  let d2 = iDiv(o);\r

  \  if (nundef(type)) type = isdef(o.type) ? o.type : 'hand';\r

  \  let arr = type == 'deck' ? o.deck.cards() : o.cards;\r

  \  let cont = type == 'deck' ? stdDeckContainer(d2, arr.length) :
  startsWith(type, 'cards') ? stdCardsContainer(d2, arr.length) :
  stdHandContainer(d2, arr.length);\r

  \  let items = arr.map(x => Card52.getItem(x % 52));\r

  \  if (endsWith(type, 'Hidden') || type == 'deck') items.map(x =>
  Card52.turnFaceDown(x, BG_CARD_BACK));\r

  \  items.map(x => mAppend(cont, iDiv(x)));\r

  \  return items;\r

  }"
sort_cards_orig: "function sort_cards_orig(hand, bysuit = true, byrank = true)
  {\r

  \  let ranked = hand.map(x => ({ x: x, r: x[0], s: x[1] }));\r

  \  let rankstr = 'A23456789TJQK';\r

  \  if (bysuit && byrank) {\r

  \    sortByFunc(ranked, x => 3 * x.s.charCodeAt(0) + 2 *
  rankstr.indexOf(x.r));\r

  \  } else if (bysuit) {\r

  \    sortByFunc(ranked, x => x.s.charCodeAt(0));\r

  \  } else if (byrank) {\r

  \    sortByFunc(ranked, x => rankstr.indexOf(x.r));\r

  \  }\r

  \  return ranked.map(x => x.x);\r

  }"
splayout: "function splayout(elems, dParent, w, h, x, y, overlap = 20, splay =
  'right') {\r

  \  function splayRight(elems, d, x, y, overlap) {\r

  \    for (const c of elems) {\r

  \      mAppend(d, c);\r

  \      mStyle(c, { position: 'absolute', left: x, top: y });\r

  \      x += overlap;\r

  \    }\r

  \    return [x, y];\r

  \  }\r

  \  function splayLeft(elems, d, x, y, overlap) {\r

  \    x += (elems.length - 2) * overlap;\r

  \    let xLast = x;\r

  \    for (const c of elems) {\r

  \      mAppend(d, c);\r

  \      mStyle(c, { position: 'absolute', left: x, top: y });\r

  \      x -= overlap;\r

  \    }\r

  \    return [xLast, y];\r

  \  }\r

  \  function splayDown(elems, d, x, y, overlap) {\r

  \    for (const c of elems) {\r

  \      mAppend(d, c);\r

  \      mStyle(c, { position: 'absolute', left: x, top: y });\r

  \      y += overlap;\r

  \    }\r

  \    return [x, y];\r

  \  }\r

  \  function splayUp(elems, d, x, y, overlap) {\r

  \    y += (elems.length - 1) * overlap;\r

  \    let yLast = y;\r

  \    for (const c of elems) {\r

  \      mAppend(d, c);\r

  \      mStyle(c, { position: 'absolute', left: x, top: y });\r

  \      y -= overlap;\r

  \    }\r

  \    return [x, yLast];\r

  \  }\r

  \  if (isEmpty(elems)) return { w: 0, h: 0 };\r

  \  mStyle(dParent, { display: 'block', position: 'relative' });\r

  \  [x, y] = (eval('splay' + capitalize(splay)))(elems, dParent, x, y,
  overlap);\r

  \  let isHorizontal = splay == 'right' || splay == 'left';\r

  \  let sz = { w: (isHorizontal ? (x - overlap + w) : w), h: (isHorizontal ?
  h : (y - overlap + h)) };\r

  \  return sz;\r

  }"
spotitCard: "function spotitCard(info, dParent, cardStyles, onClickSym) {\r

  \  let styles = copyKeys({ w: Card.sz, h: Card.sz }, cardStyles);\r

  \  let card = cRound(dParent, cardStyles, info.id);\r

  \  addKeys(info, card);\r

  \  let d = iDiv(card);\r

  \  card.pattern = fillColarr(card.colarr, card.keys);\r

  \  let symStyles = { sz: Card.sz / (card.rows + 1), fg: 'random', hmargin:
  8, vmargin: 4, cursor: 'pointer' };\r

  \  let syms = [];\r

  \  mRows(iDiv(card), card.pattern, symStyles, { 'justify-content': 'center'
  }, { 'justify-content': 'center' }, syms);\r

  \  for (let i = 0; i < info.keys.length; i++) {\r

  \    let key = card.keys[i];\r

  \    let sym = syms[i];\r

  \    card.live[key] = sym;\r

  \    sym.setAttribute('key', key);\r

  \    sym.onclick = onClickSym;\r

  \  }\r

  \  return card;\r

  }"
spotitDeal: "function spotitDeal(rows, cols, numCards, setName) {\r

  \  let colarr = _calc_hex_col_array(rows, cols);\r

  \  let perCard = arrSum(colarr);\r

  \  let nShared = (numCards * (numCards - 1)) / 2;\r

  \  let nUnique = perCard - numCards + 1;\r

  \  let keys = choose(oneWordKeys(KeySets[setName]), nShared + numCards *
  nUnique);\r

  \  let dupls = keys.slice(0, nShared); \r

  \  let uniqs = keys.slice(nShared);\r

  \  let infos = [];\r

  \  for (let i = 0; i < numCards; i++) {\r

  \    let keylist = uniqs.slice(i * nUnique, i * nUnique + nUnique);\r

  \    let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols:
  cols, colarr: colarr };\r

  \    infos.push(info);\r

  \  }\r

  \  let iShared = 0;\r

  \  for (let i = 0; i < numCards; i++) {\r

  \    for (let j = i + 1; j < numCards; j++) {\r

  \      let c1 = infos[i];\r

  \      let c2 = infos[j];\r

  \      let dupl = dupls[iShared++];\r

  \      c1.keys.push(dupl);\r

  \      c1.shares[c2.id] = dupl;\r

  \      c2.shares[c1.id] = dupl;\r

  \      c2.keys.push(dupl);\r

  \    }\r

  \  }\r

  \  for (const info of infos) { shuffle(info.keys); }\r

  \  return infos;\r

  }"
spotitFindCardSharingSymbol: "function spotitFindCardSharingSymbol(card, key)
  {\r

  \  let id = firstCondDict(card.shares, x => x == key);\r

  \  return Items[id];\r

  }"
spotitFindSymbol: function spotitFindSymbol(card, key) { let k =
  firstCondDictKey(card.live, x => x == key); return card.live[k]; }
spotitOnClickSymbol: "function spotitOnClickSymbol(ev) {\r

  \  let keyClicked = evToProp(ev, 'key');\r

  \  let id = evToId(ev);\r

  \  if (isdef(keyClicked) && isdef(Items[id])) {\r

  \    let item = Items[id];\r

  \    console.log('clicked key', keyClicked, 'of card', id, item);\r

  \    if (Object.values(item.shares).includes(keyClicked)) {\r

  \      console.log('success!!!');\r

  \      let otherCard = spotitFindCardSharingSymbol(item, keyClicked);\r

  \      let cardSymbol = ev.target;\r

  \      let otherSymbol = spotitFindSymbol(otherCard, keyClicked);\r

  \      Selected = { success: true, feedbackUI: [cardSymbol, otherSymbol]
  };\r

  \    } else {\r

  \      console.log('fail!!!!!!!!'); \r

  \      let cardSymbol = ev.target;\r

  \      Selected = { success: false, feedbackUI: [cardSymbol] };\r

  \    }\r

  \  }\r

  }"
stdCardsContainer: "function stdCardsContainer(dParent, n, ov = 80, styles = {})
  { return stdRowOverlapContainer(dParent, n, n * ov + 22, ov, addKeys({ paleft:
  20, patop: 10 }, styles)); }"
stdColOverlapContainer: "function stdColOverlapContainer(dParent, n, wGrid,
  wCell, styles) {\r

  \  addKeys({\r

  \    h: wGrid,\r

  \    gap: 0,\r

  \    display: 'inline-grid',\r

  \    'grid-template-rows': `repeat(${n}, ${wCell}px)`\r

  \  }, styles);\r

  \  return mDiv(dParent, styles);\r

  }"
stdDeckContainer: "function stdDeckContainer(dParent, n, ov = .25, styles = {})
  { return stdRowOverlapContainer(dParent, n, 140, ov, addKeys({ padding: 10 },
  styles)); }"
stdGridContainer: "function stdGridContainer(dParent, wCell, styles = {}) {\r

  \  addKeys({\r

  \    wmax: 500,\r

  \    margin: 'auto',\r

  \    padding: 10,\r

  \    gap: 0,\r

  \    display: 'grid',\r

  \    bg: 'green',\r

  \    'grid-template-columns': `repeat(${20}, ${wCell}px)`\r

  \  }, styles);\r

  \  return mDiv(dParent, styles);\r

  }"
stdHandContainer: "function stdHandContainer(dParent, n, ov = 20, styles = {}) {
  return stdRowOverlapContainer(dParent, n, 76 + n * ov + 22, ov, addKeys({
  padding: 10 }, styles)); }"
stdRowOverlapContainer: "function stdRowOverlapContainer(dParent, n, wGrid,
  wCell, styles) {\r

  \  addKeys({\r

  \    w: wGrid,\r

  \    gap: 0,\r

  \    display: 'inline-grid',\r

  \    'grid-template-columns': `repeat(${n}, ${wCell}px)`\r

  \  }, styles);\r

  \  return mDiv(dParent, styles);\r

  }"
stdRowsColsContainer: "function stdRowsColsContainer(dParent, cols, styles = {})
  {\r

  \  addKeys({\r

  \    margin: 'auto',\r

  \    padding: 10,\r

  \    gap: 10,\r

  \    display: 'grid',\r

  \    bg: 'green',\r

  \    'grid-template-columns': `repeat(${cols}, 1fr)`\r

  \  }, styles);\r

  \  return mDiv(dParent, styles);\r

  }"
stringToMatrix: "function stringToMatrix(s, rows, cols) {\r

  \  if (isNumber(s)) s = String(s);\r

  \  let letters = toLetterArray(s);\r

  \  let nums = letters.map(x => Number(x));\r

  \  let matrix = arrToMatrix(nums, rows, cols);\r

  }"
sudokuSampleToIndexMatrix: "function sudokuSampleToIndexMatrix(s, rows, cols)
  {\r

  \  if (isNumber(s)) s = String(s);\r

  \  let letters = toLetterArray(s);\r

  \  let nums = letters.map(x => Number(x));\r

  \  let res = [];\r

  \  for (const n of nums) {\r

  \    if (n === 0) res.push(' ');\r

  \    else res.push(n - 1);\r

  \  }\r

  \  let matrix = arrToMatrix(res, rows, cols);\r

  \  return matrix;\r

  }"
test_add_building: "function test_add_building() {\r

  \  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];\r

  \  let type = rChoose(['farm', 'estate', 'chateau']);\r

  \  add_a_correct_building_to(fen, uname, type);\r

  \  take_turn_fen();\r

  }"
test_add_schwein: "function test_add_schwein() {\r

  \  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];\r

  \  let type = rChoose(['farm', 'estate', 'chateau']);\r

  \  let keys = deck_deal(fen.deck, type[0] == 'f' ? 4 : type[0] == 'e' ? 5 :
  6);\r

  \  fen.players[uname].buildings[type].push({ list: keys, h: null });\r

  \  take_turn_fen();\r

  }"
test_endgame: "function test_endgame() {\r

  \  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];\r

  \  fen.actionsCompleted = [];\r

  \  for (const plname of fen.plorder) {\r

  \    add_a_correct_building_to(fen, plname, 'chateau');\r

  \    add_a_correct_building_to(fen, plname, rChoose(['farm', 'estate',
  'chateau']));\r

  \    if (coin()) add_a_correct_building_to(fen, plname, rChoose(['farm',
  'estate', 'chateau']));\r

  \    fen.actionsCompleted.push(plname);\r

  \  }\r

  \  Z.stage = 5;\r

  \  Z.phase = 'king';\r

  \  take_turn_fen();\r

  }"
test_skip_to_actions: "function test_skip_to_actions() {\r

  \  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];\r

  \  Z.phase = 'king';\r

  \  Z.stage = 5;\r

  \  fen.actionsCompleted = [];\r

  \  let i = arrMinMax(fen.plorder, x => fen.players[x].hand.length).imin;\r

  \  let pl_min_hand = fen.plorder[i];\r

  \  console.log('pl w/ min hand is', pl_min_hand);\r

  \  let pl = fen.players[pl_min_hand];\r

  \  pl.hand = pl.hand.concat(fen.market);\r

  \  fen.market = deck_deal(fen.deck, 2);\r

  \  for (const plname of fen.plorder) {\r

  \    pl = fen.players[plname];\r

  \    let n = rNumber(1, pl.hand.length);\r

  \    pl.stall = pl.hand.splice(0, n);\r

  \  }\r

  \  Z.turn = [fen.plorder[rNumber(0, fen.plorder.length - 1)]];\r

  \  fen.total_pl_actions = fen.num_actions =
  fen.players[Z.turn[0]].stall.length;\r

  \  fen.action_number = 1;\r

  \  take_turn_fen();\r

  }"
test_skip_to_tax: "function test_skip_to_tax() {\r

  \  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];\r

  \  Z.phase = 'jack';\r

  \  Z.stage = 5;\r

  \  let iturn = fen.plorder.length - 1;\r

  \  Z.turn = [fen.plorder[iturn]];\r

  \  fen.actionsCompleted = fen.plorder.slice(0, iturn);\r

  \  console.log('fen.actionsCompleted', fen.actionsCompleted);\r

  \  for (const plname in fen.players) {\r

  \    let pl = fen.players[plname];\r

  \    pl.hand = pl.hand.concat(deck_deal(fen.deck, rNumber(0, 5)));\r

  \  }\r

  \  take_turn_fen();\r

  }"
testanim0: "function testanim0() {\r

  \  let [fen, phase, stage, deck, market] = [Z.fen, Z.phase, Z.stage, Z.deck,
  Z.market];\r

  \  let ms = 400;\r

  \  let item = deck.topmost;\r

  \  mAnimate(iDiv(item), 'transform', [`scale(1,1)`, `scale(0,1)`],\r

  \    () => {\r

  \      if (item.faceUp) face_down(item); else face_up(item);\r

  \      mAnimate(iDiv(item), 'transform', [`scale(0,1)`, `scale(1,1)`],
  null,\r

  \        ms / 2, 'ease-in', 0, 'both');\r

  \    }, ms / 2, 'ease-out', 100, 'both');\r

  }"
testanim1: "function testanim1() {\r

  \  let [fen, phase, deck, market] = [Z.fen, Z.phase, Z.deck, Z.market];\r

  \  DA.qanim = [];\r

  \  let n_market = phase == 'jack' ? 3 : 2;\r

  \  fen.stage = Z.stage = phase == 'jack' ? 12 : phase == 'queen' ? 11 : 4;\r

  \  for (let i = 0; i < n_market; i++) {\r

  \    DA.qanim = DA.qanim.concat([\r

  \      [qanim_flip_topmost, [deck]],\r

  \      [qanim_move_topmost, [deck, market]],\r

  \      [q_move_topmost, [deck, market]],\r

  \    ]);\r

  \  }\r

  \  DA.qanim.push([q_mirror_fen, ['deck', 'market']]);\r

  \  DA.qanim.push([ari_pre_action, []]);\r

  \  qanim();\r

  }"
testjourney0: "function testjourney0() {\r

  \  let [fen, uname] = [Z.fen, Z.uname];\r

  \  let plist = find_players_with_potential_journey(fen);\r

  \  console.log('journey players', plist);\r

  \  if (!plist.includes(uname)) {\r

  \    set_nextplayer_after_journey(); \r

  \    console.log('Z.turn', Z.turn)\r

  \    take_turn_fen();\r

  \  }\r

  }"
testSplitIntoNumbersAndWords: "function testSplitIntoNumbersAndWords() {\r

  \  let ss = ['1k 2queen', '1 k 12 q', '12king2queen', '31 ace 2queen', '1 3
  3 4', '1 10 3 8', '1J3As', '12 koenig 2 Ass'];\r

  \  for (const s of ss) {\r

  \    let x = splitIntoNumbersAndWords(s);\r

  \  }\r

  }"
toBoardString: "function toBoardString(arr, rows, cols) {\r

  \  let s = '\\n';\r

  \  for (let r = 0; r < rows; r++) {\r

  \    for (let c = 0; c < cols; c++) {\r

  \      let item = arr[r * cols + c];\r

  \      s += '' + (nundef(item) ? '_' : item) + ' ';\r

  \    }\r

  \    s += '\\n';\r

  \  }\r

  \  return s;\r

  }"
toggle_games_off: "function toggle_games_off() { let a = mBy('aGames');
  hide('dGames'); mStyle(a, { bg: 'silver' }); }"
toggle_games_on: "function toggle_games_on() { let a = mBy('aGames'); mStyle(a,
  { bg: 'skyblue' }); }"
toggle_tables_off: "function toggle_tables_off() { let a = mBy('aTables');
  hide('dTables'); mStyle(a, { bg: 'silver' }); }"
toggle_tables_on: "function toggle_tables_on() { let a = mBy('aTables');
  mStyle(a, { bg: '#afe78f' }); } //'lightgreen' }); }"
toggle_users_off: "function toggle_users_off() { let a = mBy('aUsers');
  hide('dUsers'); mStyle(a, { bg: 'silver' }); }"
toggle_users_on: "function toggle_users_on() { let a = mBy('aUsers'); mStyle(a,
  { bg: 'coral' }); }"
useSymbolElemNO: "function useSymbolElemNO(key = 'Treff', h = 50, x = 0, y = 0)
  {\r

  \  return mCreateFrom(`<use xlink:href=\"#${key}\" height=\"${h}\"
  x=\"${x}\" y=\"${y}\"></use>`);\r

  }"
onclick_ack: "function onclick_ack() {\r

  \  if (nundef(Z) || nundef(Z.func.clear_ack)) return;\r

  \  Z.func.clear_ack();\r

  }"
onclick_advanced_menu: function onclick_advanced_menu() { DA.showTestButtons =
  toggle_visibility('dTestButtons'); }
onclick_advanced_mode: function onclick_advanced_mode() { Clientdata.mode = toggle_mode(); }
onclick_advanced_test: "function onclick_advanced_test() {\r

  \  DA.showTestButtons = toggle_visibility('dTestButtons');\r

  \  style_advanced_button();\r

  }"
onclick_by_rank: "function onclick_by_rank() {\r

  \  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A,
  Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];\r

  \  let items = ui_get_hand_items(uplayer).map(x => x.o);\r

  \  let h = UI.players[uplayer].hand;\r

  \  pl.handsorting = 'rank'; \r

  \  Clientdata.handsorting = pl.handsorting;\r

  \  localStorage.setItem('handsorting', Clientdata.handsorting);\r

  \  let cardcont = h.cardcontainer;\r

  \  let ch = arrChildren(cardcont);\r

  \  ch.map(x => x.remove());\r

  \  let sorted = sortCardItemsByRank(items, Z.func.rankstr);
  //window[Z.game.toUpperCase()].rankstr); //'23456789TJQKA*');\r

  \  h.sortedBy = 'rank';\r

  \  for (const item of sorted) {\r

  \    mAppend(cardcont, iDiv(item));\r

  \  }\r

  }"
onclick_by_suit: "function onclick_by_suit() {\r

  \  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A,
  Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];\r

  \  let items = ui_get_hand_items(uplayer).map(x => x.o);\r

  \  let h = UI.players[uplayer].hand;\r

  \  Clientdata.handsorting = pl.handsorting = 'suit'; \r

  \  localStorage.setItem('handsorting', Clientdata.handsorting);\r

  \  let cardcont = h.cardcontainer;\r

  \  let ch = arrChildren(cardcont);\r

  \  ch.map(x => x.remove());\r

  \  let sorted = sortCardItemsByRank(items, Z.func.rankstr);
  //'23456789TJQKA*');\r

  \  sorted = sortCardItemsBySuit(sorted);\r

  \  h.sortedBy = 'suit';\r

  \  for (const item of sorted) {\r

  \    mAppend(cardcont, iDiv(item));\r

  \  }\r

  }"
onclick_cancelmenu: function onclick_cancelmenu() { hide('dMenu'); }
onclick_experience: "function onclick_experience() {\r

  \  let [fen, uplayer] = [Z.fen, Z.uplayer];\r

  \  let plnames = get_other_players();\r

  \  let nums = range(1, fen.players[uplayer].experience);\r

  \  if (isEmpty(nums)) { show_special_message('you dont have any experience
  points!'); return; }\r

  \  show_special_popup('select player and number of experience points to
  gift:', send_experience_points, {}, plnames, nums);\r

  }"
onclick_game_menu_item: function onclick_game_menu_item(ev) { show_game_menu(ev_to_gname(ev)); }
onclick_home: function onclick_home() { stopgame(); start_with_assets(); }
onclick_logout: "function onclick_logout() {\r

  \  mFadeClearShow('dAdminRight', 300);\r

  \  mClear('dAdminMiddle');\r

  \  stopgame();\r

  \  clear_screen();\r

  \  U = null;\r

  \  show_users();\r

  }"
onclick_random: "function onclick_random() {\r

  \  if (uiActivated && !DA.ai_is_moving) ai_move(300);\r

  \  else if (!uiActivated) console.log('NOP: ui not activated...');\r

  \  else if (DA.ai_is_moving) console.log('NOP: ai is (or was already)
  moving...');\r

  \  else console.log('NOP: unknown...');\r

  }"
onclick_reload: "function onclick_reload() {\r

  \  if (isdef(Z)) {\r

  \    if (Z.game == 'fritz' && nundef(Z.fen.winners)) {\r

  \      console.log(Z);\r

  \      Z.fen.players[Z.uplayer].time_left = stop_timer();\r

  \      take_turn_fen();\r

  \    } else {\r

  \      FORCE_REDRAW = true; send_or_sim({ friendly: Z.friendly, uname:
  Z.uplayer, auto: false }, 'table');\r

  \    }\r

  \  } else if (U) { onclick_tables(); }\r

  \  else { show_users(); }\r

  }"
onclick_reload_after_switching: function onclick_reload_after_switching() {
  DA.pollCounter = 0; DA.reloadColor = rColor(); onclick_reload(); }
onclick_remove_host: "function onclick_remove_host() {\r

  \  let [role, host, game, fen, uplayer, turn, stage] = [Z.role, Z.host,
  Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];\r

  }"
onclick_reset_all: "function onclick_reset_all() { stopgame(); phpPost({ app:
  'simple' }, 'delete_tables'); }"
onclick_restart: "function onclick_restart() {\r

  \  let [game, fen, plorder, host] = [Z.game, Z.fen, Z.plorder, Z.host];\r

  \  Z.scoring = {};\r

  \  if (nundef(fen.original_players)) fen.original_players = fen.players;\r

  \  let playernames = [host].concat(get_keys(fen.original_players).filter(x
  => x != host));\r

  \  let playmodes = playernames.map(x => fen.original_players[x].playmode);\r

  \  let strategies = playernames.map(x =>
  fen.original_players[x].strategy);\r

  \  let default_options = {}; for (const k in Config.games[game].options)
  default_options[k] = arrLast(Config.games[game].options[k].split(','));\r

  \  addKeys(default_options, Z.options);\r

  \  fen = Z.fen = Z.func.setup(playernames, Z.options);\r

  \  [Z.plorder, Z.stage, Z.turn, Z.round, Z.step, Z.phase] = [fen.plorder,
  fen.stage, fen.turn, 1, 1, fen.phase];\r

  \  if (DA.TESTSTART1) Z.turn = fen.turn = [Z.host];\r

  \  let i = 0; playernames.map(x => { let pl = fen.players[x]; pl.name = x;
  pl.strategy = strategies[i]; pl.playmode = playmodes[i++]; });\r

  \  take_turn_fen_clear();\r

  }"
onclick_restart_move: function onclick_restart_move() { clear_transaction(); onclick_reload(); }
onclick_skip: "function onclick_skip() {\r

  \  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer,
  Z.turn, Z.stage];\r

  \  if (game == 'spotit') return;\r

  \  else if (game == 'bluff' && stage == 1 || game == 'ferro' && stage ==
  'auto_ack') { onclick_ack(); }\r

  \  else if (game == 'aristo') {\r

  \    Z.uplayer = Z.turn[0];\r

  \    Z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null,
  breadcrumbs: [], sib: [], command: null };\r

  \    copyKeys(jsCopy(Z.fen), Z);\r

  \    copyKeys(UI, Z);\r

  \    activate_ui(Z);\r

  \    Z.func.activate_ui();\r

  \    ai_move();\r

  \  } else {\r

  \    let plskip = Z.turn[0];\r

  \    Z.turn = [get_next_player(Z, plskip)];\r

  \    Z.uplayer = plskip;\r

  \    take_turn_fen();\r

  \  }\r

  }"
onclick_skip_membership_selection: "function onclick_skip_membership_selection()
  {\r

  \  let [game, A, fen, uplayer, plorder] = [Z.game, Z.A, Z.fen, Z.uplayer,
  Z.plorder];\r

  \  for (const pld of Z.playerdata) {\r

  \    if (isDict(pld.state)) continue;\r

  \    let plname = pld.name;\r

  \    let pl = fen.players[plname];\r

  \    pld.state = { item: rChoose(pl.hand) };\r

  \  }\r

  \  relegate_to_host(Z.playerdata);\r

  }"
onclick_start_spotit: "function onclick_start_spotit() {\r

  \  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer,
  Z.turn, Z.stage];\r

  \  Z.stage = 'move';\r

  \  Z.turn = jsCopy(Z.plorder);\r

  \  take_turn_fen();\r

  }"
onclick_status: function onclick_status() { query_status(); }
onclick_table: "function onclick_table(tablename) {\r

  \  send_or_sim({ friendly: tablename, uname: U.name }, 'table');\r

  }"
onclick_tables: "function onclick_tables() { phpPost({ app: 'simple' }, 'tables'); }"
onclick_tithe_all: "function onclick_tithe_all() {\r

  \  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer,
  Z.turn, Z.stage];\r

  \  for (const plname in fen.players) {\r

  \    let pl = fen.players[plname];\r

  \    if (isdef(pl.tithes)) { continue; }\r

  \    pl.tithes = { val: rNumber(8, 10) };\r

  \  }\r

  \  proceed_to_newcards_selection();\r

  }"
onclick_user: "function onclick_user(uname) {\r

  \  U = firstCond(Serverdata.users, x => x.name == uname);\r

  \  localStorage.setItem('uname', U.name);\r

  \  DA.secretuser = U.name;\r

  \  let elem = firstCond(arrChildren('dUsers'), x =>
  x.getAttribute('username') == uname);\r

  \  let img = elem.children[0];\r

  \  mShrinkTranslate(img, .75, 'dAdminRight', 400, show_username);\r

  \  mFadeClear('dUsers', 300);\r

  }"
onclick_view_buildings: "function onclick_view_buildings() {\r

  \  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer,
  Z.turn, Z.stage];\r

  \  let buildings = UI.players[uplayer].buildinglist;\r

  \  for (const b of buildings) b.items.map(x => face_up(x));\r

  \  TO.buildings = setTimeout(hide_buildings, 5000);\r

  }"
onclick_vote_1: "function onclick_vote_1() {\r

  \  let [game, A, fen, uplayer, plorder] = [Z.game, Z.A, Z.fen, Z.uplayer,
  Z.plorder];\r

  \  let pld = Z.playerdata.filter(x => !isDict(x.state));\r

  \  let pld1 = rChoose(pld);\r

  \  pld1.state = { item: rChoose(fen.players[pld1.name].hand) };\r

  \  relegate_to_host(Z.playerdata);\r

  }"
onclick_vote_empty: "function onclick_vote_empty() {\r

  \  let [game, A, fen, uplayer, plorder] = [Z.game, Z.A, Z.fen, Z.uplayer,
  Z.plorder];\r

  \  for (const pld of Z.playerdata) {\r

  \    if (isDict(pld.state)) continue;\r

  \    pld.state = { item: '' };\r

  \  }\r

  \  relegate_to_host(Z.playerdata);\r

  }"
onclick_vote_president: "function onclick_vote_president() {\r

  \  let [game, A, fen, uplayer, plorder] = [Z.game, Z.A, Z.fen, Z.uplayer,
  Z.plorder];\r

  \  let pls = rChoose(Z.turn, 2);\r

  \  let pld0 = Z.playerdata.find(x => x.name == pls[0]);\r

  \  let pld1 = Z.playerdata.find(x => x.name == pls[1]);\r

  \  pld0.state = { item: get_random_ballot_card() };\r

  \  pld1.state = { item: get_random_ballot_card() };\r

  \  relegate_to_host(Z.playerdata);\r

  }"
onclick_vote_random: "function onclick_vote_random() {\r

  \  let [game, A, fen, uplayer, plorder] = [Z.game, Z.A, Z.fen, Z.uplayer,
  Z.plorder];\r

  \  for (const pld of Z.playerdata) {\r

  \    if (isDict(pld.state)) continue;\r

  \    let plname = pld.name;\r

  \    let pl = fen.players[plname];\r

  \    pld.state = { item: (coin() ? '' : rChoose(pl.hand)) };\r

  \  }\r

  \  relegate_to_host(Z.playerdata);\r

  }"
onclick_vote_red: "function onclick_vote_red() {\r

  \  let [game, A, fen, uplayer, plorder] = [Z.game, Z.A, Z.fen, Z.uplayer,
  Z.plorder];\r

  \  for (const pld of Z.playerdata) {\r

  \    if (isDict(pld.state)) continue;\r

  \    let plname = pld.name;\r

  \    let pl = fen.players[plname];\r

  \    let list = pl.hand.filter(x => get_color_of_card(x) == 'red');\r

  \    pld.state = { item: isEmpty(list) ? '' : rChoose(list) };\r

  \  }\r

  \  relegate_to_host(Z.playerdata);\r

  }"
style_advanced_button: "function style_advanced_button(){\r

  \  let b = mBy('dAdvancedUI').children[0];\r

  \  if (DA.showTestButtons) { b.innerHTML = ' '; mStyle(b, {
  bg:GREEN,opacity:1 });} \r

  \  else { b.innerHTML = ' '; mStyle(b, { bg:'silver',opacity:.5 });} \r

  }"
style_not_playing: "function style_not_playing(item, game, list) {\r

  \  let ui = iDiv(item); let uname = ui.getAttribute('username');\r

  \  mStyle(ui, { bg: 'transparent', fg: 'black' });\r

  \  arrLast(arrChildren(ui)).innerHTML = uname;\r

  \  item.ifunc = 0; item.playmode = 'none'; removeInPlace(list, item);\r

  \  item.isSelected = false;\r

  }"
style_playing_as_bot: "function style_playing_as_bot(item, game, list) {\r

  \  let ui = iDiv(item); let uname = ui.getAttribute('username'); let bg =
  get_game_color(game);\r

  \  mStyle(ui, { bg: bg, fg: colorIdealText(bg) });\r

  \  arrLast(arrChildren(ui)).innerHTML = uname.substring(0, 3) + 'bot';\r

  \  item.ifunc = 2; item.playmode = 'bot';\r

  \  item.isSelected = true;\r

  }"
style_playing_as_human: "function style_playing_as_human(item, game, list) {\r

  \  let ui = iDiv(item); let uname = ui.getAttribute('username');\r

  \  mStyle(ui, { bg: get_user_color(uname), fg:
  colorIdealText(get_user_color(uname)) });\r

  \  arrLast(arrChildren(ui)).innerHTML = uname;\r

  \  item.ifunc = 1; item.playmode = 'human'; list.push(item);\r

  \  item.isSelected = true;\r

  }"
test_start_aristo: "function test_start_aristo(n = 3, mode = 'multi') {\r

  \  let game = 'aristo';\r

  \  let playernames = arrTake(['mimi', 'felix', 'amanda', 'lauren', 'gul',
  'nasi'], n);\r

  \  let playmodes = ['human', 'human', 'human', 'human', 'human', 'human'];\r

  \  let strategies = ['random', 'random', 'random', 'random', 'random',
  'random', 'random'];\r

  \  let i = 0; let players = playernames.map(x => ({ name: x, strategy:
  strategies[i], playmode: playmodes[i++] }));\r

  \  let options = { mode: mode, commission: 'no' };\r

  \  startgame(game, players, options);\r

  }"
test_start_ferro: "function test_start_ferro(mode = 'multi') {\r

  \  let game = 'ferro';\r

  \  let playernames = ['mimi', 'lauren', 'felix'];\r

  \  let playmodes = ['human', 'human', 'human'];\r

  \  let strategies = ['random', 'random', 'random'];\r

  \  let i = 0; let players = playernames.map(x => ({ name: x, strategy:
  strategies[i], playmode: playmodes[i++] }));\r

  \  let options = { mode: mode, thinking_time: 20 };\r

  \  startgame(game, players, options);\r

  }"
toggle_select: "function toggle_select(item, funcs) {\r

  \  let params = [...arguments];\r

  \  let ifunc = (valf(item.ifunc, 0) + 1) % funcs.length; let f =
  funcs[ifunc]; f(item, ...params.slice(2));\r

  }"
add_transaction: "function add_transaction(cmd) {\r

  \  if (!DA.simulate) start_transaction();\r

  \  DA.transactionlist.push(cmd);\r

  }"
ari_make_selectable: "function ari_make_selectable(item, dParent, dInstruction)
  {\r

  \  let A = Z.A;\r

  \  switch (item.itemtype) {\r

  \    case 'card': make_card_selectable(item); break;\r

  \    case 'container': make_container_selectable(item); break;\r

  \    case 'player': make_container_selectable(item); break;\r

  \    case 'string': make_string_selectable(item); break;\r

  \  }\r

  }"
ari_make_selected: "function ari_make_selected(item) {\r

  \  let A = Z.A;\r

  \  switch (item.itemtype) {\r

  \    case 'card': make_card_selected(item); break;\r

  \    case 'container': make_container_selected(item); break;\r

  \    case 'player': make_container_selected(item); break;\r

  \    case 'string': make_string_selected(item); break;\r

  \  }\r

  }"
ari_make_unselectable: "function ari_make_unselectable(item) {\r

  \  let A = Z.A;\r

  \  switch (item.itemtype) {\r

  \    case 'card': make_card_unselectable(item); break;\r

  \    case 'container': make_container_unselectable(item); break;\r

  \    case 'player': make_container_unselectable(item); break;\r

  \    case 'string': make_string_unselectable(item); break;\r

  \  }\r

  }"
ari_make_unselected: "function ari_make_unselected(item) {\r

  \  let A = Z.A;\r

  \  switch (item.itemtype) {\r

  \    case 'card': make_card_unselected(item); break;\r

  \    case 'container': make_container_unselected(item); break;\r

  \    case 'player': make_container_unselected(item); break;\r

  \    case 'string': make_string_unselected(item); break;\r

  \  }\r

  }"
clear_selection: "function clear_selection() {\r

  \  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A,
  Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];\r

  \  if (nundef(Z.A) || isEmpty(A.selected)) return;\r

  \  let selitems = A.selected.map(x => A.items[x]);\r

  \  for (const item of selitems) { ari_make_unselected(item); }\r

  \  A.selected = [];\r

  }"
clear_transaction: function clear_transaction() { DA.simulate = false; DA.transactionlist = []; }
continue_after_error: "function continue_after_error() {\r

  \  dError.innerHTML = ''; if (isdef(DA.callback)) { DA.callback(); delete
  (DA.callback); }\r

  }"
make_card_selectable: "function make_card_selectable(item) { \r

  \  let d = iDiv(item.o); \r

  \  mClass(d, 'selectable'); \r

  \  if (Z.game != 'aristo') { spread_hand(item.path, .3); } \r

  \  mClass(d.parentNode, 'selectable_parent'); \r

  }"
make_card_selected: "function make_card_selected(item) {\r

  \  let color = isdef(Z.func.get_selection_color) ?
  Z.func.get_selection_color(item) : 'red';\r

  \  set_card_border(item, 13, color);\r

  \  if (DA.magnify_on_select) mClass(iDiv(item.o), 'mag');\r

  }"
make_card_unselectable: function make_card_unselectable(item) { let d =
  iDiv(item.o); d.onclick = null; mClassRemove(d, 'selectable');
  mClassRemove(d.parentNode, 'selectable_parent'); spread_hand(item.path); }
make_card_unselected: function make_card_unselected(item) {
  set_card_border(item); if (DA.magnify_on_select) mClassRemove(iDiv(item.o),
  'mag'); }
make_container_selectable: function make_container_selectable(item) { let d =
  iDiv(item); mClass(d, 'selectable'); mClass(d, 'selectable_parent'); }
make_container_selected: function make_container_selected(item) { let d =
  iDiv(item); mClass(d, 'selected_parent'); }
make_container_unselectable: function make_container_unselectable(item) { let d
  = iDiv(item); d.onclick = null; mClassRemove(d, 'selectable'); mClassRemove(d,
  'selectable_parent'); }
make_container_unselected: function make_container_unselected(item) { let d =
  iDiv(item); mClassRemove(d, 'selected_parent'); }
make_deck_selectable: function make_deck_selectable(item) { }
make_deck_selected: function make_deck_selected(item) { }
make_deck_unselectable: function make_deck_unselectable(item) { }
make_deck_unselected: function make_deck_unselected(item) { }
make_hand_selectable: function make_hand_selectable(item) { }
make_hand_selected: function make_hand_selected(item) { }
make_hand_unselectable: function make_hand_unselectable(item) { }
make_hand_unselected: function make_hand_unselected(item) { }
make_market_selectable: function make_market_selectable(item) { }
make_market_selected: function make_market_selected(item) { }
make_market_unselectable: function make_market_unselectable(item) { }
make_market_unselected: function make_market_unselected(item) { }
make_string_selectable: function make_string_selectable(item) { let d =
  mBy(item.id); mClass(d, 'selectable_button'); }
make_string_selected: "function make_string_selected(item) { let d =
  mBy(item.id); item.bg = mGetStyle(d, 'bg'); item.fg = mGetStyle(d, 'fg');
  mStyle(d, { bg: 'yellow', fg: 'black' }); }"
make_string_unselectable: function make_string_unselectable(item) { let d =
  mBy(item.id); d.onclick = null; mClassRemove(d, 'selectable_button'); }
make_string_unselected: "function make_string_unselected(item) { let d =
  mBy(item.id); mStyle(d, { bg: item.bg, fg: item.fg }); }"
pack_table: "function pack_table(o) {\r

  \  for (const k of ['players', 'fen', 'state', 'player_status', 'options',
  'scoring', 'notes', 'turn']) {\r

  \    let val = o[k];\r

  \    if (isdef(val)) o[k] = JSON.stringify(val);\r

  \  }\r

  \  return JSON.stringify({ table: o, playerdata:
  JSON.stringify(o.playerdata) });\r

  }"
remove_from_selection: "function remove_from_selection(card) {\r

  \  if (nundef(Z.A)) return;\r

  \  let A = Z.A;\r

  \  let item = firstCond(A.items, x => x.id == card.id);\r

  \  if (isdef(item)) {\r

  \    let idx = item.index;\r

  \    A.items.splice(item.index, 1);\r

  \    removeInPlace(A.selected, item.index);\r

  \    make_card_unselectable(item);\r

  \    make_card_unselected(item);\r

  \    reindex_items(A.items);\r

  \  }\r

  }"
restart_selection_process: "function restart_selection_process() {\r

  \  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A,
  Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];\r

  \  if (Z.game != 'ferro') {\r

  \    console.log('attempt to restart selection process in non-ferro
  game!!!');\r

  \    return;\r

  \  }\r

  \  A.selectedCards.map(x => ari_make_unselected(x));\r

  \  mClear('dSelections0');\r

  \  Z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null,
  breadcrumbs: [], sib: [], command: null };\r

  \  Z.stage = 'card_selection';\r

  \  ferro_pre_action();\r

  }"
select_add_items: "function select_add_items(items, callback = null, instruction
  = null, min = 0, max = 100, prevent_autoselect = false) { \r

  \  let A = Z.A;\r

  \  select_clear_previous_level();\r

  \  A.level++; A.items = items; A.callback = callback; A.selected = [];
  A.minselected = min; A.maxselected = max;\r

  \  show_progress();\r

  \  let dInstruction = mBy('dSelections0');\r

  \  mClass(dInstruction, 'instruction');\r

  \  mCenterCenterFlex(dInstruction);\r

  \  dInstruction.innerHTML = (Z.role == 'active' ?
  `${get_waiting_html()}<span
  style=\"color:red;font-weight:bold;max-height:25px\">You</span>` :
  `${Z.uplayer}`) + \"&nbsp;\" + instruction; \r

  \  if (too_many_string_items(A)) { mLinebreak(dInstruction, 4); } \r

  \  let has_submit_items = false;\r

  \  let buttonstyle = { maleft: 10, vmargin: 2, rounding: 6, padding: '4px
  12px 5px 12px', border: '0px solid transparent', outline: 'none' }\r

  \  for (const item of A.items) {\r

  \    let type = item.itemtype = is_card(item) ? 'card' : is_player(item.a)?
  'player': isdef(item.o) ? 'container' : is_color(item.a)? 'color' : 'string';
  \r

  \    if (isdef(item.submit_on_click)) { has_submit_items = true; }\r

  \    let id = item.id = lookup(item, ['o', 'id']) ? item.o.id : getUID();
  A.di[id] = item;\r

  \    if (type == 'string' || type == 'color') { \r

  \      let handler = ev => select_last(item, isdef(item.submit_on_click) ?
  callback : select_toggle, ev);\r

  \      item.div = mButton(item.a, handler, dInstruction, buttonstyle, null,
  id);\r

  \      if (type == 'color') mStyle(item.div,{bg:item.a,fg:'contrast'});\r

  \    } else {\r

  \      let ui = item.div = iDiv(item.o);\r

  \      ui.onclick = ev => select_last(item, select_toggle, ev); \r

  \      ui.id = id;\r

  \    }\r

  \  }\r

  \  let show_submit_button = !has_submit_items && (A.minselected !=
  A.maxselected || !A.autosubmit);\r

  \  if (show_submit_button) { mButton('submit', callback, dInstruction,
  buttonstyle, 'selectable_button', 'bSubmit'); }\r

  \  let show_restart_button = A.level > 1; \r

  \  if (show_restart_button) { mButton('restart', onclick_reload,
  dInstruction, buttonstyle, 'selectable_button', 'bReload'); }\r

  \  let dParent = window[`dActions${A.level}`];\r

  \  for (const item of A.items) { ari_make_selectable(item, dParent,
  dInstruction); }\r

  \  assertion(A.items.length >= min, 'less options than min selection!!!!',
  A.items.length, 'min is', min); \r

  \  if (A.items.length == min && !is_ai_player() && !prevent_autoselect) {\r

  \    for (const item of A.items) { A.selected.push(item.index);
  ari_make_selected(item); }\r

  \    if (A.autosubmit) {\r

  \      loader_on();\r

  \      setTimeout(() => { if (callback) callback(); loader_off(); }, 800);\r

  \    }\r

  \  } else if (is_ai_player()) {\r

  \    ai_move();\r

  \  } else if (TESTING && isdef(DA.test)) {\r

  \    if (DA.test.iter >= DA.auto_moves.length) {\r

  \      if (isdef(DA.test.end)) DA.test.end();\r

  \      activate_ui();\r

  \      return;\r

  \    }\r

  \    let selection = DA.auto_moves[DA.test.iter++];\r

  \    if (selection) {\r

  \      deactivate_ui();\r

  \      let numbers = [];\r

  \      for (const el of selection) {\r

  \        if (el == 'last') {\r

  \          numbers.push(A.items.length - 1);\r

  \        } else if (el == 'random') {\r

  \          numbers.push(rNumber(0, A.items.length - 1));\r

  \        } else if (isString(el)) {\r

  \          let commands = A.items.map(x => x.key);\r

  \          let idx = commands.indexOf(el);\r

  \          numbers.push(idx);\r

  \        } else numbers.push(el);\r

  \      }\r

  \      selection = numbers;\r

  \      A.selected = selection;\r

  \      if (selection.length == 1) A.command = A.items[A.selected[0]].key;\r

  \      A.last_selected = A.items[A.selected[0]];\r

  \      select_highlight();\r

  \      setTimeout(() => {\r

  \        if (A.callback) A.callback();\r

  \      }, 1000);\r

  \    } else { activate_ui(); }\r

  \  } else { activate_ui(); }\r

  }"
select_clear_previous_level: "function select_clear_previous_level() {\r

  \  let A = Z.A;\r

  \  if (!isEmpty(A.items)) {\r

  \    console.assert(A.level >= 1, 'have items but level is ' + A.level);\r

  \    A.ll.push({ items: A.items, selected: A.selected });\r

  \    let dsel = Z.game == 'accuse'?mBy(`dTitleMiddle`):mBy(`dSelections1`);
  \r

  \    mStyle(dsel, { display: 'flex', 'align-items': 'center', padding: 10,
  box: true, gap: 10 });\r

  \    for (const item of A.items) {\r

  \      ari_make_unselectable(item);\r

  \      if (A.keep_selection) continue;\r

  \      ari_make_unselected(item);\r

  \      if (!A.selected.includes(item.index)) continue;\r

  \      if (item.itemtype == 'card') {\r

  \        let d = iDiv(item);\r

  \        let card = item.o;\r

  \        let mini = mDiv(dsel, { bg: 'yellow', fg: 'black', hpadding: 2,
  border: '1px solid black' }, null, card.friendly);\r

  \      } else if (item.itemtype == 'container') {\r

  \        let list = item.o.list;\r

  \        let cards = list.map(x => ari_get_card(x, 30, 30 * .7));\r

  \        let cont2 = ui_make_hand_container(cards, dsel, { bg: 'transparent'
  });\r

  \        ui_add_cards_to_hand_container(cont2, cards, list);\r

  \      } else if (item.itemtype == 'string') {\r

  \        let db = mDiv(dsel, { bg: 'yellow', fg: 'black', border: 'black',
  hpadding: 4 }, item.id, item.a);\r

  \      } else if (item.itemtype == 'color') {\r

  \        let db = mDiv(dsel, { bg: item.a, fg: 'contrast', border: 'black',
  hpadding: 4 }, item.id, item.a);\r

  \      } else if (item.itemtype == 'player') {\r

  \        let db = mDiv(dsel, {  }, item.id, `<span
  style=\"color:${get_user_color(item.a)};font-weight:bold\"> ${item.a}
  </span>`);\r

  \      }\r

  \    }\r

  \  }\r

  }"
select_confirm_weiter: "function select_confirm_weiter(callback) {\r

  \  select_add_items(ui_get_string_items(['weiter']), callback, 'may click to
  continue', 1, 1, Z.mode == 'multi');\r

  }"
select_error: "function select_error(msg, callback = null, stay = false) {\r

  \  let [A] = [Z.A];\r

  \  DA.callback = callback;\r

  \  if (A.maxselected == 1 && A.selected.length > 0) {\r

  \    let item = A.items[A.selected[0]];\r

  \    ari_make_unselected(item);\r

  \    A.selected = [];\r

  \  } else if (A.selected.length == 2) {\r

  \    let item = A.items[A.selected[1]];\r

  \    ari_make_unselected(item);\r

  \    A.selected = [A.selected[0]];\r

  \  }\r

  \  dError.innerHTML = msg;\r

  \  if (stay) {\r

  \    dError.innerHTML += '<br><button
  onclick=\"continue_after_error()\">CLICK TO CONTINUE</button>';\r

  \  } else {\r

  \    TO.error = setTimeout(continue_after_error, 3000);\r

  \  }\r

  }"
select_highlight: function select_highlight() { let A = Z.A; for (const i of
  A.selected) { let a = A.items[i]; ari_make_selected(a, true); } }
select_last: "function select_last(item, callback, ev) {\r

  \  if (isdef(ev)) evNoBubble(ev);\r

  \  Z.A.last_selected = item; callback(item, ev);\r

  }"
select_timer: "function select_timer(ms, callback) {\r

  \  let d = mBy('dSelections0');\r

  \  let dtimer = mDiv(d, { w: 80, maleft: 10, fg: 'red', weight: 'bold' },
  'dTimer');\r

  \  if (isdef(DA.timer)) { DA.timer.clear(); DA.timer = null; }\r

  \  let timer = DA.timer = new SimpleTimer(dtimer, 1000, null, ms,
  callback);\r

  \  timer.start();\r

  \  return dtimer;\r

  }"
select_toggle: "function select_toggle() { \r

  \  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }\r

  \  let A = Z.A;\r

  \  let item = A.last_selected;\r

  \  if (A.selected.includes(item.index)) {\r

  \    removeInPlace(A.selected, item.index);\r

  \    ari_make_unselected(item);\r

  \  } else {\r

  \    if (A.maxselected == 1 && !isEmpty(A.selected)) {
  ari_make_unselected(A.items[A.selected[0]]); A.selected = []; }\r

  \    A.selected.push(item.index);\r

  \    ari_make_selected(item);\r

  \    if (!DA.ai_is_moving && A.selected.length >= A.maxselected &&
  A.autosubmit) {\r

  \      setTimeout(() => A.callback(), 100);\r

  \    }\r

  \  }\r

  }"
start_transaction: "function start_transaction() {\r

  \  if (DA.simulate) return;\r

  \  DA.simulate = true;\r

  \  DA.snapshot = { fen: jsCopy(Z.fen), stage: Z.stage, round: Z.round,
  phase: Z.phase, turn: Z.turn }; \r

  \  DA.transactionlist = [];\r

  }"
stop_timer: "function stop_timer() {\r

  \  if (isdef(DA.timer)) {\r

  \    let res = DA.timer.clear();\r

  \    DA.timer = null;\r

  \    return isNumber(res) ? res : 0;\r

  \  }\r

  \  return 0;\r

  }"
add_to_chain: function add_to_chain(list) { DA.chain = DA.chain.concat(list); }
ari_test_hand_to_discard: "function ari_test_hand_to_discard(fen, uname, keep =
  0) {\r

  \  let list = fen.players[uname].hand;\r

  \  while (fen.open_discard.length < 4 && list.length > keep)
  top_elem_from_to(list, fen.open_discard);\r

  \  while (list.length > keep) top_elem_from_to(list, fen.deck_discard);\r

  }"
ari_ut0_create_staged: "function ari_ut0_create_staged() {\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);\r

  \  }\r

  \  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');\r

  \  fen.players.leo.hand = 'ACb ASb 2Db 4Db 6Db KDb QSb'.split(' ');\r

  \  fen.players.mimi.buildings.farm = [{ list: '4Cr 4Sr 4Sb 4Dr'.split(' '),
  h: null }, { list: '5Cr 5Sr 5Sb 5Dr'.split(' '), h: null }];\r

  \  fen.players.mimi.buildings.estate = [{ list: 'TCr TSr TSb TDr
  TDb'.split(' '), h: null }];\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut1_create_staged: "function ari_ut1_create_staged() {\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  top_elem_from_to(fen.deck, fen.market);\r

  \  top_elem_from_to(fen.deck, fen.market);\r

  \  fen.stage = 4;\r

  \  top_elem_from_to(fen.players.mimi.hand, fen.players.mimi.stall);\r

  \  top_elem_from_to(fen.players.mimi.hand, fen.players.mimi.stall);\r

  \  fen.iturn = 1;\r

  \  fen.turn = ['leo'];\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut10_create_staged: "function ari_ut10_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut100_create_staged: "function ari_ut100_create_staged() { \r

  \  console.log('*** test 100: tax ***');\r

  \  DA.test.number = 100;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];\r

  \  let fen = ari_setup(player_names);\r

  \  ari_test_hand_to_discard(fen, 'mimi'); \r

  \  deck_add(fen.deck, 3, fen.players.amanda.hand); \r

  \  ari_test_hand_to_discard(fen, 'felix', 3); \r

  \  deck_add(fen.deck, 1, fen.players.blade.hand); \r

  \  let sz = ARI.sz_hand;\r

  \  fen.pl_tax = { mimi: -sz, amanda: 3, felix: -sz + 3, lauren: 0, blade: 1
  };\r

  \  [fen.iturn, fen.turn] = [1, ['amanda']];\r

  \  fen.stage = 2;\r

  \  DA.fen0 = fen;\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  DA.iter_verify = 3;\r

  \  DA.verify = (ot) => {\r

  \    let res = forAll(ot.plorder, x => ot[x].hand.length <= sz);\r

  \    if (!res) for (const uname of ot.plorder) console.log('pl', uname,
  'hand', ot[uname].hand.length, 'should be', Math.min(sz,
  DA.fen0.players[uname].hand.length));\r

  \    return res;\r

  \  };\r

  \  DA.auto_moves = {\r

  \    amanda_1: [[0, 1, 2]],\r

  \    blade_2: [[0]],\r

  \  }\r

  \  return [fen, player_names];\r

  }"
ari_ut101_create_staged: "function ari_ut101_create_staged() { \r

  \  console.log('*** test 101: stall selection 5 players ***');\r

  \  DA.test.number = 101;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];\r

  \  let fen = ari_setup(player_names);\r

  \  ari_test_hand_to_discard(fen, 'mimi'); \r

  \  ari_test_hand_to_discard(fen, 'felix'); \r

  \  fen.stage = 3;\r

  \  DA.fen0 = fen;\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  DA.iter_verify = 6;\r

  \  DA.verify = (ot) => {\r

  \    let stall_sz = { mimi: 0, amanda: 3, felix: 0, lauren: 1, blade: 2 };\r

  \    let res = forAll(ot.plorder, x => ot[x].stall.length == stall_sz[x]);\r

  \    if (!res) for (const uname of ot.plorder) console.log('pl', uname,
  'stall', ot[uname].stall.length, 'should be', stall_sz[uname]);\r

  \    return res;\r

  \  };\r

  \  DA.auto_moves = {\r

  \    amanda_2: [[0, 1, 2]],\r

  \    lauren_4: [[0]],\r

  \    blade_5: [[0, 1]],\r

  \  }\r

  \  return [fen, player_names];\r

  }"
ari_ut102_create_staged: "function ari_ut102_create_staged() { \r

  \  console.log('*** test 102: stall selection mimi-leo ***');\r

  \  DA.test.number = 102;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  ari_test_hand_to_discard(fen, 'mimi'); \r

  \  fen.stage = 3;\r

  \  DA.fen0 = fen;\r

  \  DA.iter_verify = 3;\r

  \  DA.verify = (ot) => {\r

  \    let stall_sz = { mimi: 0, leo: 3 };\r

  \    let res = forAll(ot.plorder, x => ot[x].stall.length == stall_sz[x]);\r

  \    if (!res) for (const uname of ot.plorder) console.log('pl', uname,
  'stall', ot[uname].stall.length, 'should be', stall_sz[uname]);\r

  \    return res;\r

  \  };\r

  \  DA.auto_moves = {\r

  \    leo_2: [[0, 1, 2]],\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut103_create_staged: "function ari_ut103_create_staged() { \r

  \  console.log('*** test 103: trade ***');\r

  \  DA.test.number = 103;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen, 2);\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = {\r

  \    mimi_1: [['trade'], [1, 3]],\r

  \    mimi_2: [['pass']],\r

  \    leo_3: [['trade'], [1, 3]],\r

  \    leo_4: [['pass']],\r

  \  };\r

  \  DA.iter_verify = 5;\r

  \  DA.verify = (ot) => {\r

  \    let res = firstCond(ot.mimi.hand, x => x == DA.fen0.market[1]);\r

  \    if (!res) console.log('mimi stall does not contain market card from
  start!!!');\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut104_create_staged: "function ari_ut104_create_staged() { \r

  \  console.log('*** test 104: downgrade from estate to farm ***');\r

  \  DA.test.number = 104;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_building(fen, fen.iturn, 'estate');\r

  \  DA.fen0 = fen;\r

  \  DA.iter_verify = 2;\r

  \  DA.verify = (ot) => {\r

  \    let stall_sz = { mimi: 0, leo: 3 };\r

  \    let res = ot.mimi.buildings.farm.length == 1 &&
  ot.mimi.buildings.estate.length == 0;\r

  \    if (!res) console.log('mimi buildings', ot.mimi.buildings);\r

  \    return res;\r

  \  };\r

  \  DA.auto_moves = {\r

  \    mimi_1: [['downgrade'], [0]],\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut105_create_staged: "function ari_ut105_create_staged() { \r

  \  console.log('*** test 105: visit ***');\r

  \  DA.test.number = 105;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo', 'meckele'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_replace_hand_cards_by(fen, 'mimi', ['QSy']);\r

  \  stage_building(fen, fen.iturn, 'estate');\r

  \  stage_building(fen, 1, 'estate');\r

  \  stage_building(fen, 2, 'estate');\r

  \  fen.phase = 'queen';\r

  \  DA.fen0 = fen;\r

  \  DA.iter_verify = 2;\r

  \  DA.verify = (ot) => {\r

  \    let uname_visited = ot.uname;\r

  \    let building = ot[uname_visited].buildings.estate[0];\r

  \    let res = ot.mimi.coins == 2 || ot.mimi.coins == 4 ||
  ot.mimi.hand.length + ot.mimi.stall.length == 6;\r

  \    if (!res) console.log('mimi visit payment did not work!',
  building.list);\r

  \    return res;\r

  \  };\r

  \  DA.auto_moves = {\r

  \    mimi_1: [['visit'], [0], [0], ['pass']],\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut106_create_staged: "function ari_ut106_create_staged() { \r

  \  console.log('*** test 106: double visit ***');\r

  \  DA.test.number = 106;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo', 'meckele'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_replace_hand_cards_by(fen, 'mimi', ['QSy', 'QSg']);\r

  \  stage_building(fen, fen.iturn, 'estate');\r

  \  stage_building(fen, 1, 'chateau');\r

  \  stage_building(fen, 2, 'chateau');\r

  \  fen.phase = 'queen';\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = {\r

  \    mimi_1: [['visit'], [0], [0]],\r

  \    mimi_2: [['visit'], [0], [0]],\r

  \  };\r

  \  DA.iter_verify = 3;\r

  \  DA.verify = (ot) => {\r

  \    let uname_visited = ot.plorder[1];\r

  \    let chateau = ot[uname_visited].buildings.chateau;\r

  \    console.log('chateau:', uname_visited, chateau);\r

  \    let res = ot.mimi.coins == 5 ||
  ot[uname_visited].buildings.chateau.length == 0;\r

  \    if (!res) console.log('double visit failed or building is
  correct!!!');\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut107_create_staged: "function ari_ut107_create_staged() { \r

  \  console.log('*** test 107: end game ***');\r

  \  DA.test.number = 107;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_correct_buildings(fen, { mimi: { farm: 2, estate: 2, chateau: 1 },
  leo: { farm: 3 } });\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = {\r

  \    mimi_1: [['pass']],\r

  \    leo_2: [['pass']],\r

  \    3: [[0]], \r

  \  };\r

  \  DA.iter_verify = 4;\r

  \  DA.verify = (ot) => {\r

  \    let res = ot.winners = 'mimi';\r

  \    if (!res) console.log('end game mimi should win didnt work!', ot);\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut108_create_staged: "function ari_ut108_create_staged() { \r

  \  console.log('*** test 108: buy from open discard ***');\r

  \  DA.test.number = 108;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  fen.open_discard = deck_deal(fen.deck, 4);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_correct_buildings(fen, { mimi: { farm: 2, estate: 2, chateau: 1 },
  leo: { farm: 3 } });\r

  \  fen.phase = 'jack';\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = {\r

  \    mimi_1: [['buy'], [0], [0]],\r

  \  };\r

  \  DA.iter_verify = 2;\r

  \  DA.verify = (ot) => {\r

  \    let res = ot.open_discard.length == 3 && ot.mimi.hand.length == 5 &&
  ot.mimi.coins == 2\r

  \      || arrLast(ot.open_discard)[0] == 'J' && ot.mimi.hand.length == 4 &&
  ot.mimi.coins == 3;\r

  \    if (!res) console.log('buy form discard does not work!', ot.mimi,
  ot.open_discard);\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut109_create_staged: "function ari_ut109_create_staged() { \r

  \  console.log('*** test 109: harvest ***');\r

  \  DA.test.number = 109;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo', 'meckele'];\r

  \  let fen = ari_setup(player_names);\r

  \  fen.open_discard = deck_deal(fen.deck, 4);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_correct_buildings(fen, { mimi: { farm: 2, estate: 2 }, leo: { farm:
  3 }, meckele: { farm: 2 } });\r

  \  fen.phase = 'jack';\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = [\r

  \    [[]],\r

  \    [['pass']], [['pass']], [['pass']], \r

  \    [[0]], [[0]], [[0]], \r

  \    [[0, 1]], [[0, 1]], [[0, 1]], \r

  \    [['harvest'], [0]],\r

  \  ];\r

  \  DA.iter_verify = 11;\r

  \  DA.verify = (ot) => {\r

  \    let uname = ot.uname;\r

  \    let res = ot[uname].buildings.farm[0].h == null &&
  ot[uname].hand.length == 6;\r

  \    if (!res) console.log('harvest FAIL!', ot[uname]);\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut11_create_staged: "function ari_ut11_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  let [mimi, leo] = [fen.players.mimi, fen.players.leo];\r

  \  mimi.buildings.farm = [{ list: deck_deal(fen.deck, 4), h: null }];\r

  \  leo.buildings.farm = [{ list: deck_deal(fen.deck, 4), h: null }];\r

  \  fen.open_discard = deck_deal(fen.deck, 4);\r

  \  fen.market = deck_deal(fen.deck, 2);\r

  \  fen.phase = 'king';\r

  \  arisim_stage_4(fen, 3, 3);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut110_create_staged: "function ari_ut110_create_staged() { \r

  \  console.log('*** test 110: end game 2 ***');\r

  \  DA.test.number = 110;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  fen.open_discard = deck_deal(fen.players.mimi.hand, 2);\r

  \  deck_add(fen.players.leo.hand, 2, fen.open_discard);\r

  \  stage_correct_buildings(fen, { mimi: { farm: 2, estate: 2, chateau: 1 },
  leo: { farm: 3 } });\r

  \  fen.phase = 'jack';\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = [\r

  \    [[]],\r

  \    [['pass']], [['pass']], \r

  \    [[0]], [[0]], \r

  \    [['pass']], [['pass']], \r

  \    [[1]], \r

  \  ];\r

  \  DA.iter_verify = 8;\r

  \  DA.verify = (ot) => {\r

  \    let res = ot.stage == 3;\r

  \    if (!res) console.log('Not ending game FAIL!', ot.stage);\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut111_create_staged: "function ari_ut111_create_staged() { \r

  \  console.log('*** test 111: auction payment test ***');\r

  \  DA.test.number = 111;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo', 'meckele'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  fen.open_discard = deck_deal(fen.players.mimi.hand, 2);\r

  \  deck_add(fen.players.leo.hand, 2, fen.open_discard);\r

  \  fen.phase = 'queen';\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = {\r

  \    1: [['pass']],\r

  \    2: [['pass']],\r

  \    3: [['pass']],\r

  \    4: [[0]],\r

  \    5: [[1]],\r

  \    6: [[2]],\r

  \    7: [[0]],\r

  \  };\r

  \  DA.iter_verify = 8;\r

  \  DA.verify = (ot) => {\r

  \    let coins = ot.plorder.map(x => ot[x].coins);\r

  \    let sum = arrSum(coins);\r

  \    let res = sum == 8;\r

  \    if (!res) console.log('payment for auction card wrong', coins, sum);\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut112_create_staged: "function ari_ut112_create_staged() { \r

  \  console.log('*** test 112: auction payment test 2 ***');\r

  \  DA.test.number = 112;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo', 'meckele', 'felix', 'amanda'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  fen.phase = 'queen';\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = {\r

  \    1: [['pass']],\r

  \    2: [['pass']],\r

  \    3: [['pass']],\r

  \    4: [['pass']],\r

  \    5: [['pass']],\r

  \    6: [[1]],\r

  \    7: [[0]],\r

  \    8: [[2]],\r

  \    9: [[2]],\r

  \    10: [[1]],\r

  \    11: [[0]], \r

  \    12: [[1]], \r

  \  };\r

  \  DA.iter_verify = 13;\r

  \  DA.verify = (ot) => {\r

  \    let coins = ot.plorder.map(x => ot[x].coins);\r

  \    let sum = arrSum(coins);\r

  \    let res = sum == 11;\r

  \    if (!res) console.log('payment for auction card wrong', coins, sum);\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut113_create_staged: "function ari_ut113_create_staged() { \r

  \  console.log('*** test 113: buy from open discard w/ jack ***');\r

  \  DA.test.number = 113;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  fen.open_discard = deck_deal(fen.deck, 4);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_replace_hand_cards_by(fen, 'mimi', ['JSy']);\r

  \  stage_correct_buildings(fen, { mimi: { farm: 2, estate: 2, chateau: 1 },
  leo: { farm: 3 } });\r

  \  fen.phase = 'jack';\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = {\r

  \    mimi_1: [['buy'], [0], [0]],\r

  \  };\r

  \  DA.iter_verify = 2;\r

  \  DA.verify = (ot) => {\r

  \    let res = ot.open_discard.length == 3 && ot.mimi.hand.length == 5 &&
  ot.mimi.coins == 2\r

  \      || arrLast(ot.open_discard)[0] == 'J' && ot.mimi.hand.length == 4 &&
  ot.mimi.coins == 3;\r

  \    if (!res) console.log('buy form discard does not work!', ot.mimi,
  ot.open_discard);\r

  \    return res;\r

  \  };\r

  \  return [fen, player_names];\r

  }"
ari_ut12_create_staged: "function ari_ut12_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];\r

  \  let fen = ari_setup(player_names);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut13_create_staged: "function ari_ut13_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];\r

  \  let fen = ari_setup(player_names);\r

  \  ari_test_hand_to_discard(fen, 'mimi');\r

  \  ari_test_hand_to_discard(fen, 'lauren');\r

  \  console.log('mimi', fen.players.mimi)\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut14_create_staged: "function ari_ut14_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];\r

  \  let fen = ari_setup(player_names);\r

  \  DA.fen0 = jsCopy(fen);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all(fen, 1);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  DA.iter_verify = 2;\r

  \  DA.verify = (ot) => {\r

  \    let plast = arrLast(ot.round);\r

  \    let ok = sameList(ot[plast].hand, DA.fen0.players[plast].hand);\r

  \    console.log('pl', plast, 'hand', ot[plast].hand, 'should be',
  DA.fen0.players[plast].hand);\r

  \    return ok;\r

  \  }\r

  \  return [fen, player_names];\r

  }"
ari_ut15_create_staged: "function ari_ut15_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];\r

  \  let fen = DA.fen0 = ari_setup(player_names);\r

  \  ari_test_hand_to_discard(fen, 'mimi');\r

  \  ari_test_hand_to_discard(fen, 'amanda');\r

  \  ari_test_hand_to_discard(fen, 'lauren');\r

  \  ari_test_hand_to_discard(fen, 'blade');\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  DA.iter_verify = 3;\r

  \  DA.verify = (ot) => ot.uname == 'felix';\r

  \  return [fen, player_names];\r

  }"
ari_ut16_create_staged: "function ari_ut16_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut2_create_staged: "function ari_ut2_create_staged() {\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4(fen);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut206_create_staged: "function ari_ut206_create_staged() { \r

  \  console.log('*** test 206: prep double visit ***');\r

  \  DA.test.number = 206;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo', 'meckele'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_replace_hand_cards_by(fen, 'mimi', ['QSy', 'QSg']);\r

  \  stage_building(fen, fen.iturn, 'estate');\r

  \  fen.players.leo.buildings.farm = [{ list: '4Cy 4Sy 4Hy 6Dy'.split(' '),
  h: null }, { list: '5Cy JSy 5Sy 5Dy'.split(' '), h: null }];\r

  \  fen.phase = 'queen';\r

  \  DA.fen0 = fen;\r

  \  return [fen, player_names];\r

  }"
ari_ut3_create_staged: "function ari_ut3_create_staged() {\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);\r

  \  }\r

  \  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');\r

  \  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');\r

  \  fen.players.mimi.buildings.farm = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '),
  h: null }];\r

  \  fen.players.leo.buildings.estate = [{ list: 'TCr 7Sr TSb TDr TDb'.split('
  '), h: null }];\r

  \  fen.market = 'KSb 3Sb'.split(' ');\r

  \  arisim_stage_4(fen, 3, 2);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut306_create_staged: "function ari_ut306_create_staged() { \r

  \  console.log('*** test 306: prep double visit ***');\r

  \  DA.test.number = 306;\r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo', 'meckele'];\r

  \  let fen = ari_setup(player_names);\r

  \  arisim_stage_3(fen);\r

  \  arisim_stage_4_all_mimi_starts(fen);\r

  \  stage_replace_hand_cards_by(fen, 'mimi', ['QSy', 'QSg']);\r

  \  stage_building(fen, fen.iturn, 'estate');\r

  \  fen.players.leo.buildings.farm = [{ list: '4Cy 4Sy 4Hy 6Dy'.split(' '),
  h: null }, { list: '5Cy JSy 5Sy 5Dy'.split(' '), h: null }];\r

  \  fen.phase = 'queen';\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = [[],\r

  \  [['visit'], ['last'], [0]],\r

  \  [['visit'], ['last'], [1]],\r

  \  [['pass']],\r

  \  ];\r

  \  return [fen, player_names];\r

  }"
ari_ut4_create_staged: "function ari_ut4_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);\r

  \  }\r

  \  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');\r

  \  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');\r

  \  fen.players.mimi.buildings.farm = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '),
  h: null }];\r

  \  fen.players.leo.buildings.estate = [{ list: 'TCr 7Sr TSb TDr TDb'.split('
  '), h: null }];\r

  \  fen.market = 'KSb 3Sb'.split(' ');\r

  \  fen.phase = 'queen';\r

  \  fen.stage = 11;\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut5_create_staged: "function ari_ut5_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);\r

  \  }\r

  \  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');\r

  \  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');\r

  \  fen.players.mimi.buildings.farm = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '),
  h: null }];\r

  \  fen.players.leo.buildings.estate = [{ list: 'TCr 7Sr TSb TDr TDb'.split('
  '), h: null }];\r

  \  fen.phase = 'jack';\r

  \  fen.stage = 3;\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut6_create_staged: "function ari_ut6_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);\r

  \  }\r

  \  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');\r

  \  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');\r

  \  fen.players.mimi.buildings.farm = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '),
  h: null }];\r

  \  fen.players.leo.buildings.estate = [{ list: 'TCr 7Sr TSb TDr TDb'.split('
  '), h: null }];\r

  \  for (let i = 0; i < 3; i++) {\r

  \    top_elem_from_to(fen.deck, fen.market);\r

  \  }\r

  \  fen.phase = 'jack';\r

  \  arisim_stage_4(fen);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut7_create_staged: "function ari_ut7_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);\r

  \  }\r

  \  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb QCb QDb'.split(' ');\r

  \  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');\r

  \  fen.players.mimi.buildings.farm = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '),
  h: null }];\r

  \  fen.players.leo.buildings.estate = [{ list: 'TCr 7Sr TSb TDr TDb'.split('
  '), h: null }];\r

  \  for (let i = 0; i < 3; i++) {\r

  \    top_elem_from_to(fen.deck, fen.market);\r

  \  }\r

  \  fen.phase = 'jack';\r

  \  arisim_stage_4(fen);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut8_create_staged: "function ari_ut8_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  deck_add(fen.deck, 1, fen.players.mimi.hand); //'AHb ADb 2Cb 4Cb 6Cb QCb
  QDb'.split(' ');\r

  \  //deck_add(fen.deck, 2, fen.players.leo.hand); //'ACb KDb QSb ASb 2Db 4Db
  6Db'.split(' ');\r

  \  fen.players.mimi.buildings.farm = [{ list: deck_deal(fen.deck, 4), h:
  '3Hb' }];\r

  \  fen.players.leo.buildings.farm = [{ list: deck_deal(fen.deck, 4), h: null
  }];\r

  \  fen.players.leo.buildings.estate = [{ list: deck_deal(fen.deck, 5), h:
  null }];\r

  \  fen.market = deck_deal(fen.deck, 3);\r

  \  fen.phase = 'jack';\r

  \  arisim_stage_4(fen);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
ari_ut9_create_staged: "function ari_ut9_create_staged() { \r

  \  Session.cur_game = 'gAristo';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = ari_setup(player_names);\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);\r

  \  }\r

  \  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb QCb QDb'.split(' ');\r

  \  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');\r

  \  fen.players.mimi.buildings.farm = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '),
  h: '3Hb' }];\r

  \  fen.players.leo.buildings.farm = [{ list: 'JCr JSr JSb JDr'.split(' '),
  h: '3Sr' }];\r

  \  fen.players.leo.buildings.estate = [{ list: 'TCr 7Sr TSb TDr TDb'.split('
  '), h: null }];\r

  \  for (let i = 0; i < 3; i++) {\r

  \    top_elem_from_to(fen.deck, fen.market);\r

  \  }\r

  \  fen.phase = 'king';\r

  \  arisim_stage_4(fen);\r

  \  DA.staged_moves = [];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
arisim_stage_3: "function arisim_stage_3(fen) {\r

  \  top_elem_from_to(fen.deck, fen.market);\r

  \  top_elem_from_to(fen.deck, fen.market);\r

  \  if (fen.phase == 'jack') top_elem_from_to(fen.deck, fen.market);\r

  \  fen.stage = 4;\r

  }"
arisim_stage_4: "function arisim_stage_4(fen, n_mimi = 2, n_leo = 3) {\r

  \  for (let i = 0; i < n_mimi; i++) top_elem_from_to(fen.players.mimi.hand,
  fen.players.mimi.stall);\r

  \  for (let i = 0; i < n_leo; i++)  top_elem_from_to(fen.players.leo.hand,
  fen.players.leo.stall);\r

  \  fen.stage = 5;\r

  \  let valmimi = fen.players.mimi.stall_value =
  arrSum(fen.players.mimi.stall.map(x => ari_get_card(x).val));\r

  \  let valleo = fen.players.leo.stall_value =
  arrSum(fen.players.leo.stall.map(x => ari_get_card(x).val));\r

  \  let minplayer = valmimi <= valleo ? 'mimi' : 'leo';\r

  \  fen.iturn = fen.plorder.indexOf(minplayer); fen.turn = [minplayer];\r

  \  fen.num_actions = fen.total_pl_actions =
  fen.players[minplayer].stall.length;\r

  \  fen.action_number = 1;\r

  }"
arisim_stage_4_all: "function arisim_stage_4_all(fen, n = 3, changeturn = true)
  {\r

  \  for (let i = 0; i < n; i++) top_elem_from_to(fen.players.mimi.hand,
  fen.players.mimi.stall);\r

  \  let others = get_keys(fen.players).filter(x => x != 'mimi');\r

  \  for (const plname of others) {\r

  \    for (let i = 0; i < n; i++)  top_elem_from_to(fen.players[plname].hand,
  fen.players[plname].stall);\r

  \  }\r

  \  let list = [];\r

  \  for (const plname of get_keys(fen.players)) {\r

  \    fen.players[plname].stall_value =
  arrSum(fen.players[plname].stall.map(x => ari_get_card(x).val));\r

  \    list.push({ uname: plname, val: fen.players[plname].stall_value });\r

  \  }\r

  \  fen.stage = 5;\r

  \  list = sortBy(list, 'val');\r

  \  let minplayer = list[0].uname;\r

  \  fen.iturn = fen.plorder.indexOf(minplayer);\r

  \  if (changeturn) fen.turn = [minplayer];\r

  \  fen.num_actions = fen.total_pl_actions =
  fen.players[fen.turn[0]].stall.length;\r

  \  fen.action_number = 1;\r

  }"
arisim_stage_4_all_mimi_starts: "function arisim_stage_4_all_mimi_starts(fen, n
  = 3) {\r

  \  for (let i = 0; i < n; i++) top_elem_from_to(fen.players.mimi.hand,
  fen.players.mimi.stall);\r

  \  let others = get_keys(fen.players).filter(x => x != 'mimi');\r

  \  for (const uname of others) {\r

  \    for (let i = 0; i < n; i++)  top_elem_from_to(fen.players[uname].hand,
  fen.players[uname].stall);\r

  \  }\r

  \  let list = [];\r

  \  for (const uname of get_keys(fen.players)) {\r

  \    fen.players[uname].stall_value = arrSum(fen.players[uname].stall.map(x
  => ari_get_card(x).val));\r

  \    list.push({ uname: uname, val: fen.players[uname].stall_value });\r

  \  }\r

  \  fen.stage = 5;\r

  \  list = sortBy(list, 'val');\r

  \  let minplayer = list[0].uname;\r

  \  if (minplayer != 'mimi') {\r

  \    console.log('NOT mimi!!! minplayer', minplayer)\r

  \    let best_stall = fen.players[minplayer].stall;\r

  \    let best_stall_value = fen.players[minplayer].stall_value;\r

  \    fen.players[minplayer].stall = fen.players.mimi.stall;\r

  \    fen.players[minplayer].stall_value = fen.players.mimi.stall_value;\r

  \    fen.players.mimi.stall = best_stall;\r

  \    fen.players.mimi.stall_value = best_stall_value;\r

  \    minplayer = 'mimi';\r

  \  }\r

  \  fen.iturn = fen.plorder.indexOf(minplayer);\r

  \  fen.turn = [minplayer];\r

  \  console.assert(fen.turn == ['mimi'], 'WTF?????????????????');\r

  \  fen.num_actions = fen.total_pl_actions =
  fen.players[minplayer].stall.length;\r

  \  fen.action_number = 1;\r

  }"
ferro_ut0_create_staged: "function ferro_ut0_create_staged() { \r

  \  console.log('*** test ferro 0: buy_or_pass with no coins ***');\r

  \  DA.test.number = 0;\r

  \  let [fen, uplayer] = [o.fen, o.fen.turn[0]];\r

  \  let otherplayer = firstCond(fen.plorder, (p) => p != uplayer);\r

  \  let pl = fen.players[otherplayer];\r

  \  pl.coins = 0;\r

  \  DA.fen0 = fen;\r

  \  DA.auto_moves = [[],\r

  \  [['visit'], ['last'], [0]],\r

  \  [['visit'], ['last'], [1]],\r

  \  [['pass']],\r

  \  ];\r

  \  return [fen, player_names];\r

  }"
inno_undo_random_deal: "function inno_undo_random_deal(fen) {\r

  \  for (const uname in fen.players) {\r

  \    let pl = fen.players[uname];\r

  \    last_elem_from_to(pl.hand, fen.decks.E[1]);\r

  \    last_elem_from_to(pl.hand, fen.decks.B[1]);\r

  \  }\r

  }"
inno_ut0_create_staged: "function inno_ut0_create_staged() {\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  console.log('fen', fen)\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('agriculture', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking',
  'mimi.board.yellow.agriculture', 'mimi.hand.comb',\r

  \    'leo.board.red.metalworking', 'leo.board.red.metalworking',
  'mimi.board.yellow.agriculture', 'pass', 'mimi.board.yellow.agriculture',
  'pass'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut1_create_staged: "function inno_ut1_create_staged() {\r

  \  console.log('*** TEST: activate agriculture ***');\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('agriculture', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking',
  'mimi.board.yellow.agriculture', 'mimi.hand.comb'];\r

  \  DA.iter = 13;\r

  \  return [fen, player_names];\r

  }"
inno_ut10_create_staged: "function inno_ut10_create_staged() {\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('agriculture', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking',
  'draw', 'draw', 'draw', 'draw'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut11_create_staged: "function inno_ut11_create_staged() {\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('agriculture', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking',
  'draw', 'draw', 'draw', 'draw', 'meld', 'meld', 'draw', 'draw', 'meld',
  'meld'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut12_create_staged: "function inno_ut12_create_staged() {\r

  \  console.log('*** TEST: activate code_of_laws ***');\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('code_of_laws', deck1, mimi.hand);\r

  \  elem_from_to('puppet', deck2, mimi.hand);\r

  \  elem_from_to('sailing', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  DA.staged_moves = ['mimi.hand.code_of_laws', 'leo.hand.sailing',
  'mimi.board.purple.code_of_laws', 'leo.hand.soap', 'mimi.hand.puppet'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut2_create_staged: "function inno_ut2_create_staged() {\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('agriculture', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut3_create_staged: "function inno_ut3_create_staged() {\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo', 'felix', 'amanda'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo, felix, amanda] = [fen.decks, fen.players.mimi,
  fen.players.leo, fen.players.felix, fen.players.amanda];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('wheel', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  elem_from_to('agriculture', deck1, felix.hand);\r

  \  elem_from_to('chopsticks', deck2, felix.hand);\r

  \  elem_from_to('pottery', deck1, amanda.hand);\r

  \  elem_from_to('dice', deck2, amanda.hand);\r

  \  DA.staged_moves = ['mimi.hand.wheel', 'leo.hand.metalworking',
  'felix.hand.agriculture', 'amanda.hand.dice'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut4_create_staged: "function inno_ut4_create_staged() {\r

  \  console.log('*** TEST: sharing agriculture ***');\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo', 'felix'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo, felix] = [fen.decks, fen.players.mimi,
  fen.players.leo, fen.players.felix];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('pottery', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  elem_from_to('agriculture', deck1, felix.hand);\r

  \  elem_from_to('chopsticks', deck2, felix.hand);\r

  \  DA.staged_moves = ['mimi.hand.pottery', 'leo.hand.soap',
  'felix.hand.agriculture'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut5_create_staged: "function inno_ut5_create_staged() {\r

  \  console.log('*** TEST: sharing metalworking ***');\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo', 'felix'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo, felix] = [fen.decks, fen.players.mimi,
  fen.players.leo, fen.players.felix];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('wheel', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  elem_from_to('agriculture', deck1, felix.hand);\r

  \  elem_from_to('chopsticks', deck2, felix.hand);\r

  \  DA.staged_moves = ['mimi.hand.wheel', 'leo.hand.metalworking',
  'felix.hand.agriculture', 'draw.decks.B.1'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut6_create_staged: "function inno_ut6_create_staged() {\r

  \  console.log('*** TEST: draw ***');\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('wheel', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  DA.staged_moves = ['mimi.hand.wheel', 'leo.hand.soap'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut7_create_staged: "function inno_ut7_create_staged() {\r

  \  console.log('*** TEST: draw 2 ***');\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('wheel', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('soap', deck2, leo.hand);\r

  \  DA.staged_moves = ['mimi.hand.wheel', 'leo.hand.soap', 'decks.E.1',
  'decks.B.1', 'decks.B.1'];\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut8_create_staged: "function inno_ut8_create_staged() {\r

  \  console.log('*** TEST: splay up ***');\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('agriculture', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('puppet', deck2, leo.hand);\r

  \  elem_from_to('chopsticks', deck2, mimi.board.yellow);\r

  \  elem_from_to('soap', deck2, mimi.board.yellow);\r

  \  elem_from_to('fermenting', decks.B[2], mimi.board.yellow);\r

  \  fen.players.mimi.splays.yellow = 3;\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
inno_ut9_create_staged: "function inno_ut9_create_staged() {\r

  \  console.log('*** TEST: splay complex ***');\r

  \  Session.cur_game = 'gPreinno';\r

  \  let player_names = ['mimi', 'leo'];\r

  \  let fen = inno_setup(player_names);\r

  \  let [decks, mimi, leo] = [fen.decks, fen.players.mimi,
  fen.players.leo];\r

  \  let deck1 = decks.B[1]; let deck2 = decks.E[1];\r

  \  inno_undo_random_deal(fen);\r

  \  elem_from_to('agriculture', deck1, mimi.hand);\r

  \  elem_from_to('comb', deck2, mimi.hand);\r

  \  elem_from_to('metalworking', deck1, leo.hand);\r

  \  elem_from_to('puppet', deck2, leo.hand);\r

  \  let mydeck1 = decks.B[1].map(x => ({ key: x, deck: decks.B[1] }));\r

  \  let mydeck2 = decks.B[2].map(x => ({ key: x, deck: decks.B[2] }));\r

  \  let mydeck3 = decks.B[3].map(x => ({ key: x, deck: decks.B[3] }));\r

  \  let mydecks = mydeck1.concat(mydeck2).concat(mydeck3);\r

  \  for (const x of mydecks) { elem_from_to(x.key, x.deck,
  mimi.board[inno_get_cardinfo(x.key).color]); }\r

  \  fen.players.mimi.splays.blue = 3;\r

  \  fen.players.mimi.splays.red = 0;\r

  \  fen.players.mimi.splays.green = 1;\r

  \  fen.players.mimi.splays.yellow = 2;\r

  \  fen.players.mimi.splays.purple = 2;\r

  \  DA.iter = 100;\r

  \  return [fen, player_names];\r

  }"
stage_building: "function stage_building(fen, i_pl, type) {\r

  \  let n = type == 'chateau' ? 6 : type == 'estate' ? 5 : 4;\r

  \  let plname = fen.plorder[i_pl];\r

  \  lookupSet(fen.players[plname], ['buildings', type], []);\r

  \  let building = { list: deck_deal(fen.deck, n), h: null, type: type,
  schweine: [] };\r

  \  building.lead = building.list[0];\r

  \  fen.players[plname].buildings[type].push(building);\r

  \  return building;\r

  }"
stage_building_new: "function stage_building_new(fen, i_pl, type, n_openschwein,
  n_closedschwein) {\r

  \  let n = type == 'chateau' ? 6 : type == 'estate' ? 5 : 4;\r

  \  let plname = fen.plorder[i_pl];\r

  \  lookupSet(fen.players[plname], ['buildings', type], []);\r

  \  let building = { list: deck_deal(fen.deck, 1), h: null, type: type,
  schweine: [] };\r

  \  let k = building.lead = building.list[0];\r

  \  let other = k[0] == 'Q' ? '2' : 'Q';\r

  \  let i, j;\r

  \  for (i = 1; i <= n_openschwein; i++) { building.schweine.push(i);
  building.list.push(other + rSuit('CSHD') + 'n'); }\r

  \  for (j = 1; j <= n_closedschwein; j++) { building.list.push(other +
  rSuit('CSHD') + 'n'); }\r

  \  while (building.list.length < n) { building.list.push(k); j++; }\r

  \  fen.players[plname].buildings[type].push(building); \r

  \  return building;\r

  }"
stage_correct_buildings: "function stage_correct_buildings(fen, o) { \r

  \  let ranks = toLetters('A23456789TJQK');\r

  \  let irank = 0;\r

  \  for (const uname in o) {\r

  \    let pl = fen.players[uname];\r

  \    let bo = pl.buildings;\r

  \    let dinums = o[uname];\r

  \    for (const type in dinums) {\r

  \      let n = dinums[type];\r

  \      for (let i = 0; i < n; i++) {\r

  \        let r = ranks[irank]; irank++;\r

  \        let s = type == 'farm' ? `${r}Cn ${r}Sn ${r}Sn ${r}Dn` :\r

  \          type == 'estate' ? `${r}Cn ${r}Sn ${r}Sn ${r}Dn ${r}Cn` : `${r}Cn
  ${r}Sn ${r}Sn ${r}Dn ${r}Cn ${r}Hn`;\r

  \        bo[type].push({ list: s.split(' '), h: null });\r

  \      }\r

  \    }\r

  \  }\r

  }"
test_engine_run_next: "function test_engine_run_next(list) {\r

  \  if (nundef(list)) {\r

  \    list = DA.test.list = arrRange(100, DA.test.number - 1); \r

  \  }\r

  \  if (isEmpty(list)) {\r

  \    console.log('*** all tests finished ***');\r

  \    DA.test.suiteRunning = DA.test.running = false;\r

  \    shield_off();\r

  \    return;\r

  \  }\r

  \  let n = list.shift();\r

  \  DA.test.iter = 0;\r

  \  onclick_ut_n('ari', n);\r

  }"
verify_unit_test: "function verify_unit_test(otree) {\r

  \  if (isdef(DA.verify) && DA.test.iter == DA.iter_verify) {\r

  \    DA.test.running = false;\r

  \    let res = DA.verify(otree);\r

  \    console.log('***UNIT TEST ' + DA.test.number, res ? 'passed...' :
  'FAILED!!!!!!!!!!!!!!!!');\r

  \    console.assert(res, '*** _ TEST FAIL ***')\r

  \    if (DA.test.suiteRunning) test_engine_run_next(DA.test.list);\r

  \  }\r

  \  return true;\r

  }"
